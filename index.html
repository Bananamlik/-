<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v8.1 UX Patch</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            /* [Theme] Jelly Cat Palette v6.2 */
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255,255,255,0.8), inset 0 -3px 6px rgba(0,0,0,0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body { 
            margin: 0; background-color: var(--bg-main); 
            background-image: var(--paw-pattern);
            background-size: 80px 80px; 
            color: var(--text-main); 
            font-family: var(--font-main);
            overflow: hidden; user-select: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; height: 100dvh; 
        }

        .screen-shake { animation: jelly-bounce 0.5s both; }
        @keyframes jelly-bounce { 
            0% { transform: scale(1, 1); } 
            30% { transform: scale(1.15, 0.85); } 
            40% { transform: scale(0.9, 1.1); }    
            50% { transform: scale(1.05, 0.95); } 
            65% { transform: scale(0.98, 1.02); } 
            100% { transform: scale(1, 1); } 
        }
        
        /* í”¼ê²© ì• ë‹ˆë©”ì´ì…˜: ì«€ë“í•˜ê²Œ í”ë“¤ë¦¼ (Chewy Shake) */
        @keyframes shake-chewy {
            0% { transform: scale(1, 1) translate(0,0) rotate(0deg); }
            15% { transform: scale(1.15, 0.85) translate(-4px, 1px) rotate(-4deg); }
            30% { transform: scale(0.9, 1.1) translate(4px, -1px) rotate(4deg); }
            45% { transform: scale(1.05, 0.95) translate(-3px, 1px) rotate(-3deg); }
            60% { transform: scale(0.95, 1.05) translate(3px, -1px) rotate(3deg); }
            75% { transform: scale(1.02, 0.98) translate(-1px, 0) rotate(-1deg); }
            100% { transform: scale(1, 1) translate(0,0) rotate(0deg); }
        }
        .shake { animation: shake-chewy 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both; }

        #flash-overlay { position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 999; transition: opacity 0.1s; }

        /* í„´ ì•Œë¦¼ ë°°ë„ˆ ìŠ¤íƒ€ì¼ */
        #turn-banner {
            position: fixed; top: 18%; left: 0; right: 0;
            padding: 15px 0;
            text-align: center; font-size: 32px; font-weight: 900;
            color: #fff; text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            pointer-events: none; z-index: 2000;
            opacity: 0; transform: scaleX(0);
            display: flex; justify-content: center; align-items: center; gap: 10px;
        }
        /* ë°°ë„ˆ ì• ë‹ˆë©”ì´ì…˜: ê¸°ë³¸ durationì€ JSì—ì„œ ì œì–´ */
        @keyframes banner-swipe {
            0% { opacity: 0; transform: translateX(-50%) scaleX(0.5); }
            20% { opacity: 1; transform: translateX(0) scaleX(1); }
            70% { opacity: 1; transform: translateX(0) scaleX(1); }
            100% { opacity: 0; transform: translateX(50%) scaleX(0.5); }
        }

        #app { width: 100%; max-width: 600px; height: 100%; position: relative; display: flex; flex-direction: column; }
        
        button { 
            font-family: var(--font-main); border-radius: 25px; border: none; 
            background: #fff; color: #777; cursor: pointer; transition: 0.1s; 
            box-shadow: var(--jelly-shadow); 
            transform: translateY(0); 
            position: relative; overflow: hidden;
        }
        button::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
            border-radius: 20px; pointer-events: none;
        }
        button:active { transform: translateY(3px) scale(0.98); box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); }
        
        .btn-restart { padding: 8px 12px; font-size: 14px; color: var(--accent); }
        .btn-restart:hover { background: #fff0f5; }

        /* ìŒì†Œê±° ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .mute-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .mute-btn:active { transform: scale(0.9); }
        .mute-btn.muted { background: #ffebee; color: #e57373; border-color: #ffcdd2; }

        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; padding: 15px; z-index: 10; }
        #selection-screen { background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); }
        #battle-screen { display: none; padding: 5px; }

        .hero-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; overflow-y: auto; padding: 10px; flex: 1; }
        
        .hero-card { 
            background: #fff; border-radius: 20px; padding: 8px; 
            cursor: pointer; transition: 0.2s; 
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05), inset 0 0 0 3px #fce4ec; 
            position: relative;
        }
        .hero-card:active { transform: scale(0.95); }
        .hero-card.selected { 
            background: #e1bee7; 
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }
        .hero-card.selected::after {
            content: 'ğŸ¾'; position: absolute; top: -10px; right: -5px;
            background: var(--accent); color: #fff; width: 28px; height: 28px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 16px; box-shadow: 0 3px 6px rgba(0,0,0,0.2); z-index: 5;
            border: 2px solid #fff;
        }

        .field-row { flex: 1; display: flex; justify-content: space-evenly; align-items: center; width: 100%; perspective: 1000px; }
        
        .unit {
            width: 30vw; max-width: 130px; 
            background: #fff; 
            border-radius: 25px; padding: 10px 5px; position: relative; transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            cursor: default; 
            box-shadow: inset 0 4px 10px rgba(255,255,255,1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0,0,0,0.1);
            text-align: center;
            display: flex; flex-direction: column; align-items: center;
            min-height: 125px; 
            justify-content: flex-end;
            border: 2px solid #f8bbd0;
        }
        .elec-badge {
            position: absolute; top: -5px; right: -5px;
            background: #ffeb3b; color: #f57f17;
            font-weight: 900; border: 2px solid #fff;
            border-radius: 50%; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 5; animation: jelly-bounce 1s infinite;
        }
        
        .unit.active-turn { 
            border-color: var(--accent); 
            transform: translateY(-12px) scale(1.05); 
            z-index: 5; 
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3); 
        }
        .unit.target-enemy:hover { border-color: #ff7043; background: #ffebee; cursor: crosshair; transform: scale(1.05) rotate(2deg); }
        .unit.target-ally:hover { border-color: #66bb6a; background: #e8f5e9; cursor: pointer; transform: scale(1.05) rotate(-2deg); }
        .unit.target-aoe { border-color: #ff7043; background: #ffebee; animation: jelly-bounce 1s infinite; cursor: pointer; }
        .unit.dead { opacity: 0.6; filter: grayscale(1); pointer-events: none; border-color: #cfd8dc; transform: scale(0.9) rotate(5deg); box-shadow: none; }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon { 
            width: 48px; height: 48px; border-radius: 50%; margin-bottom: 4px; 
            display: flex; justify-content: center; align-items: center; font-size: 28px; 
            color: #fff; position: relative; 
            box-shadow: 0 4px 0 rgba(0,0,0,0.1); 
            border: 3px solid #fff;
        }
        
        .mini-attr-box {
            position: absolute; bottom: -2px; right: -2px; 
            display: flex; gap: 1px; background: rgba(255,255,255,0.95); 
            padding: 2px; border-radius: 12px; border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .mini-icon { font-size: 12px; line-height: 1; }
        
        .status-bar { width: 85%; height: 12px; background: #eceff1; border-radius: 12px; overflow: hidden; position: relative; margin-top: 4px; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .hp-fill { height: 100%; background: var(--hp-high); border-radius: 10px; transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .hp-fill::after { content:''; position:absolute; top:2px; left:2px; right:2px; height:3px; background:rgba(255,255,255,0.4); border-radius:10px; }
        .shield-fill { position: absolute; top:0; left:0; height: 100%; background: var(--shield); opacity: 0.8; border-radius: 10px; transition: width 0.3s; }

        .control-panel { 
            flex: 0 0 auto; max-height: 45vh; 
            background: rgba(255,255,255,0.9); border-radius: 35px 35px 0 0; 
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15); 
            display: flex; flex-direction: column; overflow: hidden; width: 100%;
            border-top: 6px solid #ff80ab;
            backdrop-filter: blur(10px);
        }
        .cp-header { padding: 12px 20px; background: #fff8e1; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dashed #ffe082; }
        
        .timeline-container { height: 50px; background: #fff; border-bottom: 2px dashed #ffcdd2; display: flex; align-items: center; padding: 0 15px; overflow: hidden; gap: 10px; }
        .timeline-label { font-size: 13px; font-weight: bold; color: var(--accent); margin-right: 5px; }
        .tl-node { 
            width: 32px; height: 32px; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; font-size: 18px; 
            border: 3px solid #eee; position: relative; flex-shrink: 0; transition:0.3s; 
            background: #fff; box-shadow: 0 3px 0 #ddd;
        }
        .tl-node.curr { 
            border-color: var(--accent); transform: scale(1.2); z-index: 2; 
            box-shadow: 0 0 0 3px #ffecb3, 0 5px 10px rgba(255,64,129,0.2); 
        }
        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container { flex: 1; padding: 15px; overflow-y: auto; font-size: 14px; border-bottom: 2px solid #f0f0f0; background: #fff; line-height: 1.6; display: flex; flex-direction: column; min-height: 60px; }
        .log-entry { margin-bottom: 6px; padding: 8px 12px; background: #fafafa; border-radius: 15px; word-break: keep-all; border-left: 4px solid #eee; }
        .log-ally { color: #29b6f6; font-weight:bold; } .log-enemy { color: #ff7043; font-weight:bold; } .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; font-size: 1.1em; }
        
        .btn-group { display: flex; height: 90px; flex-shrink: 0; padding: 8px; gap: 8px; background: #fff5f8; }
        .skill-btn { 
            flex: 1; border: none; background: #fff; border-radius: 20px;
            cursor: pointer; transition: 0.2s; color: var(--text-main); display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; padding: 5px;
            box-shadow: var(--jelly-shadow); transform: translateY(0);
        }
        .skill-btn::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0));
            border-radius: 15px; pointer-events: none;
        }
        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform:none; }
        .skill-name { font-size: 15px; font-weight: bold; margin-bottom: 3px; }
        .skill-desc { font-size: 11px; color: #90a4ae; line-height: 1.2; }

        .passive-panel {
            background: #e0f2f1; padding: 8px 15px; font-size: 13px; color: #00695c;
            display: flex; align-items: center; border-radius: 15px; margin: 5px 15px;
            border: 2px solid #b2dfdb;
        }
        .passive-icon { margin-right: 8px; font-size: 16px; }
        
        .btn-start { 
            background: var(--accent); color: white; border: none; padding: 18px; 
            border-radius: 35px; font-weight: bold; width: 100%; margin-top: 15px; 
            cursor: pointer; font-size: 22px; box-shadow: 0 8px 0 #c2185b, 0 15px 20px rgba(0,0,0,0.15); 
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn-start::after { content:'ğŸ¾'; font-size:24px; margin-left:10px; opacity:0.8; }
        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(6px); box-shadow: 0 2px 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform:none; }

        .btn-rnd { background:#b39ddb; color:#fff; border:none; padding:10px 20px; border-radius:25px; cursor:pointer; font-weight:bold; margin-left:5px; box-shadow: 0 5px 0 #7e57c2; }
        .btn-rnd:active { transform: translateY(5px); box-shadow:none; }

        .tag-container { 
            position: relative; top: 0; left: 0; 
            width: 100%; display: flex; justify-content: center; 
            gap: 3px; flex-wrap: wrap; margin-bottom: 5px; 
            z-index: 10; 
        }
        .tag { padding: 4px 8px; border-radius: 12px; font-size: 10px; color: #fff; font-weight: bold; box-shadow: 0 2px 0 rgba(0,0,0,0.1); margin-bottom:2px; }
        
        .tag.poison { background: #ab47bc; } .tag.stun { background: #ffd54f; color:#5d4037; }
        .tag.freeze { background: #29b6f6; } .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; } .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; } .tag.bind { background: #66bb6a; } .tag.trap { background: #d4e157; color:#5d4037; }
        .tag.atkdown { background: #5c6bc0; } .tag.growth { background: #9ccc65; color:#33691e; }
        .tag.blind { background: #bdbdbd; color:#5d4037; }
        .tag.immunity { background: #fff; color:#5d4037; border:2px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color:#fff; }
        .tag.atkup { background: #ef5350; color:#fff; }
        .tag.taunt { background: #212121; color: #ff5252; border: 2px solid #ff1744; box-shadow: 0 0 8px rgba(255, 23, 68, 0.6); font-weight: 900; }
        .tag.karma { background: #512da8; color:#fff; border: 1px solid #d1c4e9; animation: jelly-bounce 2s infinite; }

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color:#1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color:#5d4037; }
        
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color:#5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        .float-text {
            position: absolute; font-weight: 900; font-size: 28px; pointer-events: none; z-index: 100;
            text-shadow: 2px 2px 0px #fff; animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; } 
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; } 
        }
        .ft-dmg { color: #ff7043; } .ft-crit { color: #ffa726; font-size: 36px; } 
        .ft-heal { color: #26a69a; } .ft-miss { color: #b0bec5; font-size: 20px; }

        #modal-overlay { position: fixed; inset: 0; background: rgba(255, 248, 225, 0.85); backdrop-filter:blur(5px); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #fff; padding: 25px; border-radius: 35px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3); overflow-y:auto; max-height:80vh; border: 5px solid #ffcc80; position: relative;}
        
        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }

        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }

        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }
    </style>
<script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div> <!-- í„´ ì•Œë¦¼ ë°°ë„ˆ -->
<button class="mute-btn" id="btn-mute" onclick="AudioSys.toggleMute()">ğŸ”Š</button> <!-- ìŒì†Œê±° ë²„íŠ¼ -->

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v8.1 UX Upgrade</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        <button id="btn-online" class="btn-start" style="background:#7e57c2; margin-top:5px;" onclick="startOnlineGame()">
             ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë§¤ì¹­ ì‹œì‘)
        </button>
        <button id="btn-start" class="btn-start" onclick="Game.start()" disabled>ì „íˆ¬ ì‹œì‘ (0/3)</button>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; font-size:16px; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
// [1] ì„œë²„ í†µì‹  ë° ë‚œìˆ˜ ë™ê¸°í™” ì„¤ì •
const socket = io(); 
let myRole = null; 
let myRoom = null;
let isOnlineMode = false; // ì˜¨ë¼ì¸ ëª¨ë“œì¸ì§€ í™•ì¸í•˜ëŠ” ê¹ƒë°œ

// [ì¶”ê°€ë¨] ì£¼ì‚¬ìœ„ ê°’ì„ ì €ì¥í•  í†µ(Buffer)ê³¼ ì¸ë±ìŠ¤
// 1Pê°€ êµ´ë¦° ì£¼ì‚¬ìœ„ ê°’ì„ ì—¬ê¸°ì— ë‹´ì•„ì„œ 2Pì—ê²Œ ë³´ë‚´ì¤ë‹ˆë‹¤.
Game = window.Game || {}; // Game ê°ì²´ ì•ˆì „ì¥ì¹˜
Game.netRndBuffer = []; 
Game.netRndIdx = 0; 
Game.isReplaying = false; // "ì§€ê¸ˆ ë‚¨ì˜ í–‰ë™ì„ ë”°ë¼í•˜ëŠ” ì¤‘ì¸ê°€?"

// [ì¶”ê°€ë¨] ë™ê¸°í™”ëœ ëœë¤ í•¨ìˆ˜ (Math.random ëŒ€ì‹  ì´ê±° ì”€)
Game.netRandom = function() {
    // 1. ë‚¨ì´ í•œ ê±° ë”°ë¼í•  ë•Œ (Replay): ì €ì¥ëœ ì£¼ì‚¬ìœ„ êº¼ë‚´ ì”€
    if (isOnlineMode && Game.isReplaying) {
        return Game.netRndBuffer[Game.netRndIdx++] || Math.random(); 
    }
    // 2. ë‚´ê°€ ì§ì ‘ í•  ë•Œ: ì£¼ì‚¬ìœ„ êµ´ë¦¬ê³  ê¸°ë¡í•´ë‘  (ë‚˜ì¤‘ì— ë³´ë‚´ì£¼ë ¤ê³ )
    const val = Math.random();
    if (isOnlineMode) Game.netRndBuffer.push(val); 
    return val;
};

// ë§¤ì¹­ì´ ì¡íˆë©´ ì„œë²„ê°€ ì•Œë ¤ì¤Œ
socket.on('gameStart', (data) => {
    myRole = data.role;
    myRoom = data.room;
    
    // ì•Œë¦¼ì°½ ë„ìš°ê¸°
    let roleText = myRole === 'player1' ? "ğŸ”µ ë‹¹ì‹ ì€ 1P (ì™¼ìª½/ì„ ê³µ) ì…ë‹ˆë‹¤!" : "ğŸ”´ ë‹¹ì‹ ì€ 2P (ì˜¤ë¥¸ìª½/í›„ê³µ) ì…ë‹ˆë‹¤!";
    alert("ë§¤ì¹­ ì„±ê³µ!\n" + roleText);

    // ê²Œì„ ì‹œì‘ (ê¸°ì¡´ í•¨ìˆ˜ í˜¸ì¶œ)
    Game.init();
    Game.start();

    // 2Pë¼ë©´ í„°ì¹˜ ë§‰ê¸° (1Pê°€ ë¨¼ì € ì‹œì‘í•˜ë‹ˆê¹Œ)
    if (myRole === 'player2') {
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ì (1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    }
});

// 2. ìƒëŒ€ë°© í–‰ë™ ìˆ˜ì‹  (ìˆ˜ì •ë¨)
// 2. ìƒëŒ€ë°© í–‰ë™ ìˆ˜ì‹  (ìˆ˜ì •ë¨)
socket.on('enemyAction', (data) => {
    const atkTeam = data.attackerTeam === 0 ? Game.pTeam : Game.eTeam;
    const defTeam = data.targetTeam === 0 ? Game.pTeam : Game.eTeam;
    
    // IDë¡œ ìœ ë‹› ì°¾ê¸°
    const attacker = atkTeam.find(u => u.id === data.attackerId);
    // íƒ€ê²Ÿì´ nullì¼ ìˆ˜ë„ ìˆìŒ (ê´‘ì—­ê¸° ë“±)
    const target = data.targetId !== null ? defTeam.find(u => u.id === data.targetId) : null;

    if(attacker) {
        // [í•µì‹¬] ìƒëŒ€ë°©ì´ ë³´ë‚¸ ì£¼ì‚¬ìœ„ í†µ(Buffer)ì„ ë°›ì•„ì„œ ë®ì–´ì”Œì›€
        Game.netRndBuffer = data.rndBuffer; 
        Game.netRndIdx = 0;
        Game.isReplaying = true;  // "ì§€ê¸ˆë¶€í„°ëŠ” ë”°ë¼í•˜ê¸° ëª¨ë“œë‹¤!"
        
        // ì‹¤í–‰ (trueëŠ” 'ì›ê²© ì¡°ì¢…'ì´ë¼ëŠ” í‘œì‹œ)
        Game.execute(attacker, target, data.skillIdx, true); 
        
        Game.isReplaying = false; // ëª¨ë“œ í•´ì œ
    }
});
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.5ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ê´‘ì—­í˜• ë”œëŸ¬ | í¡í˜ˆ+í™”ìƒ', passive:'ğŸ©¸ í¡í˜ˆ: ëª¨ë“  ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 20%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì•„êµ°ì „ì²´ HP+125 (20%í™•ë¥  +50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'í“¨ì–´ íëŸ¬ | ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ì‰´ë“œ+30/ê³µ+18 ì„±ì¥', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤ | ìê°€ ë²„í”„', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+í”¼í•´í¡ìˆ˜(30%)', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ì  ë„ë°œ/ì‰´ë“œ+15', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤ | ë„ë°œ+ë€ê°', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ25%/ì¹¨ë¬µ20%', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ì‹œ 1.8ë°°)', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸœï¸', desc:'ì œì–´í˜• ë”œëŸ¬ | ê¸°ì ˆ/ì¹¨ë¬µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+10(1í„´)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë²„í¼ | ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê³µâ†“/ì‰´ë“œ30%ì†Œë©¸', type:'DEBUFF', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ì¹´ìš´í„° ì„œí¬í„° | CCë°˜ì‚¬', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ ë˜ëŒë ¤ì¤ë‹ˆë‹¤.' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ì•„êµ°ë³´í˜¸(HPì†Œëª¨)', s2:'ì£¼ì‚¬ìœ„', s2d:'ëœë¤ í”¼í•´', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë¬´ìƒì„± ë”œëŸ¬ | ì™„ì „ ë©´ì—­', passive:'ğŸ² ë©´ì—­: CCê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ ë“±)ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤. (ë„íŠ¸ë”œ ì œì™¸)' },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ì •í™”í˜• ì„œí¬í„° | ê´‘ì—­ ì¼€ì–´', passive:null },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ', s2:'ë¸”ë™í™€', s2d:'í„´ ìŠ¤í‚µ(75%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ•³ï¸', desc:'ì œì–´í˜• ì„œí¬í„° | í„´ ìŠ¤í‚µ', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ë¸”ë™í™€ ì„±ê³µ ì‹œ ê³µê²©ë ¥ì´ 10 ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'1.4ë°°+ì‹¤ëª…(20%)', s2:'ì•ˆê°œ', s2d:'íƒ€ê²Ÿí+íšŒí”¼(20%)', type:'TARGET_BUFF', target:'ALLY', role:'supp', icon:'â˜ï¸', desc:'íšŒí”¼í˜• ì„œí¬í„° | íšŒí”¼ ë¶€ì—¬', passive:'â˜ï¸ ì¦ê¸°: íšŒí”¼(20%) ì‹œ ê¸°ì ˆ/ë¹™ê²° CCê¸°ë¥¼ í™•ë¥ ë¡œ ë¬´íš¨í™”í•©ë‹ˆë‹¤ (íšŒí”¼ì†Œë©¸).' },
    'Fire-Light': { s1:'ì²­ì—¼', s1d:'1.5ë°°', s2:'í­ì£¼', s2d:'ìì‹  ê³µ+40~ (ìµœëŒ€5íšŒ)', type:'BUFF', target:'SELF', role:'nuker', icon:'ğŸ”·', desc:'ì„±ì¥í˜• ë”œëŸ¬ | ìŠ¤íƒ í­ì£¼', passive:'ğŸ”¥ í­ì£¼: ìŠ¤í‚¬ ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ ëŒ€í­ ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 5íšŒ).' },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì‰´ë“œê´€í†µ+í', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ê³µê²©í˜• íëŸ¬ | ê´€í†µ+íšŒë³µ', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.5ë°°+ì‰´ë“œíŒŒê´´(ì„±ê³µì‹œ ì‰´ë“œ)', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…', type:'DEBUFF', target:'ALL_ENEMY', role:'tank', icon:'â˜£ï¸', desc:'ë””ë²„í”„ íƒ±ì»¤ | ì‰´ë“œíŒŒê´´', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°+ì‰´ë“œë¬´ì‹œ', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì¹˜ìœ ê°ì†Œ(ê°•)+ë„íŠ¸', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ¦‚', desc:'ì§€ì†í˜• ë””ë²„í¼ | ì¹˜ìœ ê°ì†Œ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'ì œì–´í˜• ë”œëŸ¬ | ê°•ë ¥ ë¹™ê²°', passive:null },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'ì²´ë ¥ë¹„ë¡€í”¼í•´', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ì§€ì†í˜• ë”œëŸ¬ | ì²´ë ¥ë¹„ë¡€', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ìŠ¤íƒê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì‚¬ë§ì‹œ í­ì£¼/ê´‘ì—­ë…', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ¥€', desc:'ê³µê²©í˜• íƒ±ì»¤ | ì£½ìŒì˜ ë³µìˆ˜', passive:'ğŸ¥€ ë³µìˆ˜: ì‚¬ë§ ì‹œ ì  ì „ì²´ì—ê²Œ ë§¹ë…ì„ ê±¸ê³  ì•„êµ° í•˜ë‚˜ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘(ìµœëŒ€3)', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ê´‘ì—­í˜• ë”œëŸ¬ | ì„±ì¥í˜• ëˆ„ì»¤', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+1í„´ê¸°ì ˆ(íœ´ì‹)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'í­ë°œí˜• ë”œëŸ¬ | í•œë°© ê¸°ì ˆ', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' }
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id; this.team = team;
        this.base = base; this.extra = extra;
        this.maxHp = 600; 
        if(base==='Tree' && extra==='Dark') this.maxHp = 700;
        this.hp = this.maxHp; this.shield = (base==='Metal' && !extra) ? 100 : 0;
        this.atk = 55 + Math.floor(Math.random()*15);
        this.status = []; this.isDead = false;
        
        this.thornStack = 0; 
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.resist = 0; 
        this.stats = { dmg: 0, heal: 0, shieldGiven: 0, taken: 0 }; 
        
        this.passiveTriggered = false;

        this.isNormal = this.base === 'Normal' || (this.base==='Light'&&this.extra==='Dark') || (this.base==='Dark'&&this.extra==='Light');
        this.isEnhanced = (this.base===this.extra && (this.base==='Light'||this.base==='Dark'));
        
        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() { if(this.isNormal) return 'Normal'; if(this.isEnhanced) return `${this.base}-${this.extra}`; return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base; }
    
    getAtk() { 
        let v = this.atk; 
        const ads = this.status.filter(s=>s.type==='ATK_DOWN'); 
        if(ads.length>0) v -= (ads.length*15); 
        if(this.hasStatus('LIGHT_MIGHT')) v += 10;
        return Math.max(10, v); 
    }
    
    resetTurn() {
        this.passiveTriggered = false;
    }

    takeDamage(dmg, isFire=false, ignoreShield=false, source=null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);
        
        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30); 
            if (dmg > cap && !this.passiveTriggered) { 
                dmg = cap; 
                this.passiveTriggered = true; 
                UI.floatText(this, "Iron Will", "ft-heal"); 
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        // [ìˆ˜ì •ë¨] íšŒí”¼ í™•ë¥  ë™ê¸°í™”
        if (this.hasStatus('EVADE')) { if(Game.netRandom() < 0.20) return -1; }

        if (source && source.id !== this.id && !source.isDead) {
             const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
             const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
             
             if (karma && !isDarkVsDark) {
                 const reflectDmg = Math.floor(dmg * 0.3);
                 if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null); 
                    this.stats.dmg += actualReflect; 
                    UI.floatText(source, reflectDmg, "ft-crit");
                 }
             }
        }
        
        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;

        if (!ignoreShield && this.shield > 0) { 
            if(this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg; 
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield; 
                this.shield = 0;
            } 
        } else {
            hpDmg = dmg;
        }

        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            hpDmg += 10; 
            this.stats.taken += 10; 
            UI.floatText(this, "Crack!", "ft-crit"); 
        }

        this.hp = Math.max(0, this.hp - hpDmg);
        return hpDmg + shieldDmg; 
    }
    
    revive(hpPercent) {
        this.isDead = false;
        this.hp = Math.floor(this.maxHp * hpPercent);
        this.status = [];
        this.shield = 0;
        this.s2Count = 0;        
        this.elecStacks = 0;     
        this.thornStack = 0;     
        this.linkedAllyId = -1; 
        this.passiveTriggered = false;
    }

    addStatus(type, turn, val=0, source=null) {
        if (this.isNormal && ['FREEZE','STUN','SILENCE','BLIND','BANISH','ATK_DOWN','HEAL_DOWN','BIND','KARMA_VICTIM'].includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type)) {
            if (source && source.id !== this.id) {
                if (Math.random() < 0.20) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return; 
                }
            }
        }

        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type.startsWith('KARMA_VICTIM_'));
            if (karma) {
                const ownerId = parseInt(karma.type.split('_')[2]);
                if (ownerId === this.id) {
                    const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
                    const isBanish = type === 'BANISH';
                    const isReflectable = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','ATK_DOWN'].includes(type);

                    if (!isDarkVsDark && !isBanish && isReflectable) {
                        UI.floatText(this, "ë°˜ì‚¬! â†©ï¸", "ft-crit");
                        Game.log(`<span class='log-crit'>ğŸ‘ï¸ [${this.name}] ì—…ë³´ ë°œë™! ${type} ë°˜ì‚¬ â” [${source.name}]</span>`);
                        source.addStatus(type, turn, val, null); 
                        return; 
                    }
                }
            }
        }

        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY')) { UI.floatText(this, "ë©´ì—­", "ft-miss"); return; }
            if (!source || source.id !== this.id) { this.status.push({type: 'IMMUNITY', turn: turn + 1}); }
        }

        // [ìˆ˜ì •ë¨] ì €í•­ í™•ë¥  ë™ê¸°í™”
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        if (type === 'ATK_DOWN') { 
            const s = this.status.filter(s=>s.type==='ATK_DOWN'); 
            if(s.length < 2) { this.status.push({type, turn, val}); } 
            else { const shortest = s.sort((a,b) => a.turn - b.turn)[0]; shortest.turn = turn; }
            return; 
        }
        
        if(type==='BURN') { const ex = this.status.find(s=>s.type==='BURN'); if(ex) { ex.turn = turn; return; } }
        if(type==='HEAL_DOWN') { const ex = this.status.find(s=>s.type==='HEAL_DOWN'); if(ex) { ex.turn = turn; return; } }
        if(type==='LIGHT_MIGHT') { const ex = this.status.find(s=>s.type==='LIGHT_MIGHT'); if(ex) { ex.turn = turn; return; } }
        if (type.startsWith('KARMA_VICTIM_')) { const ex = this.status.find(s => s.type === type); if(ex) { ex.turn = turn; return; } }
        if (type.startsWith('PROVOKED_BY_') && source) type = `PROVOKED_BY_${source.id}`;

        const idx = this.status.findIndex(s=>s.type===type); if(idx >= 0) this.status[idx].turn = turn; else this.status.push({type, turn, val});
    }
    hasStatus(type) { return this.status.some(s=>s.type===type); }
    cleanse() { 
        const bad = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN','KARMA_VICTIM']; 
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM')); 
    }
    dispel() { const buffs = ['EVADE','DMG_RED','ATK_BUFF','GROWTH','LIGHT_MIGHT']; const has=this.status.some(s=>buffs.includes(s.type)); this.status=this.status.filter(s=>!buffs.includes(s.type)); return has; }
    
    tickStatus() {
        let log = [];
        if(this.hasStatus('POISON')) { const d=this.takeDamage(30, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ ${d}`); }
        if(this.hasStatus('BURN')) { const d=this.takeDamage(20, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ ${d}`); }
        if(this.hasStatus('TRAP')) { const d=this.takeDamage(40, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ í”¼í•´ ${d}`); }
        return log;
    }

    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    
    heal(amount) { 
        if(this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4); 
        const prev=this.hp; 
        this.hp=Math.min(this.maxHp, this.hp+amount); 
        const diff=this.hp-prev; 
        if(diff>0) { UI.floatText(this, diff, 'ft-heal'); }
        return diff; 
    }
}

const AudioSys = {
    ctx: null,
    isMuted: false, // ìŒì†Œê±° ìƒíƒœ
    init: function() { 
        if(this.ctx) return;
        try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} 
    },
    resume: function() { if(this.ctx&&this.ctx.state==='suspended') this.ctx.resume(); },
    
    toggleMute: function() {
        this.isMuted = !this.isMuted;
        const btn = document.getElementById('btn-mute');
        if(this.isMuted) {
            btn.innerHTML = 'ğŸ”‡';
            btn.classList.add('muted');
        } else {
            btn.innerHTML = 'ğŸ”Š';
            btn.classList.remove('muted');
        }
    },

    playSoft: function(freq, type, dur, vol=0.3) { 
        if(!this.ctx || this.isMuted) return; // ìŒì†Œê±° ì²´í¬
        const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const t=this.ctx.currentTime;
        o.type=type; o.frequency.setValueAtTime(freq,t);
        g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.1);
    },
    
    play: function(type) {
        if(!this.ctx || this.isMuted) return;

        if(type==='HIT') { 
            const rndFreq = 600 + (Math.random() * 100 - 50); 
            this.playSoft(rndFreq,'triangle',0.1,0.4); 
        } 
        else if(type==='SKILL') { this.playSoft(500,'sine',0.15,0.3); setTimeout(()=>this.playSoft(800,'sine',0.2,0.3),100); } 
        else if(type==='HEAL') { this.playSoft(500,'sine',0.2,0.3); setTimeout(()=>this.playSoft(700,'sine',0.3,0.3),150); }
        else if(type==='DEBUFF') { this.playSoft(300,'triangle',0.2,0.35); setTimeout(()=>this.playSoft(200,'triangle',0.2,0.35), 150); } 
        else if(type==='MISS') this.playSoft(900,'square',0.05,0.2); 
        else if(type==='WIN') { setTimeout(()=>this.playSoft(523,'sine',0.2,0.5),0); setTimeout(()=>this.playSoft(659,'sine',0.2,0.5),200); setTimeout(()=>this.playSoft(784,'sine',0.4,0.5),400); }
        else if(type==='POWER_UP') { 
            this.playSoft(440,'sine',0.2,0.35); setTimeout(()=>this.playSoft(554,'sine',0.2,0.35), 100); setTimeout(()=>this.playSoft(659,'sine',0.3,0.35), 200); 
        }
        else if(type==='CRITICAL') { this.playSoft(150,'triangle',0.1,0.6); setTimeout(()=>this.playSoft(880,'sine',0.3,0.7), 50); } 
    }
};

const UI = {
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() { document.getElementById('modal-overlay').style.display = 'none'; },
    
    showGuide: function() {
        let heroList = '';
        Object.keys(SKILL_DB).forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if(k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if(parts.length===2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';

            heroList += `
            <div class="guide-item">
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div>
                <div class="guide-info">
                    <div class="guide-name">${name}</div>
                    <div class="guide-desc">${s.desc}</div>
                    <div style="font-size:10px; color:#555; margin-top:2px;">
                        <div>S1: ${s.s1} (${s.s1d})</div>
                        <div>S2: ${s.s2} (${s.s2d})</div>
                    </div>
                </div>
            </div>`;
        });

        const content = `
            <div class="tab-header">
                <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button>
                <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button>
            </div>
            <div id="tab-0" class="tab-content active">
                <table class="chart-table">
                    <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                    <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                    <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                    <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                    <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                    <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                    <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
                    <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr>
                </table>
                <div class="dual-chart">
                    <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                    <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div>
                </div>
            </div>
            <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;">
                ${heroList}
            </div>
        `;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if(i===idx) b.classList.add('active'); else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if(i===idx) c.classList.add('active'); else c.classList.remove('active');
        });
    },

    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id); if(!unitEl) return;
        const el = document.createElement('div'); el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        el.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px'; el.style.top = (rect.top + window.scrollY) + 'px';
        document.body.appendChild(el); setTimeout(() => el.remove(), 800);
    },
    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    
    // [v8.1] í„´ ì•Œë¦¼ ë°°ë„ˆ í‘œì‹œ í•¨ìˆ˜ (ì†ë„ ì¡°ì ˆ ë¡œì§ ì¶”ê°€)
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        // ë°°ë„ˆ ìŠ¤íƒ€ì¼ ë° í…ìŠ¤íŠ¸ ì„¤ì •
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)";
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ (í´ë˜ìŠ¤ ì œê±° ì—†ì´ styleë¡œ ì œì–´)
        banner.style.animation = 'none';
        void banner.offsetWidth; // Trigger Reflow
        
        // [v8.1] í„´ì´ 5í„´ì„ ë„˜ì–´ê°€ë©´ ë°°ë„ˆ ì†ë„ë¥¼ 2ë°° ë¹ ë¥´ê²Œ (1.2s -> 0.6s)
        const duration = Game.turnCount > 5 ? '0.6s' : '1.2s';
        banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`;
    },

    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);

        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        
        const mvp = allUnits.sort((a,b)=>(b.stats.dmg+b.stats.heal+b.stats.shieldGiven)-(a.stats.dmg+a.stats.heal+a.stats.shieldGiven))[0];

        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            
            return `
            <div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
                ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''}
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div>
                    <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div>
                </div>
                <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;">
                    <span style="width:30px; color:#888;">ë”œ</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span>
                </div>
                <div style="display:flex; align-items:center; font-size:11px;">
                    <span style="width:30px; color:#888;">í</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span>
                </div>
            </div>`;
        };

        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },
    checkMode: function() {
        Game.checkMode();
    }
};

const ChallengeDB = [
    { name: "í™ë ¨ì˜ ë¶ˆê½ƒ", desc: "í™”ìƒê³¼ í­ë°œì ì¸ ë”œë§ì„ ì£¼ì˜í•˜ì„¸ìš”.", team: ['Fire', 'Fire-Dark', 'Earth-Dark'] },
    { name: "ì ˆëŒ€ ë°©ì–´ì„ ", desc: "ëš«ì„ ìˆ˜ ì—†ëŠ” ì‰´ë“œì™€ íì˜ ì¡°í•©ì…ë‹ˆë‹¤.", team: ['Metal', 'Light', 'Water'] },
    { name: "ìˆ²ì˜ ìš”ìƒˆ", desc: "ì£½ì§€ ì•Šê³  ê³„ì† ì„±ì¥í•˜ëŠ” ì¢€ë¹„ ë±ì…ë‹ˆë‹¤.", team: ['Tree', 'Tree-Dark', 'Water-Light'] },
    { name: "ìƒíƒœì´ìƒ ì§€ì˜¥", desc: "ê¸°ì ˆ, ì¹¨ë¬µ, ë¹™ê²°... ì•„ë¬´ê²ƒë„ ëª» í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", team: ['Earth', 'Water-Dark', 'Dark-Dark'] },
    { name: "ë¬µì§í•œ ì‹¬íŒ", desc: "ê°•ë ¥í•œ ì •í™”ì™€ ê¸°ì ˆ ì½¤ë³´ë¥¼ ì£¼ì˜í•˜ì„¸ìš”.", team: ['Earth-Dark', 'Light-Light', 'Normal'] },
    { name: "ì–´ë‘ ì˜ ë°˜ì‚¬", desc: "ë•Œë¦¬ë©´ ì•„í”ˆ ë°˜ì‚¬ ë°ë¯¸ì§€ì™€ ê³µí¬ë¥¼ ê²ë‹ˆë‹¤.", team: ['Dark', 'Dark-Dark', 'Metal-Light'] },
    { name: "ìì—°ì˜ ë¶„ë…¸", desc: "ì†ë°•ê³¼ ë…ìœ¼ë¡œ ì„œì„œíˆ ë§ë ¤ ì£½ì…ë‹ˆë‹¤.", team: ['Tree', 'Earth-Light', 'Metal-Dark'] },
    { name: "ê°•ì² ì˜ ì§„ê²©", desc: "ì‰´ë“œ íŒŒê´´ì™€ ë„ë°œë¡œ ì•„êµ°ì„ ë¬´ë ¥í™”í•©ë‹ˆë‹¤.", team: ['Metal', 'Metal-Light', 'Fire'] },
    { name: "í˜¼ëˆì˜ ì¹´ì˜¤ìŠ¤", desc: "ì˜ˆì¸¡í•  ìˆ˜ ì—†ëŠ” ëœë¤ ê³µê²©ê³¼ ë³€ìˆ˜ ì°½ì¶œ.", team: ['Normal', 'Earth-Dark', 'Water-Light'] },
    { name: "ìµœì¢… ë³´ìŠ¤", desc: "ê³µìˆ˜ ë°¸ëŸ°ìŠ¤ê°€ ì™„ë²½í•œ ìµœê°•ì˜ ì¡°í•©ì…ë‹ˆë‹¤.", team: ['Tree', 'Water', 'Dark-Dark'] }
];

const Game = {
    pool: [], selected: [], pTeam: [], eTeam: [], queue: [], curr: 0, selectedSkillIdx: -1, timer: null, turnCount: 1, difficulty: 'normal', watchdog: null,
    isOver: false, mode: 'pve', isProcessing: false,
    challengeStage: 0,

    init: function() {
        if(this.timer) clearTimeout(this.timer);
        this.isOver = false;
        let combos = [];
        const bases = ['Fire','Water','Tree','Metal','Earth','Light','Dark'];
        const extras = [null, 'Light', 'Dark'];
        bases.forEach(b => extras.forEach(e => combos.push({b, e})));
        combos = combos.filter(c => !(c.b === 'Dark' && c.e === 'Light')); 
        combos.sort(() => Math.random() - 0.5);

        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        this.pool = []; this.selected = [];

        for(let i=0; i<12; i++) {
            const c = combos[i];
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
            const el = document.createElement('div');
            el.className = 'hero-card';
            el.innerHTML = this.renderCard(u);
            el.onclick = () => this.toggle(i, el);
            grid.appendChild(el);
        }
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        
        this.checkMode(); 
    },

    renderCard: function(u) {
        let bgClass = `bg-${u.base}`;
        if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
        if(u.isNormal) bgClass = 'bg-Normal';
        const info = SKILL_DB[u.getKey()];
        const icon = info.icon || ''; 
        return `<div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div><div style="font-weight:bold; margin-bottom:2px; font-size:15px;">${u.name.split(' ')[0]}</div><div style="font-size:11px; color:#999;">${u.name}</div><div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">${info.desc}</div>`;
    },

    toggle: function(i, el) {
        if(this.selected.includes(i)) { this.selected = this.selected.filter(x=>x!==i); el.classList.remove('selected'); }
        else { if(this.selected.length>=3) return; this.selected.push(i); el.classList.add('selected'); }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (${this.selected.length}/3)`;
        btn.disabled = this.selected.length !== 3;
    },

    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if(el) el.classList.remove('selected');
        });
        Game.selected = [];
        while(Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 12);
            if(!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if(el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            
            if(this.challengeStage > maxStage) this.challengeStage = maxStage;

            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }
    },
    
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },

    start: function() {
        AudioSys.init(); AudioSys.resume();
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = diffVal === 'pvp' ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => { const u = this.pool[idx]; u.id=i; u.team=0; return u; });
        this.eTeam = [];
        this.isOver = false;
        
        const makeEnemy = (idx, b, e) => { const u = new Unit(idx + 3, 1, b, e); return u; };

        if (this.difficulty === 'hell') { 
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            
            const stageData = ChallengeDB[this.challengeStage];
            this.eTeam = stageData.team.map((key, i) => {
                let b, e;
                if(key === 'Normal') { b='Normal'; e=null; }
                else if(key.includes('-')) { [b, e] = key.split('-'); }
                else { b=key; e=null; }
                return makeEnemy(i, b, e);
            });
        } 
        else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => {
                const u = new Unit(i + 3, 1, pu.base, pu.extra);
                u.maxHp = Math.floor(u.maxHp * 1.15); u.hp = u.maxHp; u.atk = Math.floor(u.atk * 1.15); 
                return u;
            });
        } 
        else if (this.difficulty === 'hard') {
            const decks = [
                [{b:'Metal',e:'Light'}, {b:'Earth',e:'Light'}, {b:'Normal',e:null}], 
                [{b:'Metal',e:null}, {b:'Light',e:null}, {b:'Fire',e:'Light'}], 
                [{b:'Normal',e:null}, {b:'Light',e:'Light'}, {b:'Tree',e:null}], 
                [{b:'Fire',e:'Light'}, {b:'Earth',e:'Dark'}, {b:'Normal',e:null}], 
                [{b:'Dark',e:'Dark'}, {b:'Water',e:'Dark'}, {b:'Earth',e:null}], 
                [{b:'Tree',e:null}, {b:'Water',e:null}, {b:'Water',e:'Light'}], 
                [{b:'Earth',e:'Dark'}, {b:'Light',e:'Light'}, {b:'Metal',e:'Light'}], 
                [{b:'Tree',e:'Dark'}, {b:'Tree',e:null}, {b:'Water',e:'Light'}]
            ];
            const d = decks[Math.floor(Math.random()*decks.length)];
            this.eTeam = d.map((c, i) => makeEnemy(i, c.b, c.e));
        }
        else {
            const used = new Set();
            while(this.eTeam.length<3) {
                const b = ['Fire','Water','Tree','Metal','Earth','Light','Dark'][Math.floor(Math.random()*7)];
                const e = [null,'Light','Dark'][Math.floor(Math.random()*3)];
                if(b==='Dark'&&e==='Light') continue; 
                let key = `${b}-${e}`; if(b==='Light'&&e==='Dark') key = 'Normal';
                if(!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
            }
        }

        this.queue = [0,1,2,3,4,5]; this.curr = Math.floor(Math.random()*6);
        this.turnCount = 1;
        this.isProcessing = false; 
        
        document.getElementById('selection-screen').style.display='none';
        document.getElementById('battle-screen').style.display='flex';
        document.getElementById('logs').innerHTML = ''; 
        
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1000);
    },

    turn: function() {
        this.isProcessing = false; 
        if (this.isOver) return;

        if(this.watchdog) clearTimeout(this.watchdog);
        this.watchdog = setTimeout(() => { console.log("AI Stuck. Forcing next."); this.endTurn(); }, 3000);

        if(this.endCheck()) return;

        const tVal = this.queue[this.curr];
        const u = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];

        if(!u.isDead) u.resetTurn();

        if(u.isDead) { this.endTurn(true); return; }

        // [v8.1] ë°°ë„ˆ ìœ„ì¹˜ ë³€ê²½: ì£½ì—ˆìœ¼ë©´ ë¦¬í„´í•˜ë¯€ë¡œ, ì—¬ê¸°ê¹Œì§€ ì™”ë‹¤ëŠ” ê±´ ì‚´ì•„ìˆë‹¤ëŠ” ëœ».
        // ì‚´ì•„ìˆëŠ” ì˜ì›…ì˜ í„´ì¼ ë•Œë§Œ ë°°ë„ˆ í‘œì‹œ
        UI.showTurnBanner(u.team === 0);

        if(u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) {
            UI.floatText(u, "SKIP", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`);
            setTimeout(() => this.endTurn(), 800);
            return;
        }
        
        const tickLogs = u.tickStatus();
        tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if(u.hp<=0) { this.die(u); this.endTurn(); return; }

        let turnName = u.name.split(' ')[0];
        if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
        document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
        this.turnCount++;
        
        if(u.team===0) { 
            if(this.watchdog) clearTimeout(this.watchdog);
            this.input(u); 
        } else { 
            if (this.mode === 'pvp') { if(this.watchdog) clearTimeout(this.watchdog); this.input(u); } 
            else { this.noInput(); this.timer=setTimeout(()=>this.ai(u), 800); }
        }
    },
    
    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for(let i=0; i<6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx]; 
            const isP = qId % 2 === 0;
            const uIdx = isP ? qId/2 : (qId-1)/2;
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if(u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }

        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if(!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });

            team.forEach((u) => {
                const cardId = tid===0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId; d.dataset.uid = u.id; row.appendChild(d);
                }

                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;

                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;
                
                let tags = u.status.map(s => {
                    let c='tag'; 
                    const map = {'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn','BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown','BLIND':'blind','ATK_BUFF':'growth','IMMUNITY':'immunity','HEAL_DOWN':'healdown','LIGHT_MIGHT':'atkup'};
                    if(s.type.includes('PROVOKED')) c+=' taunt';
                    else if(s.type.startsWith('KARMA_VICTIM')) c+=' karma';
                    else if(map[s.type]) c+=` ${map[s.type]}`;
                    
                    let txt = s.type;
                    const tMap = {'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ','TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…','ATK_BUFF':'í­ì£¼','IMMUNITY':'ë©´ì—­','HEAL_DOWN':'ì¹˜ìœ â†“','LIGHT_MIGHT':'ê³µê²©â†‘'};
                    if(s.type.includes('PROVOKED')) txt='ë„ë°œ';
                    else if(s.type.startsWith('KARMA_VICTIM')) txt='ğŸ‘ï¸ì—…ë³´';
                    else if(tMap[s.type]) txt = tMap[s.type];

                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');

                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;

let bgClass = `bg-${u.base}`;
                if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if(u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || ''; 

                let extraBadge = '';
                if(u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;

                const innerHTML = `
                    ${extraBadge}
                    <div class="tag-container">${tags}</div>
                    <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div>
                    <div class="unit-name" style="font-size:15px; margin-bottom:3px;">${u.name.split(' ')[0]} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div>
                    <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div>
                    <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div>
                `;
                if(d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0); draw('enemy-row', this.eTeam, 1);
    },
    
    endTurn: function(isFast = false) {
        if(this.isOver) return; 
        if(this.watchdog) clearTimeout(this.watchdog);
        
        const u = this.queue[this.curr]%2===0 ? this.pTeam[this.queue[this.curr]/2] : this.eTeam[(this.queue[this.curr]-1)/2];
        if(u && !u.isDead) u.decayStatus();

        if (this.curr === 0 && Math.ceil(this.turnCount / 6) >= 20) {
            [...this.pTeam, ...this.eTeam].forEach(u => {
                if(!u.isDead) u.atk += 10;
            });
            this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
        }

        [...this.pTeam, ...this.eTeam].forEach(u=>{if(u.hp<=0) this.die(u)});
        
        this.curr = (this.curr+1)%6;
        if(this.curr===0) this.turnCount++;
        
        this.render();
        const delay = isFast ? 100 : 1500; 
        this.timer = setTimeout(()=>this.turn(), delay);
    },

    reset: function() {
        if(this.timer) clearTimeout(this.timer);
        if(this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display='none';
        document.getElementById('selection-screen').style.display='flex';
        
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));
        this.selected = [];
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        
        this.init(); 
    },

    recordStat: function(unit, type, amount) {
        if(!unit || amount <= 0) return;
        if(type === 'dmg') unit.stats.dmg += amount;
        if(type === 'shield') unit.stats.shieldGiven += amount;
        if(type === 'heal') unit.stats.heal += amount;
    },

    input: function(u) {
        const k=u.getKey(); const s=SKILL_DB[k];
        const silenced = u.hasStatus('SILENCE');
        
        document.getElementById('p-icon').innerText = s.icon;
        document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';

        document.getElementById('sk-1').innerHTML = `<span class="skill-name">${s.s1}</span><br><span class="skill-desc">${s.s1d}</span>`;
        document.getElementById('sk-2').innerHTML = `<span class="skill-name">${s.s2}</span><br><span class="skill-desc">${s.s2d}</span>`;
        document.getElementById('sk-0').disabled = false;
        document.getElementById('sk-1').disabled = silenced;
        
        let s2Limit = false;
        if (k === 'Fire-Light' && u.s2Count >= 5) s2Limit = true;
        let sk2Disable = silenced || s2Limit;
        
        if (k === 'Tree-Dark') {
            const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
            const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
            if (aliveAllies.length === 0 || u.linkedAllyId !== -1) sk2Disable = true;
        }
        
        document.getElementById('sk-2').disabled = sk2Disable;
        
        if(silenced) this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
        
        const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
        if(provoked) {
            const targetId = parseInt(provoked.type.split('_')[2]);
            const enemies = u.team === 0 ? this.eTeam : this.pTeam;
            const allies = u.team === 0 ? this.pTeam : this.eTeam;
            const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
            
            if(!target || target.isDead) {
                u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
                UI.floatText(u, "ììœ !", "ft-heal");
                this.render();
            } else {
                this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
                this.noInput(); 
                setTimeout(() => this.execute(u, target, 0), 1000);
                return;
            }
        }
        this.selectedSkillIdx = -1;
    },
    
    noInput: function() { [0,1,2].forEach(i=>{ const b = document.getElementById(`sk-${i}`); b.disabled=true; b.classList.remove('selected'); }); },

    prepareSkill: function(idx) {
        [0,1,2].forEach(i => { const b = document.getElementById(`sk-${i}`); if(i===idx) b.classList.add('selected'); else b.classList.remove('selected'); });
        this.selectedSkillIdx = idx;
        
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        
        const k = u.getKey(); const skillInfo = SKILL_DB[k];
        let targetType = (idx === 0 || idx === 1) ? 'ENEMY' : skillInfo.target;
        if(k==='Tree') { if(idx===1) targetType = 'SELF'; else if(idx===2) targetType = 'ALLY'; }
        if(k==='Water-Light' && idx===2) targetType = 'ALLY';
        this.highlightTargets(targetType, u);
    },

    highlightTargets: function(targetType, actingUnit) {
        if (!actingUnit) {
            const tVal = this.queue[this.curr];
            actingUnit = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        }

        document.querySelectorAll('.unit').forEach(el => { 
            el.classList.remove('target-enemy', 'target-ally', 'target-aoe'); 
            el.onclick = null; 
        });

        const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
        const isAllyTarget = ['ALLY','ALL_ALLY','SELF','SELF_BUFF'].includes(targetType);
        
        const myTeam = actingUnit.team === 0 ? this.pTeam : this.eTeam;
        const oppTeam = actingUnit.team === 0 ? this.eTeam : this.pTeam;
        
        const targets = isAllyTarget ? myTeam : oppTeam;
        let targetClass = isAllyTarget ? 'target-ally' : 'target-enemy';
        if (isAOE && !isAllyTarget) targetClass = 'target-aoe'; 

        targets.forEach((t) => {
            if(!t.isDead) {
                if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2 && t.id === actingUnit.id) return;

                const el = document.getElementById(t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`);
                el.classList.add(targetClass);
                el.onclick = () => {
                    if (Game.isProcessing) return; 
                    Game.isProcessing = true;

                    if(targetType === 'SELF' && t.id !== actingUnit.id) return;
                    this.noInput();
                    document.querySelectorAll('.unit').forEach(el => el.classList.remove('target-enemy', 'target-ally', 'target-aoe'));
                    this.execute(actingUnit, t, this.selectedSkillIdx);
                };
            }
        });
    },

    ai: function(u) {
        try {
            const silenced = u.hasStatus('SILENCE');
            
            const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if(provoked) {
                const targetId = parseInt(provoked.type.split('_')[2]);
                const target = this.pTeam.find(p => p.id === targetId) || this.eTeam.find(e => e.id === targetId);
                
                if(!target || target.isDead) {
                    u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                    this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
                    UI.floatText(u, "ììœ !", "ft-heal");
                    this.render();
                } else {
                    this.execute(u, target, 0); 
                    return; 
                }
            }

            const enemies = u.team === 0 ? this.eTeam : this.pTeam; 
            const allies = u.team === 0 ? this.pTeam : this.eTeam; 
            const aliveEnemies = enemies.filter(e => !e.isDead);
            const aliveAllies = allies.filter(a => !a.isDead);

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            const k = u.getKey(); 
            const info = SKILL_DB[k];
            
            let attackTarget = aliveEnemies[0];
            let bestScore = -9999;

            aliveEnemies.forEach(e => {
                let score = 0;
                let multi = Game.calc(u, e).v;
                if (multi >= 1.5) score += 150;
                else if (multi >= 1.2) score += 80;
                else if (multi < 1.0) score -= 50;

                let estDmg = u.getAtk() * multi;
                if (e.hp <= estDmg) score += 1000; 

                if (this.difficulty !== 'easy') {
                    const role = SKILL_DB[e.getKey()].role;
                    if (role === 'supp') score += 100; 
                    else if (role === 'nuker') score += 50; 
                }

                if (k === 'Earth-Dark') {
                    if (e.hp < 200 && e.hp > estDmg) score -= 50; 
                }
                if (k === 'Metal-Light') {
                    if (e.shield > 0) score += 100;
                }
                if (k === 'Fire-Dark') {
                    if (e.hp > 400) score += 60;
                }

                if (['STUN','FREEZE','BANISH'].some(s => e.hasStatus(s))) score -= 40;

                const isImmune = e.isNormal || e.hasStatus('IMMUNITY');
                if (isImmune) {
                    if (k === 'Water-Dark' || k === 'Dark-Dark') score -= 9999;
                    if (k === 'Earth') score -= 50; 
                }

                if (score > bestScore) { bestScore = score; attackTarget = e; }
            });
            
            if (k === 'Tree') {
                const lowestAlly = aliveAllies.sort((a,b) => a.hp - b.hp)[0];
                if (aliveAllies.length > 1) {
                    if (lowestAlly.hp < lowestAlly.maxHp * 0.5 && !silenced) {
                        this.execute(u, lowestAlly, 2); 
                        return;
                    } else if (u.hp < u.maxHp * 0.4 && !silenced) {
                        this.execute(u, u, 1); 
                        return;
                    }
                    if (!silenced) {
                        this.execute(u, u, 1); 
                        return;
                    }
                }
            }

            let supportTarget = aliveAllies.sort((a,b) => a.hp - b.hp)[0]; 
            let blockS2 = false;

            if (k === 'Fire-Light') {
                const hasBuff = u.status.some(s => s.type === 'ATK_BUFF'); 
                if (hasBuff || u.s2Count >= 5) blockS2 = true; 
            }
            if (k === 'Tree-Dark') {
                const otherAllies = aliveAllies.filter(a => a.id !== u.id);
                if (otherAllies.length === 0 || u.linkedAllyId !== -1) blockS2 = true; 
                if (otherAllies.length > 0) supportTarget = otherAllies[0];
            }

            if (k === 'Metal') {
                const provokedEnemy = aliveEnemies.find(e => e.status.some(s => s.type === `PROVOKED_BY_${u.id}`));
                if (provokedEnemy) {
                    blockS2 = true; 
                    attackTarget = provokedEnemy;
                }
            }

            let action = 0;
            let finalTarget = attackTarget; 

            if (!silenced) {
                const isS2Support = ['BUFF','SELF_BUFF','HEAL','TARGET_BUFF','ALL_ALLY'].includes(info.type);
                let useS2 = false;
                
                if (info.type === 'HEAL') {
                    const totalMissing = aliveAllies.reduce((sum, a) => sum + (a.maxHp - a.hp), 0);
                    if (totalMissing > 300 || supportTarget.hp < supportTarget.maxHp * 0.6) useS2 = true;
                } 
                else if (this.difficulty === 'easy') { useS2 = Math.random() > 0.4; } 
                else { useS2 = true; }

                if (useS2) {
                      const isImmune = (info.type === 'DEBUFF' || k === 'Water-Dark' || k === 'Dark-Dark') && 
                                       (attackTarget.isNormal || attackTarget.hasStatus('IMMUNITY'));
                      if (isImmune) useS2 = false;
                }

                if (useS2 && !blockS2) {
                    if (isS2Support) {
                        action = 2;
                        finalTarget = supportTarget; 
                        if (info.type === 'SELF_BUFF') finalTarget = u;
                    } else {
                        action = 2; 
                    }
                } else {
                    action = 1; 
                }
            }
            
            if (['HEAL'].includes(info.type) && !silenced) {
                const totalMissing = aliveAllies.reduce((sum, a) => sum + (a.maxHp - a.hp), 0);
                if (totalMissing > 300 || supportTarget.hp < supportTarget.maxHp * 0.6) {
                    action = 2; finalTarget = supportTarget;
                } else {
                    action = 1; finalTarget = attackTarget;
                }
            }
            
            if (k === 'Tree' && aliveAllies.length === 1 && finalTarget === u && action === 2) {
                if (u.hp >= u.maxHp * 0.9) { action = 0; finalTarget = attackTarget; }
            }

            if (!finalTarget) {
                this.endTurn();
                return;
            }

            this.execute(u, finalTarget, action);
        } catch (e) {
            console.error(e);
            this.endTurn(); 
        }
    },

// [ìˆ˜ì •ëœ execute] ë™ê¸°í™” ë¡œì§ + Math.random êµì²´ ì™„ë£Œ
    execute: function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el=>el.onclick=null);

        // [ë™ê¸°í™” 1] ë‚´ê°€ ê³µê²©í•  ë•Œ(ì˜¨ë¼ì¸, ì›ê²©ì•„ë‹˜) -> ì£¼ì‚¬ìœ„ í†µ ë¹„ìš°ê³  ê¸°ë¡ ì‹œì‘
        if (isOnlineMode && !isRemote) {
            if (myRole === 'player1' && atk.team !== 0) { alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!"); return; }
            if (myRole === 'player2' && atk.team !== 1) { alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!"); return; }
            Game.netRndBuffer = []; // ì£¼ì‚¬ìœ„ ê¸°ë¡ ì´ˆê¸°í™”
        }

        const k = atk.getKey(); const s = SKILL_DB[k];
        const aff = (def && def.team !== atk.team) ? this.calc(atk, def) : {v:1, t:''};
        let defMod = 1.0;
        
        if (def && def.team !== atk.team) {
            const defAff = this.calc(def, atk); 
            if (aff.v < 1.2) {
                if (defAff.v === 1.3) defMod = 0.76; 
                else if (defAff.v === 1.2) defMod = 0.83;
            }
        }

        let m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ${sIdx===0?'ê³µê²©':(sIdx===1?s.s1:s.s2)}`;
        
        const isGlobal = ['AOE','HEAL','BUFF','ALL_ALLY'].includes(s.type) && sIdx === 2;
        if (!isGlobal && def) {
             m += ` â” <b class="${def.team===0?'log-ally':'log-enemy'}">[${def.name}]</b>`;
        }

        // [ë™ê¸°í™” 2] Math.random -> Game.netRandom (ì‹¤ëª… ì²´í¬)
        if (atk.hasStatus('BLIND') && Game.netRandom() < 0.20) { 
            m += " (ì‹¤ëª…ìœ¼ë¡œ ë¹—ë‚˜ê°!)"; UI.floatText(atk, "MISS", "ft-miss"); AudioSys.play('MISS');
            this.log(m); 
            // ë¹—ë‚˜ê°€ë„ í„´ ì¢…ë£Œ ì²˜ë¦¬ëŠ” í•´ì•¼ í•¨ (ì „ì†¡ í¬í•¨)
            this.postExecute(atk, def, sIdx, isRemote);
            return;
        }

        const baseAtk = atk.getAtk();
        let playedSound = false;

        // --- ìŠ¤í‚¬ ë¡œì§ (ëª¨ë“  Math.randomì´ Game.netRandomìœ¼ë¡œ êµì²´ë¨) ---
        if(sIdx === 0) {
            AudioSys.play('HIT'); playedSound=true;
            const dmg = Math.floor(baseAtk * 1.0 * aff.v * defMod);
            const act = def.takeDamage(dmg, false, false, atk);
            Game.recordStat(atk, 'dmg', act); 
            if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            else { 
                m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg");
                if (aff.v > 1.2 || act > 150) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; } 
                if (k === 'Fire') {
                    const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                    const h = atk.heal(healAmt); Game.recordStat(atk, 'heal', h); 
                }
            }
        } 
        else if (sIdx === 1) {
            if(k === 'Tree') {
                atk.shield += 30; Game.recordStat(atk, 'shield', 30);
                atk.atk += 18; atk.addStatus('GROWTH', 99); 
                m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ê´‘í•©ì„±! (ì„±ì¥)`;
                UI.floatText(atk, "GROWTH", "ft-heal");
                AudioSys.play('POWER_UP'); playedSound=true;
            } else {
                let mult = 1.5; if(k==='Tree-Dark') mult += atk.thornStack; if(k==='Water-Light') mult = 1.4;
                if (k==='Metal-Light') mult = 0.5;
                if (k==='Metal') mult = 1.3;
                if (k==='Dark-Dark') mult = 0.9; 
                if(k==='Fire') mult = 1.5;

                let rawDmg = Math.floor(baseAtk * mult * aff.v * defMod);
                
                if(k==='Metal-Light' || k==='Earth') { AudioSys.play('DEBUFF'); playedSound=true; }

                if(k==='Earth') { 
                    // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                    if(Game.netRandom() < 0.25) { def.addStatus('STUN', 1, 0, atk); m+='(ê¸°ì ˆ) '; } 
                    else if(Game.netRandom() < 0.20) { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; } 
                }
                
                if(k==='Metal-Light') { 
                    const broken = def.shield > 0;
                    def.shield=0; def.addStatus('POISON', 3, 0, atk); m+='(ì‰´ë“œíŒŒê´´+ì¤‘ë…) '; 
                    if (broken) {
                        const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                        const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                        if(lowest) { lowest.shield += 30; Game.recordStat(atk, 'shield', 30); UI.floatText(lowest, "+30ğŸ›¡ï¸", "ft-heal"); m+=`(ì•„êµ°ë³´í˜¸) `; }
                    }
                }

                if(k==='Dark-Dark') { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; }
                // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                if(k==='Water-Light' && Game.netRandom()<0.2) { def.addStatus('BLIND', 1, 0, atk); m+='(ì‹¤ëª… ì„±ê³µ) '; }
                if(k==='Fire') { def.addStatus('BURN', 2, 0, atk); m+='(í™”ìƒ) '; }
                if(k==='Fire-Dark') { (atk.team===0 ? this.eTeam : this.pTeam).forEach(e => { if(!e.isDead) e.addStatus('BURN', 2, 0, atk); }); m += '(ì „ì²´ í™”ìƒ) '; }
                if(k==='Tree-Light') {
                    const allies = atk.team===0 ? this.pTeam : this.eTeam;
                    const alive = allies.filter(a=>!a.isDead);
                    if(alive.length > 0) { 
                        // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                        const lucky = alive[Math.floor(Game.netRandom()*alive.length)]; 
                        const h = lucky.heal(20); 
                        Game.recordStat(atk, 'heal', h); 
                        m+=`(ì•„êµ° íšŒë³µ) `; 
                    }
                }

                if(k==='Metal-Dark') { 
                    if(atk.elecStacks < 3) { 
                        atk.atk += 10; atk.elecStacks++; 
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        AudioSys.play('POWER_UP'); m += ` (âš¡ê³µê²©ë ¥+10)`;
                    } else { m += ` (âš¡MAX)`; }
                }

                if (k === 'Normal') {
                    atk.hp = Math.max(1, atk.hp - 30); 
                    const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                    const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                    if (lowest) {
                        const shieldAmt = (lowest.id === atk.id) ? 60 : 50;
                        lowest.shield += shieldAmt; Game.recordStat(atk, 'shield', shieldAmt); UI.floatText(lowest, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                    m += ` (HPì†Œëª¨/ë³´í˜¸)`;
                }

                if (k === 'Dark') {
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                    m += ' (ì—…ë³´ ì‹¬ê¸°)';
                }

                if (k === 'Earth-Light' || k === 'Tree-Light') { 
                    let actual = def.takeDamage(rawDmg, false, true, atk);
                    Game.recordStat(atk, 'dmg', actual);
                    if (actual === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { m += ` ${actual} í”¼í•´ (ì‰´ë“œë¬´ì‹œ) ${aff.t}`; this.shake(def); UI.floatText(def, actual, "ft-crit"); }
                } else {
                    const act = def.takeDamage(rawDmg, k.startsWith('Fire'), false, atk);
                    Game.recordStat(atk, 'dmg', act);
                    if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { 
                        m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg"); 
                        if (k === 'Metal') {
                            const absorb = Math.floor(act * 0.3); atk.shield += absorb; Game.recordStat(atk, 'shield', absorb); UI.floatText(atk, `+${absorb}`, "ft-heal");
                        }
                        if (k === 'Fire') {
                            const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                            const h = atk.heal(healAmt);
                            Game.recordStat(atk, 'heal', h); 
                        }
                    }
                }
            }
        } 
        else { // S2 (ìŠ¤í‚¬ 2)
            if (k === 'Fire-Light') { 
                if(atk.s2Count < 5) {
                    const bonuses = [40, 30, 20, 30, 40];
                    const bonus = bonuses[atk.s2Count];
                    atk.s2Count++; atk.atk += bonus;
                    AudioSys.play('POWER_UP'); 
                    m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ğŸ”¥í­ì£¼! (ê³µê²©ë ¥ +${bonus})`;
                }
                playedSound=true; 
            }

            if (k === 'Dark-Dark') {
                atk.takeDamage(20, false, false, null); AudioSys.play('DEBUFF'); playedSound=true;
                // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                if(Game.netRandom() < 0.75) { 
                    def.addStatus('BANISH', 1); m += " (ğŸŒŒì¶”ë°© ì„±ê³µ)"; UI.floatText(def,"ì¶”ë°©!","ft-miss"); atk.atk += 10;
                } 
                else { m += " (ì¶”ë°© ì‹¤íŒ¨)"; UI.floatText(def,"ì €í•­","ft-miss"); }
            }
            else if (k === 'Water-Dark') {
                const act = def.takeDamage(Math.floor(baseAtk), false, false, atk);
                if (act === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ${act} í”¼í•´`; UI.floatText(def, act, "ft-dmg");
                    // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                    if(Game.netRandom() < 0.35) { def.addStatus('FREEZE', 1); m += " (â„ï¸ë¹™ê²°)"; UI.floatText(def,"ë¹™ê²°","ft-miss"); }
                }
            }
            else if (k === 'Normal') {
                // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                const rnd = Game.netRandom() * 1.7 + 0.8;
                const dmg = Math.floor(baseAtk * rnd * aff.v * defMod);
                const act = def.takeDamage(dmg, false, false, atk); 
                if (act === -1) { m += " ì£¼ì‚¬ìœ„ ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ì£¼ì‚¬ìœ„(x${rnd.toFixed(2)}) ${act}`; this.shake(def); UI.floatText(def, act, "ft-dmg");
                    if(rnd > 2.0) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; }
                }
            }
           else if(s.type === 'AOE') {
                m += " (ì „ì²´ ê³µê²©!)";
                let earthMult = 0.8; 
                if (k === 'Earth') {
                    const pAlive = this.pTeam.filter(u => !u.isDead).length;
                    const eAlive = this.eTeam.filter(u => !u.isDead).length;
                    if (pAlive === 1 && eAlive === 1) { earthMult = 1.8; m += " <br><span class='log-crit'>ğŸ”¥1:1 ì§„ê²€ìŠ¹ë¶€! (ë°ë¯¸ì§€ 1.8ë°°)</span>"; }
                }

                (atk.team===0?this.eTeam:this.pTeam).forEach(e => { if(!e.isDead) {
                    let indDefMod = 1.0;
                    const da = Game.calc(atk, e); const dd = Game.calc(e, atk); 
                    if (da.v < 1.2) { if(dd.v===1.3) indDefMod=0.76; else if(dd.v===1.2) indDefMod=0.83; }

                    const dmg = Math.floor(baseAtk * earthMult * da.v * indDefMod);
                    const act = e.takeDamage(dmg, k.startsWith('Fire'), false, atk);
                    Game.recordStat(atk, 'dmg', act);
                    if(act !== -1) { 
                        this.shake(e); UI.floatText(e, act, "ft-dmg"); 
                        if(k==='Earth-Light') e.addStatus('BLIND', 2); 
                        // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                        if(k==='Metal-Dark' && Game.netRandom()<0.15) {
                            e.addStatus('STUN', 1, 0, atk); m += ` <span style="color:#ffd54f; font-weight:bold;">(âš¡ê¸°ì ˆ)</span>`;
                        }
                        if(k==='Fire' && Game.netRandom()<0.25) e.addStatus('BURN', 2, 0, atk); 
                        if (k === 'Fire') { const healAmt = Math.min(30, Math.floor(act * 0.2)); const h = atk.heal(healAmt); Game.recordStat(atk, 'heal', h); }
                    } else { UI.floatText(e, "MISS", "ft-miss"); }
                }});
            } 
            else if(s.type === 'HEAL') { 
                AudioSys.play('HEAL'); playedSound=true;
                const healBase = k === 'Water' ? 125 : 110;
                (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{
                    if(!a.isDead) { const h = a.heal(healBase); Game.recordStat(atk, 'heal', h); }
                });
                m+=` (ì•„êµ° ì „ì²´ íšŒë³µ +${healBase})`; 
                // [ë™ê¸°í™”] netRandom ì‚¬ìš©
                if(k==='Water' && Game.netRandom() < 0.2) {
                    const lowest = (atk.team===0?this.pTeam:this.eTeam).filter(a=>!a.isDead).sort((a,b)=>a.hp-b.hp)[0];
                    if(lowest) { const h = lowest.heal(50); Game.recordStat(atk, 'heal', h); m+=` (ğŸ’§ëŒ€ë°•í +50)`; UI.floatText(lowest, "+50", "ft-heal"); }
                }
            }
            else if(s.type === 'BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(k !== 'Fire-Light') m += " (ì•„êµ° ì „ì²´ ê°•í™”)";
                const allies = atk.team===0?this.pTeam:this.eTeam;
                if(k==='Light') allies.forEach(a=>{if(!a.isDead) { a.shield=Math.min(300, a.shield+70); a.addStatus('LIGHT_MIGHT', 1); Game.recordStat(atk,'shield',70); }}); 
                else if(k==='Light-Light') allies.forEach(a=>{if(!a.isDead) {a.shield=Math.min(300, a.shield+50); Game.recordStat(atk,'shield',50); a.cleanse();}}); 
                else if(k==='Tree-Light') allies.forEach(a=>{if(!a.isDead) { const h = a.heal(70); Game.recordStat(atk, 'heal', h); a.cleanse(); }});
            } 
            else if(s.type === 'TARGET_BUFF' || s.type === 'SELF_BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(def) { 
                    if(k==='Tree') { const h = def.heal(150); Game.recordStat(atk, 'heal', h); def.cleanse(); m+=` ì¹˜ìœ /ì •í™”`; }
                    else if(k==='Tree-Dark') { 
                        if (atk.id === def.id) { } else { atk.linkedAllyId = def.id; def.addStatus('BIND', 99); atk.resist += 0.3; m+=` ê²°ì†! (í­ì£¼ëŒ€ê¸°/ì €í•­â†‘)`; }
                    }
                    else if(k==='Water-Light') {
                        (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{if(!a.isDead) a.addStatus('EVADE', 2)});
                        const healAmt = Math.floor((def.maxHp - def.hp) * 0.15); const h = def.heal(healAmt); Game.recordStat(atk, 'heal', h); m += ` (íšŒí”¼ì¦ê°€+ì¹˜ìœ )`;
                    }
                }
            } 
            else if(s.type === 'DEBUFF') {
                AudioSys.play('DEBUFF'); playedSound=true;
                if(k==='Metal') { 
                    const enemies = (atk.team===0?this.eTeam:this.pTeam);
                    enemies.forEach(e => { e.status = e.status.filter(s => s.type !== `PROVOKED_BY_${atk.id}`); });
                    def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk); atk.shield+=15; Game.recordStat(atk,'shield',15); m += ` ë„ë°œ! (ì‰´ë“œ+15)`; 
                }
                else if(k==='Dark') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{if(!e.isDead){ e.addStatus('ATK_DOWN', 2); e.shield=Math.floor(e.shield*0.7); if(Game.netRandom()<0.2) e.dispel(); }}); m+=" (ì  ì „ì²´ ê³µí¬)"; }
                else if(k==='Metal-Light') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{ if(!e.isDead) { e.addStatus('POISON', 3); } }); m+=" (ê´‘ì—­ ì¤‘ë… ì‚´í¬)"; }
                else if(k==='Earth-Light') { def.addStatus('TRAP', 2); def.addStatus('HEAL_DOWN', 2); m+=` ëª¨ë˜ì§€ì˜¥(ì†ë°•+ì¹˜ìœ ê°ì†Œ)`; }
            } 
            else if(s.type === 'NUKE' || s.type === 'NUKE_PER' || s.type === 'ATK') {
                let dmg = 0;
                if (s.type === 'NUKE_PER') dmg = Math.floor(baseAtk * 1.2 * aff.v * defMod + def.maxHp * 0.1);
                else if (k === 'Earth-Dark') dmg = Math.floor(baseAtk * 2.5 * aff.v * defMod);
                else dmg = Math.floor(baseAtk * 2.0 * aff.v * defMod);

                if(k==='Earth-Dark') atk.addStatus('STUN', 2, 0, atk);
                
                const act = def.takeDamage(dmg, k.startsWith('Fire'), false, atk);
                Game.recordStat(atk, 'dmg', act);
                if(act!==-1) { 
                    m+=` ${act} í­ë°œì  í”¼í•´!`; this.shake(def); UI.floatText(def, act, "ft-crit"); AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true;
                    if (k === 'Fire') { const healAmt = Math.min(30, Math.floor(act * 0.2)); const h = atk.heal(healAmt); Game.recordStat(atk, 'heal', h); }
                } else { m+=" ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            }
        }
        
        if (!playedSound) AudioSys.play('SKILL');

        // [ë™ê¸°í™” 3] íˆë“  íŒ¨ì‹œë¸Œ í™•ë¥ 
        if(k === 'Metal-Dark' && sIdx===2 && Game.netRandom() < 0.1) {
            const aliveE = (atk.team===0?this.eTeam:this.pTeam).filter(e=>!e.isDead);
            if(aliveE.length>0) { const target = aliveE[Math.floor(Game.netRandom()*aliveE.length)]; const extra = Math.floor(baseAtk); 
            const act = target.takeDamage(extra, false, false, atk);
            if(act !== -1) { Game.recordStat(atk,'dmg',extra); m += `<br>âš¡ ê³¼ë¶€í•˜! +${extra}`; UI.floatText(target, extra, "ft-crit"); } else { UI.floatText(target, "MISS", "ft-miss"); }
          }
        }

        this.log(m); 
        // [ë™ê¸°í™” 4] í›„ì²˜ë¦¬ í•¨ìˆ˜ í˜¸ì¶œ (ì—¬ê¸°ì„œ ì„œë²„ë¡œ ì „ì†¡í•¨)
        this.postExecute(atk, def, sIdx, isRemote);
    },

    // [ì¶”ê°€ë¨] í›„ì²˜ë¦¬ ë° ì „ì†¡ í•¨ìˆ˜ (Game ê°ì²´ ì•ˆì— ì¶”ê°€í•˜ì„¸ìš”)
    postExecute: function(atk, def, sIdx, isRemote) {
        // ë‚´ê°€ í–‰ë™í•œ ê²½ìš° -> ê¸°ë¡ëœ ì£¼ì‚¬ìœ„ ê°’(netRndBuffer)ì„ ìƒëŒ€ì—ê²Œ ì „ì†¡!
        if (isOnlineMode && !isRemote) {
            socket.emit('action', {
                room: myRoom,
                attackerId: atk.id, attackerTeam: atk.team,
                targetId: def ? def.id : null, targetTeam: def ? def.team : null,
                skillIdx: sIdx,
                rndBuffer: Game.netRndBuffer // í•µì‹¬: ë‚´ê°€ êµ´ë¦° ì£¼ì‚¬ìœ„ ê°’ì„ ë³´ëƒ„
            });
        }
        this.endTurn();
    },
    
    // (ê¸°ì¡´ ìŠ¤í‚¬ ë¡œì§ì„ ê°ì‹¸ëŠ” í•¨ìˆ˜ - executeê°€ ë„ˆë¬´ ê¸¸ì–´ì„œ ë¶„ë¦¬ ì¶”ì²œ)
    runSkillLogic: function(atk, def, sIdx, baseAtk, aff, defMod, k, s, m) {
        // ì—¬ê¸°ì— ê¸°ì¡´ execute í•¨ìˆ˜ì— ìˆë˜ sIdx === 1, sIdx === 2 ë¶€ë¶„ ì½”ë“œë¥¼ ë„£ìœ¼ì„¸ìš”.
        // ê·¸ë¦¬ê³  Math.random()ì„ ì „ë¶€ Game.netRandom()ìœ¼ë¡œ ë°”ê¾¸ì„¸ìš”!
    },

        const baseAtk = atk.getAtk();
        let playedSound = false;

        if(sIdx === 0) {
            AudioSys.play('HIT'); playedSound=true;
            const dmg = Math.floor(baseAtk * 1.0 * aff.v * defMod);
            const act = def.takeDamage(dmg, false, false, atk);
            Game.recordStat(atk, 'dmg', act); 
            if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            else { 
                m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg");
                if (aff.v > 1.2 || act > 150) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; } 
                
                if (k === 'Fire') {
                    const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                    const h = atk.heal(healAmt);
                    Game.recordStat(atk, 'heal', h); 
                }
            }
        } 
        else if (sIdx === 1) {
            if(k === 'Tree') {
                atk.shield += 30; Game.recordStat(atk, 'shield', 30);
                atk.atk += 18; atk.addStatus('GROWTH', 99); 
                m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ê´‘í•©ì„±! (ì„±ì¥)`;
                UI.floatText(atk, "GROWTH", "ft-heal");
                AudioSys.play('POWER_UP'); playedSound=true;
            } else {
                let mult = 1.5; if(k==='Tree-Dark') mult += atk.thornStack; if(k==='Water-Light') mult = 1.4;
                if (k==='Metal-Light') mult = 0.5;
                if (k==='Metal') mult = 1.3;
                if (k==='Dark-Dark') mult = 0.9; 
                if(k==='Fire') mult = 1.5;

                let rawDmg = Math.floor(baseAtk * mult * aff.v * defMod);
                
                if(k==='Metal-Light' || k==='Earth') { AudioSys.play('DEBUFF'); playedSound=true; }

                if(k==='Earth') { if(Math.random() < 0.25) { def.addStatus('STUN', 1, 0, atk); m+='(ê¸°ì ˆ) '; } else if(Math.random() < 0.20) { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; } }
                
                if(k==='Metal-Light') { 
                    const broken = def.shield > 0;
                    def.shield=0; def.addStatus('POISON', 3, 0, atk); m+='(ì‰´ë“œíŒŒê´´+ì¤‘ë…) '; 
                    if (broken) {
                        const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                        const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                        if(lowest) { lowest.shield += 30; Game.recordStat(atk, 'shield', 30); UI.floatText(lowest, "+30ğŸ›¡ï¸", "ft-heal"); m+=`(ì•„êµ°ë³´í˜¸) `; }
                    }
                }

                if(k==='Dark-Dark') { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; }
                if(k==='Water-Light' && Math.random()<0.2) { def.addStatus('BLIND', 1, 0, atk); m+='(ì‹¤ëª… ì„±ê³µ) '; }
                if(k==='Fire') { def.addStatus('BURN', 2, 0, atk); m+='(í™”ìƒ) '; }
                if(k==='Fire-Dark') { (atk.team===0 ? this.eTeam : this.pTeam).forEach(e => { if(!e.isDead) e.addStatus('BURN', 2, 0, atk); }); m += '(ì „ì²´ í™”ìƒ) '; }
                if(k==='Tree-Light') {
                    const allies = atk.team===0 ? this.pTeam : this.eTeam;
                    const alive = allies.filter(a=>!a.isDead);
                    if(alive.length > 0) { 
                        const lucky = alive[Math.floor(Math.random()*alive.length)]; 
                        const h = lucky.heal(20); 
                        Game.recordStat(atk, 'heal', h); 
                        m+=`(ì•„êµ° íšŒë³µ) `; 
                    }
                }

                if(k==='Metal-Dark') { 
                    if(atk.elecStacks < 3) { 
                        atk.atk += 10;
                        atk.elecStacks++; 
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        AudioSys.play('POWER_UP');
                        m += ` (âš¡ê³µê²©ë ¥+10)`;
                    } else {
                        m += ` (âš¡MAX)`;
                    }
                }

                if (k === 'Normal') {
                    atk.hp = Math.max(1, atk.hp - 30); 
                    const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                    const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                    if (lowest) {
                        const shieldAmt = (lowest.id === atk.id) ? 60 : 50;
                        lowest.shield += shieldAmt; Game.recordStat(atk, 'shield', shieldAmt); UI.floatText(lowest, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                    m += ` (HPì†Œëª¨/ë³´í˜¸)`;
                }

                if (k === 'Dark') {
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                    m += ' (ì—…ë³´ ì‹¬ê¸°)';
                }

                if (k === 'Earth-Light' || k === 'Tree-Light') { 
                    let actual = def.takeDamage(rawDmg, false, true, atk);
                    Game.recordStat(atk, 'dmg', actual);
                    if (actual === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { m += ` ${actual} í”¼í•´ (ì‰´ë“œë¬´ì‹œ) ${aff.t}`; this.shake(def); UI.floatText(def, actual, "ft-crit"); }
                } else {
                    const act = def.takeDamage(rawDmg, k.startsWith('Fire'), false, atk);
                    Game.recordStat(atk, 'dmg', act);
                    if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { 
                        m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg"); 
                        if (k === 'Metal') {
                            const absorb = Math.floor(act * 0.3); atk.shield += absorb; Game.recordStat(atk, 'shield', absorb); UI.floatText(atk, `+${absorb}`, "ft-heal");
                        }
                        if (k === 'Fire') {
                            const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                            const h = atk.heal(healAmt);
                            Game.recordStat(atk, 'heal', h); 
                        }
                    }
                }
            }
        } 
        else {
            if (k === 'Fire-Light') { 
                if(atk.s2Count < 5) {
                    const bonuses = [40, 30, 20, 30, 40];
                    const bonus = bonuses[atk.s2Count];
                    atk.s2Count++; 
                    atk.atk += bonus;
                    AudioSys.play('POWER_UP'); 
                    m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ğŸ”¥í­ì£¼! (ê³µê²©ë ¥ +${bonus})`;
                }
                playedSound=true; 
            }

            if (k === 'Dark-Dark') {
                atk.takeDamage(20, false, false, null); AudioSys.play('DEBUFF'); playedSound=true;
                if(Math.random() < 0.75) { 
                    def.addStatus('BANISH', 1); m += " (ğŸŒŒì¶”ë°© ì„±ê³µ)"; UI.floatText(def,"ì¶”ë°©!","ft-miss"); 
                    atk.atk += 10;
                } 
                else { m += " (ì¶”ë°© ì‹¤íŒ¨)"; UI.floatText(def,"ì €í•­","ft-miss"); }
            }
            else if (k === 'Water-Dark') {
                const act = def.takeDamage(Math.floor(baseAtk), false, false, atk);
                if (act === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ${act} í”¼í•´`; UI.floatText(def, act, "ft-dmg");
                    if(Math.random() < 0.35) { def.addStatus('FREEZE', 1); m += " (â„ï¸ë¹™ê²°)"; UI.floatText(def,"ë¹™ê²°","ft-miss"); }
                }
            }
            else if (k === 'Normal') {
                const rnd = Math.random() * 1.7 + 0.8;
                const dmg = Math.floor(baseAtk * rnd * aff.v * defMod);
                const act = def.takeDamage(dmg, false, false, atk); 
                if (act === -1) { m += " ì£¼ì‚¬ìœ„ ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ì£¼ì‚¬ìœ„(x${rnd.toFixed(2)}) ${act}`; this.shake(def); UI.floatText(def, act, "ft-dmg");
                    if(rnd > 2.0) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; }
                }
            }
           else if(s.type === 'AOE') {
                m += " (ì „ì²´ ê³µê²©!)";

                let earthMult = 0.8; 
                if (k === 'Earth') {
                    const pAlive = this.pTeam.filter(u => !u.isDead).length;
                    const eAlive = this.eTeam.filter(u => !u.isDead).length;
                    if (pAlive === 1 && eAlive === 1) { earthMult = 1.8; m += " <br><span class='log-crit'>ğŸ”¥1:1 ì§„ê²€ìŠ¹ë¶€! (ë°ë¯¸ì§€ 1.8ë°°)</span>"; }
                }

                (atk.team===0?this.eTeam:this.pTeam).forEach(e => { if(!e.isDead) {
                    let indDefMod = 1.0;
                    const da = Game.calc(atk, e); const dd = Game.calc(e, atk); 
                    if (da.v < 1.2) { if(dd.v===1.3) indDefMod=0.76; else if(dd.v===1.2) indDefMod=0.83; }

                    const dmg = Math.floor(baseAtk * earthMult * da.v * indDefMod);
                    const act = e.takeDamage(dmg, k.startsWith('Fire'), false, atk);
                    Game.recordStat(atk, 'dmg', act);
                    if(act !== -1) { 
                        this.shake(e); UI.floatText(e, act, "ft-dmg"); 
                        if(k==='Earth-Light') e.addStatus('BLIND', 2); 
                        
                        if(k==='Metal-Dark' && Math.random()<0.15) {
                            e.addStatus('STUN', 1, 0, atk);
                            m += ` <span style="color:#ffd54f; font-weight:bold;">(âš¡ê¸°ì ˆ)</span>`;
                        }

                        if(k==='Fire' && Math.random()<0.25) e.addStatus('BURN', 2, 0, atk); 
                        if (k === 'Fire') {
                            const healAmt = Math.min(30, Math.floor(act * 0.2)); const h = atk.heal(healAmt); Game.recordStat(atk, 'heal', h); 
                        }
                    } else { UI.floatText(e, "MISS", "ft-miss"); }
                }});
            } 
            else if(s.type === 'HEAL') { 
                AudioSys.play('HEAL'); playedSound=true;
                const healBase = k === 'Water' ? 125 : 110;
                (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{
                    if(!a.isDead) { const h = a.heal(healBase); Game.recordStat(atk, 'heal', h); }
                });
                m+=` (ì•„êµ° ì „ì²´ íšŒë³µ +${healBase})`; 
                if(k==='Water' && Math.random() < 0.2) {
                    const lowest = (atk.team===0?this.pTeam:this.eTeam).filter(a=>!a.isDead).sort((a,b)=>a.hp-b.hp)[0];
                    if(lowest) { const h = lowest.heal(50); Game.recordStat(atk, 'heal', h); m+=` (ğŸ’§ëŒ€ë°•í +50)`; UI.floatText(lowest, "+50", "ft-heal"); }
                }
            }
            else if(s.type === 'BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(k !== 'Fire-Light') m += " (ì•„êµ° ì „ì²´ ê°•í™”)";
                const allies = atk.team===0?this.pTeam:this.eTeam;
                if(k==='Light') allies.forEach(a=>{if(!a.isDead) { a.shield=Math.min(300, a.shield+70); a.addStatus('LIGHT_MIGHT', 1); Game.recordStat(atk,'shield',70); }}); 
                else if(k==='Light-Light') allies.forEach(a=>{if(!a.isDead) {a.shield=Math.min(300, a.shield+50); Game.recordStat(atk,'shield',50); a.cleanse();}}); 
                else if(k==='Tree-Light') allies.forEach(a=>{if(!a.isDead) { const h = a.heal(70); Game.recordStat(atk, 'heal', h); a.cleanse(); }});
            } 
            else if(s.type === 'TARGET_BUFF' || s.type === 'SELF_BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(def) { 
                    if(k==='Tree') { const h = def.heal(150); Game.recordStat(atk, 'heal', h); def.cleanse(); m+=` ì¹˜ìœ /ì •í™”`; }
                    else if(k==='Tree-Dark') { 
                        if (atk.id === def.id) { } else { atk.linkedAllyId = def.id; def.addStatus('BIND', 99); atk.resist += 0.3; m+=` ê²°ì†! (í­ì£¼ëŒ€ê¸°/ì €í•­â†‘)`; }
                    }
                    else if(k==='Water-Light') {
                        (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{if(!a.isDead) a.addStatus('EVADE', 2)});
                        const healAmt = Math.floor((def.maxHp - def.hp) * 0.15); const h = def.heal(healAmt); Game.recordStat(atk, 'heal', h); m += ` (íšŒí”¼ì¦ê°€+ì¹˜ìœ )`;
                    }
                }
            } 
            else if(s.type === 'DEBUFF') {
                AudioSys.play('DEBUFF'); playedSound=true;
                if(k==='Metal') { 
                    const enemies = (atk.team===0?this.eTeam:this.pTeam);
                    enemies.forEach(e => { e.status = e.status.filter(s => s.type !== `PROVOKED_BY_${atk.id}`); });
                    def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk); atk.shield+=15; Game.recordStat(atk,'shield',15); m += ` ë„ë°œ! (ì‰´ë“œ+15)`; 
                }
                else if(k==='Dark') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{if(!e.isDead){ e.addStatus('ATK_DOWN', 2); e.shield=Math.floor(e.shield*0.7); if(Math.random()<0.2) e.dispel(); }}); m+=" (ì  ì „ì²´ ê³µí¬)"; }
                else if(k==='Metal-Light') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{ if(!e.isDead) { e.addStatus('POISON', 3); } }); m+=" (ê´‘ì—­ ì¤‘ë… ì‚´í¬)"; }
                else if(k==='Earth-Light') { def.addStatus('TRAP', 2); def.addStatus('HEAL_DOWN', 2); m+=` ëª¨ë˜ì§€ì˜¥(ì†ë°•+ì¹˜ìœ ê°ì†Œ)`; }
            } 
            else if(s.type === 'NUKE' || s.type === 'NUKE_PER' || s.type === 'ATK') {
                let dmg = 0;
                if (s.type === 'NUKE_PER') dmg = Math.floor(baseAtk * 1.2 * aff.v * defMod + def.maxHp * 0.1);
                else if (k === 'Earth-Dark') dmg = Math.floor(baseAtk * 2.5 * aff.v * defMod);
                else dmg = Math.floor(baseAtk * 2.0 * aff.v * defMod);

                if(k==='Earth-Dark') atk.addStatus('STUN', 2, 0, atk);
                
                const act = def.takeDamage(dmg, k.startsWith('Fire'), false, atk);
                Game.recordStat(atk, 'dmg', act);
                if(act!==-1) { 
                    m+=` ${act} í­ë°œì  í”¼í•´!`; this.shake(def); UI.floatText(def, act, "ft-crit"); AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true;
                    if (k === 'Fire') { const healAmt = Math.min(30, Math.floor(act * 0.2)); const h = atk.heal(healAmt); Game.recordStat(atk, 'heal', h); }
                } else { m+=" ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            }
        }
        
        if (!playedSound) AudioSys.play('SKILL');

        if(k === 'Metal-Dark' && sIdx===2 && Math.random() < 0.1) {
            const aliveE = (atk.team===0?this.eTeam:this.pTeam).filter(e=>!e.isDead);
            if(aliveE.length>0) { const target = aliveE[Math.floor(Math.random()*aliveE.length)]; const extra = Math.floor(baseAtk); 
            const act = target.takeDamage(extra, false, false, atk);
            if(act !== -1) { Game.recordStat(atk,'dmg',extra); m += `<br>âš¡ ê³¼ë¶€í•˜! +${extra}`; UI.floatText(target, extra, "ft-crit"); } else { UI.floatText(target, "MISS", "ft-miss"); }
          }
        }
        this.log(m); this.endTurn();
    },

    die: function(u) { 
        if(u.isDead) return; 
        u.isDead=true; u.hp=0; u.status=[]; 
        Game.log(`${u.name} íƒˆë½`); 
        
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team===0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => { 
                if(!e.isDead) e.addStatus('POISON', 1, 0, u); 
            });
        }

        const allies = u.team===0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base==='Tree' && a.extra==='Dark' && !a.isDead && a.linkedAllyId === u.id);
        
        thorns.forEach(thorn => {
            thorn.thornStack += 0.3; 
            thorn.atk += 20; 
            thorn.linkedAllyId = -1; 
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µê²©ë ¥ ì¦ê°€)`);
            UI.floatText(thorn, "RAGE!", "ft-crit"); 
        });
    },
    
    endCheck: function() {
        const pd=this.pTeam.every(u=>u.isDead), ed=this.eTeam.every(u=>u.isDead);
        if(pd||ed) { 
            this.isOver = true; 
            if(this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN'); 
            
            if (ed && this.difficulty === 'hell' && !pd) { 
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if(this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)"); 
            }
            localStorage.removeItem('et_save_v6');
            return true; 
        } 
        return false;
    },
    
    log: function(m) { const b=document.getElementById('logs'); const d=document.createElement('div'); d.className='log-entry'; d.innerHTML=m; b.appendChild(d); b.scrollTop = b.scrollHeight; },
    
    shake: function(u) { const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`; const el = document.getElementById(id); if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); } },

    saveGame: function() {
        if (this.isOver) { alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue, curr: this.curr, turnCount: this.turnCount,
            difficulty: this.difficulty, mode: this.mode, selected: this.selected 
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },

    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if(savedStage) this.challengeStage = parseInt(savedStage);
        
        if (!json) { alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`); return; }

        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty; this.mode = data.mode;
            this.turnCount = data.turnCount; this.curr = data.curr;
            this.queue = data.queue; this.selected = data.selected;

            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
            
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;

            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) { console.error(e); alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤."); }
    },

    serializeUnit: function(u) {
        return {
            id: u.id, team: u.team, base: u.base, extra: u.extra,
            hp: u.hp, maxHp: u.maxHp, shield: u.shield, atk: u.atk,
            status: u.status, isDead: u.isDead,
            thornStack: u.thornStack, linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count, elecStacks: u.elecStacks,
            stats: u.stats
        };
    },

    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp; u.maxHp = d.maxHp; u.shield = d.shield; u.atk = d.atk;
        u.status = d.status; u.isDead = d.isDead;
        u.thornStack = d.thornStack; u.linkedAllyId = d.linkedAllyId;
        u.s2Count = d.s2Count; u.elecStacks = d.elecStacks;
        u.stats = d.stats;
        return u;
    }
    
    , calc: (a,d) => {
        let v = 1.0;
        let t = '';
        if(a.isNormal) {
            if(d.isNormal || d.isEnhanced) { v=1.2; t='(ê°•íƒ€)'; }
        } else {
            const w={'Fire':['Metal','Tree'],'Water':['Fire','Metal'],'Tree':['Water','Earth'],'Metal':['Tree','Earth'],'Earth':['Fire','Water']};
            const ew={'Light':['Dark'],'Dark':['Light']};
            if(!d.isNormal){ 
                if(w[a.base]?.includes(d.base)||ew[a.base]?.includes(d.base)) { v=1.2; t='(ì•½ì )'; }
            }
        }
        if(v===1.2 && a.extra && d.extra && ((a.extra==='Light'&&d.extra==='Dark')||(a.extra==='Dark'&&d.extra==='Light'))) { v=1.3; t='(ì¹˜ëª…íƒ€!)'; }
        return {v, t};
    }
};

window.onload = function() { Game.init(); };
</script>
</body>
</html>
