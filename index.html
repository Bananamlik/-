<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v9.4 Stable</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fff5f8; --panel-bg: #ffffff; --text-main: #5d4037;
            --accent: #ff80ab; --hp-high: #80deea; --hp-low: #ffcc80; --shield: #ce93d8;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255,255,255,0.8), inset 0 -3px 6px rgba(0,0,0,0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }
        body { margin: 0; background-color: var(--bg-main); background-image: var(--paw-pattern); background-size: 80px 80px; color: var(--text-main); font-family: var(--font-main); overflow: hidden; user-select: none; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; height: 100dvh; }
        
        #app { width: 100%; max-width: 600px; height: 100%; position: relative; display: flex; flex-direction: column; transition: 0.3s; }
        
        .screen-shake { animation: jelly-bounce 0.5s both; }
        @keyframes jelly-bounce { 0% { transform: scale(1, 1); } 30% { transform: scale(1.15, 0.85); } 40% { transform: scale(0.9, 1.1); } 50% { transform: scale(1.05, 0.95); } 65% { transform: scale(0.98, 1.02); } 100% { transform: scale(1, 1); } }
        
        button { font-family: var(--font-main); border-radius: 25px; border: none; background: #fff; color: #777; cursor: pointer; transition: 0.1s; box-shadow: var(--jelly-shadow); transform: translateY(0); position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%; background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0)); border-radius: 20px; pointer-events: none; }
        button:active { transform: translateY(3px) scale(0.98); box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); }
        .btn-restart { padding: 8px 12px; font-size: 14px; color: var(--accent); }
        .btn-restart:hover { background: #fff0f5; }
        .mute-btn { position: absolute; top: 15px; right: 15px; width: 40px; height: 40px; border-radius: 50%; background: #fff; border: 2px solid #eee; font-size: 20px; display: flex; align-items: center; justify-content: center; z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1); cursor: pointer; transition: 0.2s; }
        .mute-btn:active { transform: scale(0.9); }
        .mute-btn.muted { background: #ffebee; color: #e57373; border-color: #ffcdd2; }
        
        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; padding: 10px; z-index: 10; overflow: hidden; }
        #selection-screen { background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); overflow-y: auto;}
        #battle-screen { display: none; padding: 5px; height: 100%; justify-content: space-between; }
        
        .hero-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; overflow-y: auto; padding: 5px; flex: 1; }
        .hero-card { background: #fff; border-radius: 20px; padding: 6px; cursor: pointer; transition: 0.2s; display: flex; flex-direction: column; align-items: center; box-shadow: 0 5px 15px rgba(0,0,0,0.05), inset 0 0 0 3px #fce4ec; position: relative; min-height: 100px; justify-content: center;}
        .hero-card:active { transform: scale(0.95); }
        .hero-card.selected { background: #e1bee7; box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4); transform: translateY(-5px); }
        .hero-card.selected::after { content: 'ğŸ¾'; position: absolute; top: -10px; right: -5px; background: var(--accent); color: #fff; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; box-shadow: 0 3px 6px rgba(0,0,0,0.2); z-index: 5; border: 2px solid #fff; }
        
        .field-row { flex: 1; display: flex; justify-content: space-evenly; align-items: center; width: 100%; perspective: 1000px; padding: 5px 0; min-height: 0; }
        .unit { width: 30vw; max-width: 130px; background: #fff; border-radius: 20px; padding: 8px 4px; position: relative; transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); cursor: default; box-shadow: inset 0 4px 10px rgba(255,255,255,1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0,0,0,0.1); text-align: center; display: flex; flex-direction: column; align-items: center; min-height: 110px; justify-content: flex-end; border: 2px solid #f8bbd0; flex-shrink: 1; }
        
        .elec-badge { position: absolute; top: -5px; right: -5px; background: #ffeb3b; color: #f57f17; font-weight: 900; border: 2px solid #fff; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 14px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 5; animation: jelly-bounce 1s infinite; }
        .unit.active-turn { border-color: var(--accent); transform: translateY(-12px) scale(1.05); z-index: 5; box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3); }
        .unit.target-enemy:hover { border-color: #ff7043; background: #ffebee; cursor: crosshair; transform: scale(1.05) rotate(2deg); }
        .unit.target-ally:hover { border-color: #66bb6a; background: #e8f5e9; cursor: pointer; transform: scale(1.05) rotate(-2deg); }
        .unit.target-aoe { border-color: #ff7043; background: #ffebee; animation: jelly-bounce 1s infinite; cursor: pointer; }
        .unit.dead { opacity: 0.6; filter: grayscale(1); pointer-events: none; border-color: #cfd8dc; transform: scale(0.9) rotate(5deg); box-shadow: none; }
        .unit.role-tank { border-radius: 20px; } .unit.role-nuker { border-radius: 35px 15px; } .unit.role-supp { border-radius: 50px; }
        
        .attr-icon { width: 44px; height: 44px; border-radius: 50%; margin-bottom: 2px; display: flex; justify-content: center; align-items: center; font-size: 26px; color: #fff; position: relative; box-shadow: 0 4px 0 rgba(0,0,0,0.1); border: 3px solid #fff; flex-shrink: 0; }
        .mini-attr-box { position: absolute; bottom: -2px; right: -2px; display: flex; gap: 1px; background: rgba(255,255,255,0.95); padding: 2px; border-radius: 12px; border: 2px solid #eee; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .mini-icon { font-size: 10px; line-height: 1; }
        
        .status-bar { width: 85%; height: 10px; background: #eceff1; border-radius: 12px; overflow: hidden; position: relative; margin-top: 4px; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.05); flex-shrink: 0; }
        .hp-fill { height: 100%; background: var(--hp-high); border-radius: 10px; transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .hp-fill::after { content:''; position:absolute; top:2px; left:2px; right:2px; height:3px; background:rgba(255,255,255,0.4); border-radius:10px; }
        .shield-fill { position: absolute; top:0; left:0; height: 100%; background: var(--shield); opacity: 0.8; border-radius: 10px; transition: width 0.3s; }
        
        .control-panel { flex: 0 0 auto; max-height: 45vh; background: rgba(255,255,255,0.95); border-radius: 30px 30px 0 0; box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15); display: flex; flex-direction: column; overflow: hidden; width: 100%; border-top: 5px solid #ff80ab; backdrop-filter: blur(10px); z-index: 20; }
        .cp-header { padding: 8px 15px; background: #fff8e1; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dashed #ffe082; font-size: 14px; }
        .timeline-container { height: 40px; background: #fff; border-bottom: 2px dashed #ffcdd2; display: flex; align-items: center; padding: 0 10px; overflow: hidden; gap: 5px; flex-shrink: 0; }
        .timeline-label { font-size: 12px; font-weight: bold; color: var(--accent); margin-right: 5px; }
        @keyframes active-pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); } 70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); } }
        .tl-node { width: 28px; height: 28px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 16px; border: 2px solid #eee; position: relative; flex-shrink: 0; transition:0.3s; background: #fff; box-shadow: 0 2px 0 #ddd; }
        .tl-node.curr { border-color: var(--accent); transform: scale(1.3); z-index: 2; animation: active-pulse 1.5s infinite; border-width: 3px; }
        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; } .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }
        
        .log-container { flex: 1; padding: 10px; overflow-y: auto; font-size: 12px; border-bottom: 2px solid #f0f0f0; background: #fff; line-height: 1.5; display: flex; flex-direction: column; min-height: 50px; max-height: 120px; }
        .log-entry { margin-bottom: 4px; padding: 4px 8px; background: #fafafa; border-radius: 10px; word-break: keep-all; border-left: 3px solid #eee; display: flex; align-items: center; gap: 4px; }
        .log-ally { color: #29b6f6; font-weight:bold; } .log-enemy { color: #ff7043; font-weight:bold; } .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }
        
        .btn-group { display: flex; height: 80px; flex-shrink: 0; padding: 5px; gap: 5px; background: #fff5f8; }
        .skill-btn { flex: 1; border: none; background: #fff; border-radius: 15px; cursor: pointer; transition: 0.2s; color: var(--text-main); display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; padding: 4px; box-shadow: var(--jelly-shadow); transform: translateY(0); }
        .skill-btn::before { content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%; background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0)); border-radius: 15px; pointer-events: none; }
        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform:none; }
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }
        
        .passive-panel { background: #e0f2f1; padding: 5px 10px; font-size: 11px; color: #00695c; display: flex; align-items: center; border-radius: 10px; margin: 4px 10px; border: 1px solid #b2dfdb; flex-shrink: 0; }
        .passive-icon { margin-right: 5px; font-size: 14px; }
        
        .btn-start { background: var(--accent); color: white; border: none; padding: 15px; border-radius: 30px; font-weight: bold; width: 100%; margin-top: 10px; cursor: pointer; font-size: 20px; box-shadow: 0 6px 0 #c2185b, 0 15px 20px rgba(0,0,0,0.15); transition: 0.2s; position: relative; overflow: hidden; }
        .btn-start::after { content:'ğŸ¾'; font-size:24px; margin-left:10px; opacity:0.8; }
        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(6px); box-shadow: 0 2px 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform:none; }
        .btn-rnd { background:#b39ddb; color:#fff; border:none; padding:10px 15px; border-radius:20px; cursor:pointer; font-weight:bold; margin-left:5px; box-shadow: 0 4px 0 #7e57c2; }
        .btn-rnd:active { transform: translateY(4px); box-shadow:none; }
        
        /* [UI ê°œì„ ] íƒœê·¸ ì»¨í…Œì´ë„ˆ ìµœì í™” */
        .tag-container { position: absolute; top: 2px; left: 2px; right: 2px; display: flex; justify-content: center; gap: 2px; flex-wrap: wrap; z-index: 10; pointer-events: none; max-height: 36px; overflow: hidden; align-content: flex-start; }
        .tag { padding: 2px 4px; border-radius: 6px; font-size: 9px; line-height: 1; color: #fff; font-weight: bold; box-shadow: 0 1px 2px rgba(0,0,0,0.2); margin-bottom: 1px; white-space: nowrap; height: 14px; display: flex; align-items: center; }
        .tag.poison { background: #ab47bc; } .tag.stun { background: #ffd54f; color:#5d4037; } .tag.freeze { background: #29b6f6; } .tag.silence { background: #78909c; } .tag.evade { background: #42a5f5; } .tag.burn { background: #ff7043; } .tag.banish { background: #263238; } .tag.bind { background: #66bb6a; } .tag.trap { background: #d4e157; color:#5d4037; } .tag.atkdown { background: #5c6bc0; } .tag.growth { background: #9ccc65; color:#33691e; } .tag.blind { background: #bdbdbd; color:#5d4037; } .tag.immunity { background: #fff; color:#5d4037; border:1px solid #5d4037; } .tag.healdown { background: #8d6e63; color:#fff; } .tag.atkup { background: #ef5350; color:#fff; } .tag.taunt { background: #212121; color: #ff5252; border: 1px solid #ff1744; box-shadow: 0 0 4px rgba(255, 23, 68, 0.6); font-weight: 900; } .tag.karma { background: #512da8; color:#fff; border: 1px solid #d1c4e9; animation: jelly-bounce 2s infinite; }
        
        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); } .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); } .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color:#1b5e20; } .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); } .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); } .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; } .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); } .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color:#5d4037; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color:#5d4037; box-shadow: 0 0 15px #fff9c4; } .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }
        .float-text { position: absolute; font-weight: 900; font-size: 28px; pointer-events: none; z-index: 100; text-shadow: 2px 2px 0px #fff; animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; }
        @keyframes floatUp { 0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; } 100% { transform: translate(-50%, -60px) scale(1); opacity: 0; } }
        .ft-dmg { color: #ff7043; } .ft-crit { color: #ffa726; font-size: 36px; } .ft-heal { color: #26a69a; } .ft-miss { color: #b0bec5; font-size: 20px; }
        #modal-overlay { position: fixed; inset: 0; background: rgba(255, 248, 225, 0.85); backdrop-filter:blur(5px); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #fff; padding: 25px; border-radius: 35px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3); overflow-y:auto; max-height:80vh; border: 5px solid #ffcc80; position: relative;}
        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        /* [UI ê°œì„ ] ì‘ì€ í™”ë©´ ëŒ€ì‘ (ë…¸íŠ¸ë¶/ëª¨ë°”ì¼ ê°€ë¡œ) */
        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 40vh; }
            .btn-group { height: 60px; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 9px; } /* ê³µê°„ ë¶€ì¡±ì‹œ ì„¤ëª… ìˆ¨ê¹€ */
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
    </style>
<script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div>
<button class="mute-btn" id="btn-mute" onclick="AudioSys.toggleMute()">ğŸ”Š</button>

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v9.4 Stable (Fix: Metal/Light/Draw)</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                      <option value="pvp">âš”ï¸ ì˜¨ë¼ì¸ PVP (í…ŒìŠ¤íŠ¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        <!-- [ì¶”ê°€] ë°© ì½”ë“œ ì…ë ¥ì°½ -->
        <div style="margin-top:5px; display:flex; gap:5px;">
            <input type="text" id="room-code" placeholder="ë°© ì½”ë“œ (ì˜ˆ: 1234)" style="flex:1; padding:10px; border-radius:15px; border:2px solid #7e57c2; text-align:center; font-weight:bold; outline:none; font-family: var(--font-main);">
        </div>
        
        <button id="btn-online" class="btn-start" style="background:#7e57c2; margin-top:5px;" onclick="startOnlineGame()">
             ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë°© ë§Œë“¤ê¸°/ì°¸ê°€)
        </button>
        <button id="btn-start" class="btn-start" onclick="Game.start()" disabled>ì „íˆ¬ ì‹œì‘ (0/3)</button>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
// [ë„¤íŠ¸ì›Œí¬] ì„œë²„ í†µì‹  ë° ë‚œìˆ˜ ë™ê¸°í™” ì„¤ì •
let socket;
if (typeof io !== 'undefined') { socket = io(); console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)"); } 
else { socket = { on: () => {}, emit: () => {}, connected: false, connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); } }; console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ"); }

let myRole = null; let myRoom = null; let isOnlineMode = false;
let netRndBuffer = []; let netRndIdx = 0; let isReplaying = false; 

function getNetRandom() {
    if (isOnlineMode && isReplaying) return netRndBuffer[netRndIdx++] || Math.random(); 
    const val = Math.random(); if (isOnlineMode) netRndBuffer.push(val); return val;
}

socket.on('gameStart', (data) => {
    isOnlineMode = true; myRole = data.role; myRoom = data.room;
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display='none';
    document.getElementById('battle-screen').style.display='flex';
    document.getElementById('logs').innerHTML = ''; 
    Game.difficulty = 'online'; Game.mode = 'pvp'; Game.turnCount = 1; Game.isOver = false;
    
    if (myRole === 'player2') Game.queue = [1,0,3,2,5,4]; else Game.queue = [0,1,2,3,4,5];
    Game.curr = 0; Game.isProcessing = false; Game.netRndBuffer = []; Game.netRndIdx = 0; Game.isReplaying = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => { const original = Game.pool[idx]; return new Unit(myIds[i], 0, original.base, original.extra); });
    const enemyIndices = data.enemyDeck; 
    Game.eTeam = enemyIndices.map((idx, i) => { const original = Game.pool[idx]; return new Unit(enIds[i], 1, original.base, original.extra); });
    Game.render();
    if (myRole === 'player2') { Game.noInput(); document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘..."; } else { Game.timer = setTimeout(()=>Game.turn(), 1000); }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    if(attacker) {
        // [ìˆ˜ì •] Game.xxx ê°€ ì•„ë‹ˆë¼ ì „ì—­ ë³€ìˆ˜(netRndBuffer)ì— ê°’ì„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.
        netRndBuffer = data.rndBuffer; 
        netRndIdx = 0; 
        isReplaying = true; 
        
        Game.execute(attacker, target, data.skillIdx, true); 
        
        isReplaying = false; 
    }
});

// [ì¶”ê°€ëœ ì½”ë“œ] ìƒëŒ€ë°© íƒˆì£¼ ê°ì§€ (ì„œë²„ì˜ ì™¸ì¹¨ì„ ë“£ëŠ” ê·€)
socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)"); // ìŠ¹ë¦¬ ë°°ë„ˆ ë„ìš°ê¸°
    isOnlineMode = false;
    // í•„ìš”í•˜ë‹¤ë©´ ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê²Œ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
    // location.reload();
});

// [ì¶”ê°€] ì„œë²„ë¡œë¶€í„° 'ëŒ€ê¸° ì¤‘' ë©”ì‹œì§€ë¥¼ ë°›ìœ¼ë©´ ë²„íŠ¼ ê¸€ì”¨ ë³€ê²½
socket.on('waiting', (msg) => {
    const btn = document.getElementById('btn-online');
    btn.innerText = "â³ " + msg;
});

// [ì¶”ê°€] ì—ëŸ¬ ë©”ì‹œì§€ (ì½”ë“œë¥¼ ì•ˆ ì ì—ˆì„ ë•Œ)
socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('btn-online');
    btn.disabled = false;
    btn.innerText = "ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë°© ë§Œë“¤ê¸°/ì°¸ê°€)";
    btn.style.backgroundColor = '#7e57c2';
});

function startOnlineGame() {
    AudioSys.init();
    if (!socket || !socket.connected) { alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."); return; }
    if (Game.selected.length !== 3) { alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!"); return; }
    
    // [ìˆ˜ì •] ë°© ì½”ë“œ ì…ë ¥ê°’ ê°€ì ¸ì˜¤ê¸°
    const codeInput = document.getElementById('room-code');
    const code = codeInput.value.trim();
    
    if (!code) {
        alert("ì¹œêµ¬ì™€ ê³µìœ í•  'ë°© ì½”ë“œ'ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!\n(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple ë“±)");
        codeInput.focus();
        return;
    }

    const btn = document.getElementById('btn-online');
    if(btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
    
    btn.disabled = true; 
    btn.style.backgroundColor = '#ccc'; 
    btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";
    
    // [ìˆ˜ì •] ë± ì •ë³´ì™€ í•¨ê»˜ 'ë°© ì½”ë“œ'ë¥¼ ì„œë²„ë¡œ ì „ì†¡
    socket.emit('findMatch', { deck: Game.selected, roomCode: code });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+30%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15/ë°ë¯¸ì§€X', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ìµœëŒ€í”¼í•´ 30% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ê³µ+18/ì‰´ë“œ+30(ë¬´í•œ)', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'ALLY', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤<br>ìê°€ì„±ì¥ + í', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(2í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 25%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ ì²´ë ¥íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤. (ê²Œì„ë‹¹ 1íšŒ)' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.6ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ (ìœ í†µê¸°í•œ)', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2í„´ ê³µ+20, 3~6í„´ ê³µ+10, 7í„´ ì´í›„ 0' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°©', passive:'ğŸ² ë©´ì—­: CCê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ ë“±)ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤. (ë„íŠ¸ë”œ ì œì™¸)' },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'ì²´ë ¥ë¹„ë¡€í”¼í•´(+10%)', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì²´ë ¥ë¹„ë¡€ ë¸Œë£¨ì €', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+ìê°€ê¸°ì ˆ', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ/ì¹¨ë¬µ', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ê¸°ì ˆ / ì¹¨ë¬µ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²°', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.3ë°°/í•´ì œ/ìŠ¤íƒë‹¤ìš´', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…(3í„´)', type:'DEBUFF', target:'ALL_ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë²„í”„ ì œê±° + ìŠ¤íƒ íŒŒê´´', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°+ì‰´ë“œë¬´ì‹œ', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•+ì¹˜ìœ ê°ì†Œ(ê°•)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì†ë°• + ì¹˜ìœ ê°ì†Œ', passive:null },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë°˜ì‚¬ê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì¦ê°€.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´120+(20%í™•ë¥ 50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°(ê´€í†µ)+ëœë¤í20', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + íšŒë³µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15(ì¤‘ì²©ì‹œ+20)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.3ë°°/ê³µ20~35%â†“/ì‰´ë“œ30%íŒŒê´´', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ', s2:'ë¸”ë™í™€', s2d:'í„´ ìŠ¤í‚µ(75%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ•³ï¸', desc:'ìŠ¤í˜ì…œë¦¬ìŠ¤íŠ¸<br>í„´ ì‚­ì œ', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ë¸”ë™í™€ ì„±ê³µ ì‹œ ê³µê²©ë ¥ì´ 10 ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.' }
};

const ChallengeDB = [
    { name: "ì •ì„ ë©”íƒ€", desc: "ë¬¼(í)+ë¶ˆ(ë”œ)+ì‡ (íƒ±)ì˜ ê°€ì¥ ì•ˆì •ì ì¸ ê³ ìŠ¹ë¥  ì¡°í•©.", team: ['Water', 'Fire', 'Metal'] },
    { name: "CC ì§€ì˜¥", desc: "ë¹™ê²°, ê¸°ì ˆ, í„´ ì‚­ì œë¡œ ì•„ë¬´ê²ƒë„ ëª»í•˜ê²Œ í•©ë‹ˆë‹¤.", team: ['Water-Dark', 'Earth', 'Dark-Dark'] },
    { name: "ë¬´í•œ ë™ë ¥", desc: "ì„±ì¥í•˜ëŠ” ë‚˜ë¬´ì™€ ì•ˆê°œ íšŒí”¼ë¡œ ë²„í‹°ëŠ” ì¢€ë¹„ ë±.", team: ['Tree', 'Tree-Light', 'Water-Light'] },
    { name: "ì² ì˜¹ì„±", desc: "ëš«ì„ ìˆ˜ ì—†ëŠ” ì‰´ë“œì™€ ì •í™”ë¡œ í„´ì„ ë‚­ë¹„ì‹œí‚µë‹ˆë‹¤.", team: ['Metal', 'Light', 'Light-Light'] },
    { name: "ê·¹ë”œ í­ê²©", desc: "ì²´ë ¥ ë¹„ë¡€ ë°ë¯¸ì§€ì™€ í•œë°© ë”œë¡œ íƒ±ì»¤ë¥¼ ë…¹ì…ë‹ˆë‹¤.", team: ['Fire-Dark', 'Earth-Dark', 'Fire-Light'] },
    { name: "ë””ë²„í”„ êµ°ë‹¨", desc: "ì‰´ë“œ íŒŒê´´, ì¹˜ìœ  ê°ì†Œ, ë°˜ì‚¬ë¡œ ë§ë ¤ ì£½ì…ë‹ˆë‹¤.", team: ['Metal-Light', 'Earth-Light', 'Dark'] },
    { name: "ë³€ì¹™ì˜ ì œì™•", desc: "ì™„ì „ ë©´ì—­ê³¼ ë³µìˆ˜, ê´‘ì—­ ê¸°ì ˆì˜ ê¹Œë‹¤ë¡œìš´ ì¡°í•©.", team: ['Normal', 'Tree-Dark', 'Metal-Dark'] },
    { name: "ì†ì„± ë§ˆìŠ¤í„°", desc: "ë‹¤ì–‘í•œ ì†ì„±ìœ¼ë¡œ ì•½ì ì„ ì°Œë¥´ëŠ” ê³µê²©ì ì¸ ì¡°í•©.", team: ['Fire', 'Tree-Light', 'Earth'] },
    { name: "ì™•ì˜ ê·€í™˜", desc: "í›„ë°˜ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ë§‰ì„ ìˆ˜ ì—†ëŠ” ì™•ê·€í˜• ë±.", team: ['Water', 'Metal-Dark', 'Normal'] },
    { name: "ìµœì¢… ë³´ìŠ¤", desc: "ê°œë°œìê°€ ì¸ì •í•œ ê³µìˆ˜ ë°¸ëŸ°ìŠ¤ 0í‹°ì–´ ì¡°í•©.", team: ['Dark-Dark', 'Light-Light', 'Water-Light'] }
];

// ================= [ìƒˆë¡œìš´ ë¡œì§ êµ¬ì¡°: Strategy Pattern] =================
// ê³µí†µ ë¡œì§ ëª¨ìŒ
const Common = {
    // ë¡œê·¸ í—¬í¼
    logAction: function(game, type, source, target, value, extra='') {
        let icon = '';
        let colorClass = '';
        if(type === 'dmg') { icon = 'ğŸ’¥'; colorClass = 'log-enemy'; }
        else if(type === 'heal') { icon = 'ğŸ’š'; colorClass = 'log-ally'; }
        else if(type === 'shield') { icon = 'ğŸ›¡ï¸'; colorClass = 'log-ally'; }
        else if(type === 'miss') { icon = 'ğŸ’¨'; colorClass = 'log-sys'; }
        
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else {
            msg = `[${source.name.split(' ')[0]}] ${extra}`;
        }
        game.log(msg);
    },

    // ê¸°ë³¸ ê³µê²© (S0) í‘œì¤€ ë¡œì§
    basicAttack: function(atk, def, game) {
        AudioSys.play('HIT');
        
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); UI.floatText(atk, "BLINDED", "ft-miss"); return; }

        const baseAtk = atk.getAtk();
        const aff = (def && def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * 1.0 * aff.v * blindMod);
        
        const act = def.takeDamage(dmg, false, false, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));

        if(act !== -1) {
            Common.logAction(game, 'dmg', atk, def, act, aff.t);
            // í¬ë¦¬í‹°ì»¬/ì¼ë°˜ íˆíŠ¸ ë¶„ê¸°
            const isCrit = (act >= 200) || (atk.isNormal && def.isNormal && act > baseAtk);
            UI.floatText(def, act, isCrit ? "ft-crit" : "ft-dmg");
            if (isCrit) { AudioSys.play('CRITICAL'); UI.screenShake(); }
            else game.shake(def);

            // [í‘¸ë¥¸ë¶ˆ] í¡í˜ˆ íŒ¨ì‹œë¸Œ
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.20));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else {
            Common.logAction(game, 'miss', atk, def, 0);
            UI.floatText(def, "MISS", "ft-miss");
        }
    },
    
    // ë‹¨ìˆœ ë°ë¯¸ì§€ ì ìš©
    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { UI.floatText(atk, "BLINDED", "ft-miss"); Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); return -1; }
        
        const baseAtk = atk.getAtk();
        const aff = (def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * mult * aff.v);
        
        const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        
        if(act !== -1) {
            UI.floatText(def, act, act>=200?"ft-crit":"ft-dmg");
            game.shake(def);
            // ë¡œê·¸ëŠ” ìŠ¤í‚¬ ê°œë³„ ë¡œì§ì—ì„œ ì¢€ ë” ë””í…Œì¼í•˜ê²Œ ì²˜ë¦¬í•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ê³µí†µì²˜ë¦¬
            // ì—¬ê¸°ì„œëŠ” ì‹¬í”Œí•˜ê²Œ ê°’ ë°˜í™˜
        } else {
            UI.floatText(def, "MISS", "ft-miss");
        }
        return act;
    },

    // ì•„êµ° ì „ì²´ ë£¨í”„ í—¬í¼
    forEachAlly: function(unit, game, callback) {
        const team = unit.team === 0 ? game.pTeam : game.eTeam;
        team.forEach(u => { if(!u.isDead) callback(u); });
    },
    
    // ì  ì „ì²´ ë£¨í”„ í—¬í¼
    forEachEnemy: function(unit, game, callback) {
        const team = unit.team === 0 ? game.eTeam : game.pTeam;
        team.forEach(u => { if(!u.isDead) callback(u); });
    }
};

// ìŠ¤í‚¬ ë¡œì§ êµ¬í˜„ì²´ (Strategy)
const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // í™”ì—¼ë°©ì‚¬
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                // [Balance] 1.5 -> 1.6
                const act = Common.applyDamage(atk, def, 1.6, game, false, true);
                if(act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) def.addStatus('BURN', 2, 0, atk);
                // return true; ì œê±°ë¨ (ê¸°ë³¸ ì‚¬ìš´ë“œ ì¬ìƒ)
            } else { // ë©”í…Œì˜¤
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if(act!==-1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.25) e.addStatus('BURN', 2, 0, atk);
                });
                // return true; ì œê±°ë¨ (ê¸°ë³¸ ì‚¬ìš´ë“œ ì¬ìƒ)
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ë¬¼ëŒ€í¬
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else { // ì¹˜ìœ ì˜ ë¹„
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    // [Balance] 125 -> 120
                    let amt = 120;
                    if (game.netRandom() < 0.2) { amt += 50; UI.floatText(a, "Lucky!", "ft-crit"); }
                    const h = a.heal(amt);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
                return false; 
            }
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ê´‘í•©ì„±
                game.log(`<b>[${atk.name}]</b> ê´‘í•©ì„± ğŸŒ¿`);
                AudioSys.play('POWER_UP');
                atk.atk += 18; atk.shield += 30;
                atk.growthStack = (atk.growthStack || 0) + 1;
                atk.addStatus('GROWTH', 99);
                game.recordStat(atk, 'shield', 30);
                UI.floatText(atk, "ì„±ì¥", "ft-heal");
                Common.logAction(game, 'shield', atk, atk, 30, "(ì„±ì¥)");
                return false;
            } else { // ì¹˜ìœ ì˜ ì
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                const h = def.heal(150);
                def.cleanse();
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(ì •í™”)");
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ê°•ì² ë² ê¸°
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const absorb = Math.floor(act * 0.3);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else { // ê²°íˆ¬ ì‹ ì²­
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ì•”ì„íˆ¬ì²™
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸª¨`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if(game.netRandom()<0.25) def.addStatus('STUN', 1, 0, atk); 
                    else if(game.netRandom()<0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else { // ì§€ì§„
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u=>!u.isDead).length;
                const eAlive = game.eTeam.filter(u=>!u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, mult, game);
                    if(act!==-1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else { // ìˆ˜í˜¸ì˜ ë¹›
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 70; 
                    // [Balance] 1 stack: +15, 2+ stacks: +20 (Max)
                    const existing = a.status.find(s=>s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    
                    a.addStatus('LIGHT_MIGHT', 2, nextVal); 
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ë‹¤í¬ë³¼
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else { // ê³µí¬
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.3, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s=>s.type==='ATK_DOWN');
                        e.status = e.status.filter(s=>s.type!=='ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear?35:20, atk);
                        if(e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ê· í˜•íƒ€
                if (atk.hp > 30) {
                    atk.hp -= 30; UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
                    
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a,b) => a.hp - b.hp)[0];
                    if (target) { 
                        target.shield += 60; game.recordStat(atk, 'shield', 60); 
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else { // ì£¼ì‚¬ìœ„
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': { // í‘¸ë¥¸ë¶ˆ
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // í¡í˜ˆë¶€ì—¬
                game.log(`<b>[${atk.name}]</b> ì²­ì—¼ (í¡í˜ˆë¶€ì—¬)`);
                AudioSys.play('POWER_UP');
                Common.forEachAlly(atk, game, (a) => a.addStatus('LIFESTEAL_BUFF', 2));
                return false;
            } else { // í­ì£¼
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                Common.forEachAlly(atk, game, (a) => a.addStatus('ATK_BUFF_SMALL', 1));
                return false;
            }
        }
    },
    'Water-Light': { // ì¦ê¸°
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ìŠ¤íŒ€ì ¯
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if(act!==-1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if(game.netRandom()<0.3) { def.addStatus('BLIND', 1, 0, atk); game.log(" (ì‹¤ëª…!)"); }
                }
            } else { // ì•ˆê°œ
                if(!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ ğŸŒ«ï¸`);
                AudioSys.play('HEAL');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt); game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => { if(a.id !== atk.id) a.addStatus('EVADE', 2); });
                return false;
            }
        }
    },
    'Tree-Light': { // ìˆ²
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ìˆ²ì˜ë¶„ë…¸ (ëœë¤í)
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                const act = Common.applyDamage(atk, def, 1.2, game);
                if(act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const alive = allies.filter(a => !a.isDead);
                    if(alive.length>0) {
                        const t = alive[Math.floor(game.netRandom() * alive.length)];
                        const h = t.heal(20); game.recordStat(atk, 'heal', h); Common.logAction(game, 'heal', atk, t, h, "(ëœë¤í)");
                    }
                }
            } else { // ì¶•ë³µ
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.cleanse();
                    const h = a.heal(70); game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': { // ë…ê°€ìŠ¤
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ê°€ìŠ¤íƒ„
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT'];
                const hadBuff = def.status.some(s => buffs.includes(s.type));
                def.status = def.status.filter(s => !buffs.includes(s.type));
                if(hadBuff) UI.floatText(def, "í•´ì œ", "ft-miss");
                
                let reduced = false;
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) { def.s2Count--; def.atk -= 20; reduced = true; }
                if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) { def.elecStacks--; def.atk -= 10; reduced = true; }
                if (def.getKey() === 'Tree' && def.growthStack > 0) { def.growthStack--; def.atk -= 18; def.shield = Math.max(0, def.shield - 30); reduced = true; }
                if (reduced) { game.log(" (ğŸ“‰ìŠ¤íƒ ë‹¤ìš´)"); UI.floatText(def, "ìŠ¤íƒ-1", "ft-miss"); }

                const act = Common.applyDamage(atk, def, 0.3, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else { // ë§¹ë…ì‚´í¬
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => e.addStatus('POISON', 3, 0, atk));
            }
        }
    },
    'Earth-Light': { // ëª¨ë˜
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ëª¨ë˜í­í’
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game, true); 
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "(ì‰´ë“œë¬´ì‹œ)");
            } else { // ëª¨ë˜ì§€ì˜¥
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                const act = Common.applyDamage(atk, def, 0, game);
                if(act !== -1) { def.addStatus('TRAP', 2, 0, atk); def.addStatus('HEAL_DOWN', 2, 0, atk); }
            }
        }
    },
    'Water-Dark': { // ì–¼ìŒ
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
                if(act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': { // ê²€ì€ë¶ˆ
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // í‘ì—¼
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if(act!==-1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => e.addStatus('BURN', 2, 0, atk));
                }
            } else { // ì†Œê° (ì²´ë ¥ë¹„ë¡€)
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.0, game); 
                if(act !== -1) {
                    const extra = Math.floor(def.maxHp * 0.1);
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act+extra, "(ì²´ë ¥ë¹„ë¡€)");
                } else {
                     Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': { // ê°€ì‹œ
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ê°€ì‹œì°Œë¥´ê¸°
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else { // ì˜í˜¼ê²°ì†
                if(!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': { // ì „ê¸°
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) { // ì „ê¸°ì¶©ê²©
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if(atk.elecStacks < 3) {
                        atk.elecStacks++; atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit"); game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else { // ë°©ì „
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if(act!==-1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if(act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': { // ë°”ìœ„
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else { // ì‚°ì‚¬íƒœ (ë°˜ë™)
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                const act = Common.applyDamage(atk, def, 2.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
                // ë°˜ë™ ê¸°ì ˆ ë¡œì§
                if(atk.hasStatus('IMMUNITY')) { atk.status = atk.status.filter(s=>s.type!=='IMMUNITY'); UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss"); }
                const ex = atk.status.find(s=>s.type==='STUN'); if(ex) ex.turn=2; else atk.status.push({type:'STUN', turn:2, val:0});
                UI.floatText(atk, "ğŸ’¤íœ´ì‹", "ft-miss"); game.log("(ë°˜ë™:íœ´ì‹)");
            }
        }
    },
    'Light-Light': { // ë¹› ê°•í™”
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if(act!==-1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 50; a.cleanse(); game.recordStat(atk, 'shield', 50);
                    Common.logAction(game, 'shield', atk, a, 50, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Dark-Dark': { // ì–´ë‘  ê°•í™”
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if(act!==-1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë¸”ë™í™€ ğŸŒ€`);
                if (game.netRandom() < 0.75) {
                    def.addStatus('BANISH', 1, 0, atk);
                    atk.atk += 10; game.log(" (ì¶”ë°©!)");
                } else {
                    game.log(" (ì¶”ë°© ì‹¤íŒ¨)"); UI.floatText(def, "ì €í•­", "ft-miss");
                }
            }
        }
    }
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id; this.team = team; this.base = base; this.extra = extra;
        this.maxHp = 600; 
        if(base==='Tree' && extra==='Dark') this.maxHp = 700; 
        if(base==='Fire' && extra==='Light') this.maxHp = 650;
        this.hp = this.maxHp; 
        this.evadeTriggered = false; this.revengeAtk = 0; 
        this.shield = (base==='Metal' && !extra) ? 100 : 0;
        this.atk = 55 + (id * 7 % 15);
        this.status = []; this.isDead = false;
        this.thornStack = 0; this.linkedAllyId = -1;
        this.s2Count = 0; this.elecStacks = 0; this.growthStack = 0;
        this.resist = 0; this.stats = { dmg: 0, heal: 0, shieldGiven: 0, taken: 0 }; 
        this.passiveTriggered = false; this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base==='Light'&&this.extra==='Dark') || (this.base==='Dark'&&this.extra==='Light');
        this.isEnhanced = (this.base===this.extra && (this.base==='Light'||this.base==='Dark'));
        
        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() { if(this.isNormal) return 'Normal'; if(this.isEnhanced) return `${this.base}-${this.extra}`; return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base; }
    
    getAtk() { 
        let v = this.atk; 
        if (this.base === 'Fire' && !this.extra) { const turn = Game.turnCount; if (turn <= 12) v += 20; else if (turn <= 36) v += 10; }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        
        // [Balance] Light buff: 1 stack = +15, 2+ stacks = +20 (Fixed)
        const lightMight = this.status.find(s=>s.type==='LIGHT_MIGHT');
        if(lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        
        if(this.hasStatus('ATK_BUFF_SMALL')) v += 10;
        v = Math.max(10, v);
        const ads = this.status.filter(s=>s.type==='ATK_DOWN'); 
        if(ads.length > 0) { ads.forEach(s => { if (s.val > 0) v -= Math.floor(v * (s.val / 100)); else v -= 15; }); }
        return Math.max(0, v); 
    }
    
    resetTurn() { this.passiveTriggered = false; this.metalPassiveUsed = false; }

    takeDamage(dmg, isFire=false, ignoreShield=false, source=null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);
        
        // [Fix] Metal passive applies per hit, not once per turn
        if (this.base === 'Metal' && !this.extra && this.shield > 0) { 
            const cap = Math.floor(this.maxHp * 0.30); 
            if (dmg > cap) { dmg = cap; UI.floatText(this, "Iron Will", "ft-heal"); } 
        }
        
        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) { if(Game.netRandom() < 0.40) { UI.floatText(this, "íšŒí”¼!", "ft-miss"); this.status = this.status.filter(s => s.type !== 'EVADE'); return -1; } }
        if (source && source.id !== this.id && !source.isDead) { const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`); const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark'); if (karma && !isDarkVsDark) { const reflectDmg = Math.floor(dmg * 0.3); if (reflectDmg > 0) { const actualReflect = source.takeDamage(reflectDmg, false, true, null); this.stats.dmg += actualReflect; UI.floatText(source, reflectDmg, "ft-crit"); } } }
        
        this.stats.taken += dmg;
        let hpDmg = 0; let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) { if(this.shield >= dmg) { shieldDmg = dmg; this.shield -= dmg; hpDmg = 0; } else { shieldDmg = this.shield; hpDmg = dmg - this.shield; this.shield = 0; } } else { hpDmg = dmg; }
        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) { hpDmg += 10; this.stats.taken += 10; UI.floatText(this, "Crack!", "ft-crit"); }
        this.hp = Math.max(0, this.hp - hpDmg);
        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) { const healAmt = Math.floor(this.maxHp * 0.1); this.hp += healAmt; this.addStatus('EVADE', 2); this.evadeTriggered = true; UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal"); }
        return hpDmg + shieldDmg; 
    }

    addStatus(type, turn, val=0, source=null, force=false) {
        if (source && source.id !== this.id && !force) { const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`); if (karma) { if (Game.netRandom() < 0.5) { UI.floatText(this, "ë°˜ì‚¬!", "ft-crit"); source.addStatus(type, turn, val, null); return; } } }
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE']; if (this.isNormal && !force) { if (NORMAL_IMMUNE.includes(type) || type.startsWith('PROVOKED')) { UI.floatText(this, "Immune", "ft-miss"); return; } }
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) { if (source && source.id !== this.id) { if (Game.netRandom() < 0.40) { UI.floatText(this, "íšŒí”¼!", "ft-miss"); this.status = this.status.filter(s => s.type !== 'EVADE'); return; } } }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH']; if (HARD_CC.includes(type)) { if (this.hasStatus('IMMUNITY') && !force) { UI.floatText(this, "ë©´ì—­", "ft-miss"); return; } if (!source || source.id !== this.id || force) { this.status.push({type: 'IMMUNITY', turn: turn + 1}); } }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        if (type === 'ATK_DOWN') { const s = this.status.filter(s=>s.type==='ATK_DOWN'); if(s.length < 2) { this.status.push({type, turn, val}); } else { const shortest = s.sort((a,b) => a.turn - b.turn)[0]; shortest.turn = turn; } return; }
        
        // [Fix] Update val if provided (for stacking buffs like LIGHT_MIGHT)
        const idx = this.status.findIndex(s=>s.type===type); 
        if(idx >= 0) {
            this.status[idx].turn = turn; 
            if(val !== 0) this.status[idx].val = val; 
        } else {
            this.status.push({type, turn, val});
        }
    }
    hasStatus(type) { return this.status.some(s=>s.type===type); }
    cleanse() { const bad = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN','KARMA_VICTIM']; this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM')); }
    dispel() { const buffs = ['EVADE','DMG_RED','ATK_BUFF','GROWTH','LIGHT_MIGHT']; const has=this.status.some(s=>buffs.includes(s.type)); this.status=this.status.filter(s=>!buffs.includes(s.type)); return has; }
    
    tickStatus() { 
        let log = []; 
        if(this.hasStatus('POISON')) { const d=this.takeDamage(35, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`); } 
        if(this.hasStatus('BURN')) { const d=this.takeDamage(20, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`); } 
        if(this.hasStatus('TRAP')) { const d=this.takeDamage(40, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`); } 
        return log; 
    }
    decayStatus() { this.status.forEach(s => s.turn--); this.status = this.status.filter(s => s.turn > 0); }
    heal(amount) { if(this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4); const prev=this.hp; this.hp=Math.min(this.maxHp, this.hp+amount); const diff=this.hp-prev; if(diff>0) { UI.floatText(this, diff, 'ft-heal'); } return diff; }
}

const AudioSys = { ctx: null, isMuted: false, init: function() { if(this.ctx) return; try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} }, resume: function() { if(this.ctx&&this.ctx.state==='suspended') this.ctx.resume(); }, toggleMute: function() { this.isMuted = !this.isMuted; const btn = document.getElementById('btn-mute'); if(this.isMuted) { btn.innerHTML = 'ğŸ”‡'; btn.classList.add('muted'); } else { btn.innerHTML = 'ğŸ”Š'; btn.classList.remove('muted'); } }, playSoft: function(freq, type, dur, vol=0.3) { if(!this.ctx || this.isMuted) return; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const t=this.ctx.currentTime; o.type=type; o.frequency.setValueAtTime(freq,t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur); o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.1); }, play: function(type) { if(!this.ctx || this.isMuted) return; if(type==='HIT') { const rndFreq = 600 + (Math.random() * 100 - 50); this.playSoft(rndFreq,'triangle',0.1,0.4); } else if(type==='SKILL') { this.playSoft(500,'sine',0.15,0.3); setTimeout(()=>this.playSoft(800,'sine',0.2,0.3),100); } else if(type==='HEAL') { this.playSoft(500,'sine',0.2,0.3); setTimeout(()=>this.playSoft(700,'sine',0.3,0.3),150); } else if(type==='DEBUFF') { this.playSoft(300,'triangle',0.2,0.35); setTimeout(()=>this.playSoft(200,'triangle',0.2,0.35), 150); } else if(type==='MISS') this.playSoft(900,'square',0.05,0.2); else if(type==='WIN') { setTimeout(()=>this.playSoft(523,'sine',0.2,0.5),0); setTimeout(()=>this.playSoft(659,'sine',0.2,0.5),200); setTimeout(()=>this.playSoft(784,'sine',0.4,0.5),400); } else if(type==='POWER_UP') { this.playSoft(440,'sine',0.2,0.35); setTimeout(()=>this.playSoft(554,'sine',0.2,0.35), 100); setTimeout(()=>this.playSoft(659,'sine',0.3,0.35), 200); } else if(type==='CRITICAL') { this.playSoft(150,'triangle',0.1,0.6); setTimeout(()=>this.playSoft(880,'sine',0.3,0.7), 50); } } };
const UI = { showModal: function(title, content) { document.getElementById('modal-overlay').style.display = 'flex'; document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`; }, closeModal: function() { document.getElementById('modal-overlay').style.display = 'none'; }, showGuide: function() { let heroList = ''; const guideOrder = [ 'Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark' ]; guideOrder.forEach(k => { const s = SKILL_DB[k]; let name = ''; if(k === 'Normal') name = NAME_MAP['Normal']; else { const parts = k.split('-'); if(parts.length===2) name = NAME_MAP[k] || k; else name = `${ATTR[k].n}(ê¸°ì´ˆ)`; } const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0]; let icon = s.icon; let bg = `bg-${base}`; if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`; if (k === 'Normal') bg = 'bg-Normal'; heroList += `<div class="guide-item"> <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> <div class="guide-info"> <div class="guide-name">${name}</div> <div class="guide-desc">${s.desc}</div> <div style="font-size:10px; color:#555; margin-top:2px;"> <div>S1: ${s.s1} (${s.s1d})</div> <div>S2: ${s.s2} (${s.s2d})</div> </div> </div> </div>`; }); const content = `<div class="tab-header"> <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button> <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button> </div> <div id="tab-0" class="tab-content active"> <table class="chart-table"> <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr> <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr> <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr> <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr> <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr> <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr> <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr> <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr> </table> <div class="dual-chart"> <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div> <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div> </div> </div> <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;"> ${heroList} </div>`; this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content); }, switchTab: function(idx) { document.querySelectorAll('.tab-btn').forEach((b, i) => { if(i===idx) b.classList.add('active'); else b.classList.remove('active'); }); document.querySelectorAll('.tab-content').forEach((c, i) => { if(i===idx) c.classList.add('active'); else c.classList.remove('active'); }); }, floatText: function(unit, text, type) { const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`; const unitEl = document.getElementById(id); if(!unitEl) return; const el = document.createElement('div'); el.className = `float-text ${type}`; el.innerText = type === 'ft-heal' ? `+${text}` : text; const rect = unitEl.getBoundingClientRect(); const randomX = (Math.random() - 0.5) * 40; const randomY = (Math.random() - 0.5) * 20; el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px'; el.style.top = (rect.top + window.scrollY + randomY) + 'px'; document.body.appendChild(el); setTimeout(() => el.remove(), 800); }, flash: function() { const f = document.getElementById('flash-overlay'); f.style.opacity = 0.6; setTimeout(() => f.style.opacity = 0, 100); }, screenShake: function() { document.body.classList.remove('screen-shake'); void document.body.offsetWidth; document.body.classList.add('screen-shake'); }, showTurnBanner: function(isPlayerTurn) { const banner = document.getElementById('turn-banner'); if (isPlayerTurn) { banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)'; banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)"; } else { banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)'; banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)"; } banner.style.animation = 'none'; void banner.offsetWidth; const duration = Game.turnCount > 5 ? '0.6s' : '1.2s'; banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`; }, showResult: function(winnerTeamStr) { const allUnits = [...Game.pTeam, ...Game.eTeam]; const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1); const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1); let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`; html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`; const mvp = allUnits.sort((a,b)=>(b.stats.dmg+b.stats.heal+b.stats.shieldGiven)-(a.stats.dmg+a.stats.heal+a.stats.shieldGiven))[0]; const renderBar = (u) => { const dmgPct = (u.stats.dmg / maxDmg) * 100; const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100; const isMVP = u.id === mvp.id; return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`; }; html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`; Game.pTeam.forEach(u => html += renderBar(u)); html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`; Game.eTeam.forEach(u => html += renderBar(u)); html += `</div>`; document.getElementById('modal-overlay').style.display = 'flex'; document.getElementById('modal-body').innerHTML = html; }, checkMode: function() { Game.checkMode(); } };

const Game = {
    pool: [], selected: [], pTeam: [], eTeam: [], queue: [], curr: 0, selectedSkillIdx: -1, timer: null, turnCount: 1, difficulty: 'normal', watchdog: null, isOver: false, mode: 'pve', isProcessing: false, challengeStage: 0,
    netRandom: function() { return getNetRandom(); },

    init: function() {
        if(this.timer) clearTimeout(this.timer); if(this.watchdog) clearTimeout(this.watchdog); this.isOver = false;
        this.pool = []; this.selected = [];
        const allCombos = [ {b:'Metal', e:null}, {b:'Tree', e:null}, {b:'Fire', e:'Light'}, {b:'Water', e:'Light'}, {b:'Fire', e:null}, {b:'Normal', e:null}, {b:'Fire', e:'Dark'}, {b:'Metal', e:'Dark'}, {b:'Earth', e:'Dark'}, {b:'Earth', e:null}, {b:'Water', e:'Dark'}, {b:'Metal', e:'Light'}, {b:'Earth', e:'Light'}, {b:'Tree', e:'Dark'}, {b:'Water', e:null}, {b:'Tree', e:'Light'}, {b:'Light', e:null}, {b:'Light', e:'Light'}, {b:'Dark', e:null}, {b:'Dark', e:'Dark'} ];
        allCombos.forEach((c, i) => { const u = new Unit(i, 0, c.b, c.e); this.pool.push(u); });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)"; document.getElementById('btn-start').disabled = true;
        const btnOnline = document.getElementById('btn-online'); if(btnOnline) { btnOnline.disabled = false; btnOnline.innerText = "ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë§¤ì¹­ ì‹œì‘)"; btnOnline.style.backgroundColor = '#7e57c2'; }
        this.checkMode(); 
    },
    renderHeroSelection: function() { const grid = document.getElementById('hero-grid'); grid.innerHTML = ''; grid.style.display = 'block'; grid.style.overflowY = 'auto'; const categories = [ { name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)", range: [0, 3], color: "#e3f2fd", border: "#90caf9" }, { name: "âš”ï¸ ë”œëŸ¬ (Dealer)", range: [4, 13], color: "#ffebee", border: "#ef9a9a" }, { name: "ğŸ§© ì§€ì› (Support)", range: [14, 19], color: "#f1f8e9", border: "#a5d6a7" } ]; categories.forEach(cat => { const header = document.createElement('div'); header.style.cssText = `width:100%; padding:8px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:10px; border-radius:5px; color:#455a64; text-align:left; box-sizing:border-box;`; header.innerText = cat.name; grid.appendChild(header); const container = document.createElement('div'); container.style.cssText = "display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; padding:10px 0;"; for(let i = cat.range[0]; i <= cat.range[1]; i++) { const u = this.pool[i]; const el = document.createElement('div'); el.className = 'hero-card'; el.id = `card-${i}`; el.innerHTML = this.renderCard(u); el.onclick = () => { this.toggle(i, el); }; container.appendChild(el); } grid.appendChild(container); }); },
    renderCard: function(u) { let bgClass = `bg-${u.base}`; if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`; if(u.isNormal) bgClass = 'bg-Normal'; const info = SKILL_DB[u.getKey()]; const icon = info.icon || ''; return `<div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div><div style="font-weight:bold; margin-bottom:2px; font-size:15px;">${u.name.split(' ')[0]}</div><div style="font-size:11px; color:#999;">${u.name}</div><div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">${info.desc}</div>`; },
    toggle: function(i, el) { if (!el) el = document.getElementById(`card-${i}`); if(this.selected.includes(i)) { this.selected = this.selected.filter(x=>x!==i); el.classList.remove('selected'); } else { if(this.selected.length >= 3) { el.classList.add('shake'); setTimeout(()=>el.classList.remove('shake'), 500); return; } this.selected.push(i); el.classList.add('selected'); } const count = this.selected.length; const btn = document.getElementById('btn-start'); btn.innerText = `ì „íˆ¬ ì‹œì‘ (${count}/3)`; btn.disabled = count !== 3; },
    randomPick: function() { Game.selected.forEach(i => { const el = document.querySelectorAll('.hero-card')[i]; if(el) el.classList.remove('selected'); }); Game.selected = []; while(Game.selected.length < 3) { const r = Math.floor(Math.random() * 20); if(!Game.selected.includes(r)) { Game.selected.push(r); const el = document.querySelectorAll('.hero-card')[r]; if(el) el.classList.add('selected'); } } const btn = document.getElementById('btn-start'); btn.innerText = `ì „íˆ¬ ì‹œì‘ (3/3)`; btn.disabled = false; },
    checkMode: function() { const diff = document.getElementById('diff-select').value; const statusEl = document.getElementById('challenge-status'); if (diff === 'hell') { statusEl.style.display = 'block'; const savedStage = localStorage.getItem('et_challenge_stage'); let maxStage = savedStage ? parseInt(savedStage) : 0; if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1; if(this.challengeStage > maxStage) this.challengeStage = maxStage; const select = document.getElementById('stage-select'); select.innerHTML = ''; ChallengeDB.forEach((st, i) => { if (i <= maxStage) { const opt = document.createElement('option'); opt.value = i; opt.text = `${i+1}. ${st.name}`; if (i === this.challengeStage) opt.selected = true; select.appendChild(opt); } }); this.updateStageInfo(); } else { statusEl.style.display = 'none'; } },
    selectStage: function() { const select = document.getElementById('stage-select'); this.challengeStage = parseInt(select.value); this.updateStageInfo(); },
    updateStageInfo: function() { const stage = ChallengeDB[this.challengeStage]; if (stage) { document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`; } },

    start: function() {
        AudioSys.init(); AudioSys.resume();
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => { const u = this.pool[idx]; u.id=i; u.team=0; return u; });
        this.eTeam = []; this.isOver = false;
        const makeEnemy = (idx, b, e) => { const u = new Unit(idx + 3, 1, b, e); return u; };

        if (this.difficulty === 'hell') { 
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            const stageData = ChallengeDB[this.challengeStage];
            this.eTeam = stageData.team.map((key, i) => { let b, e; if(key === 'Normal') { b='Normal'; e=null; } else if(key.includes('-')) { [b, e] = key.split('-'); } else { b=key; e=null; } return makeEnemy(i, b, e); });
        } else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => { const u = new Unit(i + 3, 1, pu.base, pu.extra); u.maxHp = Math.floor(u.maxHp * 1.15); u.hp = u.maxHp; u.atk = Math.floor(u.atk * 1.15); return u; });
        } else if (this.difficulty === 'easy') {
            const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
            while(this.eTeam.length < 3) { const b = basics[Math.floor(Math.random() * basics.length)]; if (!this.eTeam.some(u => u.base === b)) { this.eTeam.push(makeEnemy(this.eTeam.length, b, null)); } }
        } else if (this.difficulty === 'hard') {
            let bestIdx = Math.floor(Math.random() * ChallengeDB.length); let maxScore = -999;
            ChallengeDB.forEach((stage, idx) => { let score = 0; stage.team.forEach(key => { let b, e, isN = false, isEnh = false; if(key==='Normal') { b='Normal'; isN=true; } else { const parts = key.split('-'); b = parts[0]; e = parts[1] || null; if(b===e) isEnh=true; } const dumE = { base:b, extra:e, isNormal:isN, isEnhanced:isEnh }; this.pTeam.forEach(p => { const atkRel = this.calc(dumE, p); if(atkRel.v > 1.0) score += 3; const defRel = this.calc(p, dumE); if(defRel.v < 1.0) score += 2; }); }); score += Math.random(); if(score > maxScore) { maxScore = score; bestIdx = idx; } });
            const targetDeck = ChallengeDB[bestIdx].team;
            this.eTeam = targetDeck.map((key, i) => { let b, e; if(key === 'Normal') { b='Normal'; e=null; } else if(key.includes('-')) { [b, e] = key.split('-'); } else { b=key; e=null; } return makeEnemy(i, b, e); });
            this.log(`<span class='log-sys'>ğŸ”¥ ì–´ë ¤ì›€(Counter): ì ì´ ë‹¹ì‹ ì˜ ì•½ì ì„ ê°„íŒŒí–ˆìŠµë‹ˆë‹¤! (${ChallengeDB[bestIdx].name})</span>`);
        } else {
            const used = new Set(); while(this.eTeam.length<3) { const b = ['Fire','Water','Tree','Metal','Earth','Light','Dark'][Math.floor(Math.random()*7)]; const e = [null,'Light','Dark'][Math.floor(Math.random()*3)]; if(b==='Dark'&&e==='Light') continue; let key = `${b}-${e}`; if(b==='Light'&&e==='Dark') key = 'Normal'; if(!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); } }
        }

        this.queue = [0,1,2,3,4,5]; this.curr = Math.floor(Math.random()*6);
        this.turnCount = 1; this.isProcessing = false; 
        document.getElementById('selection-screen').style.display='none'; document.getElementById('battle-screen').style.display='flex'; document.getElementById('logs').innerHTML = ''; 
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);
        this.render(); this.timer = setTimeout(()=>this.turn(), 1000);
    },

    turn: function() {
        this.isProcessing = false; if (this.isOver) return;
        const round = Math.ceil(this.turnCount / 6);
        const tVal = this.queue[this.curr];
        const u = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        const isMyTurn = (u.team === 0);

        if(this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') { this.watchdog = setTimeout(() => { console.log("AI Stuck. Forcing next."); this.endTurn(); }, 3000); }
        if(this.endCheck()) return;

        if(!u.isDead) u.resetTurn();
        if(u.isDead) { this.endTurn(true); return; }
        
        UI.showTurnBanner(isMyTurn);
        if(u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) { UI.floatText(u, "SKIP", "ft-miss"); this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`); setTimeout(() => this.endTurn(), 800); return; }
        const tickLogs = u.tickStatus(); tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if(u.hp<=0) { this.die(u); this.endTurn(); return; }

        let turnName = u.name.split(' ')[0]; if (this.mode === 'pvp') turnName += (u.team === 0 ? " (ë‚˜)" : " (ì )");
        document.getElementById('turn-indicator').innerText = `Round ${round} : ${turnName}`;
        this.turnCount++;
        if(isMyTurn || this.difficulty === 'local') { this.input(u); } else { this.noInput(); if (this.mode === 'pvp') document.getElementById('turn-indicator').innerText = `ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...`; else this.timer=setTimeout(()=>this.ai(u), 800); }
    },
    
    render: function() {
        const tl = document.getElementById('tl-track'); tl.innerHTML = '';
        for(let i=0; i<6; i++) { const idx = (this.curr + i) % 6; const qId = this.queue[idx]; const isP = qId % 2 === 0; const uIdx = isP ? qId/2 : (qId-1)/2; const team = isP ? this.pTeam : this.eTeam; const u = team[uIdx]; const n = document.createElement('div'); n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`; if(u.isDead) n.style.opacity = 0.3; n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i; tl.appendChild(n); }
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId); const currentIds = team.map(u => u.id); Array.from(row.children).forEach(c => { if(!currentIds.includes(parseInt(c.dataset.uid))) c.remove(); });
            team.forEach((u) => {
                const cardId = tid===0 ? `p-card-${u.id}` : `e-card-${u.id}`; let d = document.getElementById(cardId); if (!d) { d = document.createElement('div'); d.id = cardId; d.dataset.uid = u.id; row.appendChild(d); }
                let isActive = false; if (tid === 0) isActive = this.queue[this.curr] === u.id * 2; else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;
                let tags = u.status.map(s => { let c='tag'; const map = { 'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn', 'BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown', 'BLIND':'blind','IMMUNITY':'immunity','HEAL_DOWN':'healdown', 'LIGHT_MIGHT':'atkup', 'LIFESTEAL_BUFF':'lifesteal', 'ATK_BUFF_SMALL':'atkup_s' }; if(s.type.includes('PROVOKED')) c+=' taunt'; else if(s.type.startsWith('KARMA_VICTIM')) c+=' karma'; else if(map[s.type]) c+=` ${map[s.type]}`; let txt = s.type; const tMap = { 'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ', 'TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…', 'IMMUNITY':'ë©´ì—­','HEAL_DOWN':'ì¹˜ìœ â†“','LIGHT_MIGHT':'ê³µê²©â†‘', 'LIFESTEAL_BUFF':'ğŸ©¸í¡í˜ˆ', 'ATK_BUFF_SMALL':'ğŸ”¥ê³µê²©â†‘' }; if(s.type.includes('PROVOKED')) txt='ë„ë°œ'; else if(s.type.startsWith('KARMA_VICTIM')) txt='ğŸ‘ï¸ì—…ë³´'; else if(tMap[s.type]) txt = tMap[s.type]; return `<span class="${c}">${txt}(${s.turn})</span>`; }).join('');
                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;
                let bgClass = `bg-${u.base}`; if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`; if(u.isNormal) bgClass = 'bg-Normal'; const icon = SKILL_DB[u.getKey()].icon || ''; let extraBadge = ''; if(u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;
                const innerHTML = ` ${extraBadge} <div class="tag-container">${tags}</div> <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div> <div class="unit-name" style="font-size:15px; margin-bottom:3px;">${u.name.split(' ')[0]} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div> <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div> <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div> `;
                if(d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0); draw('enemy-row', this.eTeam, 1);
    },
    
    endTurn: function(isFast = false) {
        if(this.isOver) return; if(this.watchdog) clearTimeout(this.watchdog);
        const u = this.queue[this.curr]%2===0 ? this.pTeam[this.queue[this.curr]/2] : this.eTeam[(this.queue[this.curr]-1)/2];
        if(u && !u.isDead) u.decayStatus();
        [...this.pTeam, ...this.eTeam].forEach(u=>{if(u.hp<=0) this.die(u)});
        this.curr = (this.curr+1)%6;
        if (this.curr === 0) { const round = Math.ceil(this.turnCount / 6); if (round > 20) { [...this.pTeam, ...this.eTeam].forEach(u => { if(!u.isDead) u.atk += 10; }); this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>"); } }
        this.render(); const delay = isFast ? 100 : 1500; this.timer = setTimeout(()=>this.turn(), delay);
    },

    // [Refactored Execute Function]
    execute: function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el=>el.onclick=null);
        if (isOnlineMode && !isRemote) { 
            if (atk.team !== 0) { alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!"); return; } 
            
            // [ìˆ˜ì •] ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” (ì´ë²ˆ í„´ì˜ ìƒˆë¡œìš´ ë‚œìˆ˜ë¥¼ ë‹´ê¸° ìœ„í•´)
            netRndBuffer = []; 
        }
        
        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];
        
        if (!logic) { console.error(`Logic missing for ${key}`); return; }
        
        // Execute the strategy
        const playedSound = logic.useSkill(atk, def, sIdx, this);
        
        if (!playedSound) AudioSys.play('SKILL');
        
        if (isOnlineMode && !isRemote) { socket.emit('action', { room: myRoom, attackerId: atk.id, attackerTeam: atk.team, targetId: def ? def.id : null, targetTeam: def ? def.team : null, skillIdx: sIdx, rndBuffer: netRndBuffer }); }
        this.endTurn();
    },

    reset: function() {
        if(this.timer) clearTimeout(this.timer); if(this.watchdog) clearTimeout(this.watchdog); UI.closeModal();
        document.getElementById('battle-screen').style.display='none'; document.getElementById('selection-screen').style.display='flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected')); this.selected = [];
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)"; document.getElementById('btn-start').disabled = true;
        this.init(); 
    },
    recordStat: function(unit, type, amount) { if(!unit || amount <= 0) return; if(type === 'dmg') unit.stats.dmg += amount; if(type === 'shield') unit.stats.shieldGiven += amount; if(type === 'heal') unit.stats.heal += amount; },
    input: function(u) {
        const k = u.getKey(); const s = SKILL_DB[k];
        if (!s) { console.error("Skill info missing for:", k); return; }
        const silenced = u.hasStatus('SILENCE');
        document.getElementById('p-icon').innerText = s.icon; document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
        document.getElementById('sk-1').innerHTML = `<span class="skill-name">${s.s1}</span><br><span class="skill-desc">${s.s1d}</span>`; document.getElementById('sk-2').innerHTML = `<span class="skill-name">${s.s2}</span><br><span class="skill-desc">${s.s2d}</span>`;
        document.getElementById('sk-0').disabled = false; document.getElementById('sk-1').disabled = silenced;
        let s2Limit = false; if (k === 'Fire-Light' && u.s2Count >= 5) s2Limit = true;
        let sk2Disable = silenced || s2Limit;
        if (k === 'Tree-Dark') { const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam; const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id); if (aliveAllies.length === 0 || u.linkedAllyId !== -1) sk2Disable = true; }
        document.getElementById('sk-2').disabled = sk2Disable;
        if(silenced) this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
        const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
        if(provoked) {
            const targetId = parseInt(provoked.type.split('_')[2]); const enemies = u.team === 0 ? this.eTeam : this.pTeam; const allies = u.team === 0 ? this.pTeam : this.eTeam; const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
            if(!target || target.isDead) { u.status = u.status.filter(s => !s.type.startsWith('PROVOKED')); this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`); UI.floatText(u, "ììœ !", "ft-heal"); this.render(); } else { this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`); this.noInput(); setTimeout(() => this.execute(u, target, 0), 1000); return; }
        }
        this.selectedSkillIdx = -1;
    },
    noInput: function() { [0,1,2].forEach(i=>{ const b = document.getElementById(`sk-${i}`); b.disabled=true; b.classList.remove('selected'); }); },
    prepareSkill: function(idx) {
        [0,1,2].forEach(i => { const b = document.getElementById(`sk-${i}`); if(i===idx) b.classList.add('selected'); else b.classList.remove('selected'); }); 
        this.selectedSkillIdx = idx;
        const tVal = this.queue[this.curr]; 
        const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        const k = u.getKey(); 
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';
        
        if (idx === 0) { targetType = 'ENEMY'; } 
        else if (idx === 1) { 
            if (['Tree'].includes(k)) targetType = 'SELF'; 
            else if (['Tree-Dark', 'Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; 
            // [Fix] ì²­ì—¼ S1ì„ ANY_ALLYë¡œ ì„¤ì •í•˜ì—¬ ì•„ë¬´ ì•„êµ°ì´ë‚˜ ëˆŒëŸ¬ë„ ë°œë™ë˜ê²Œ ë³€ê²½ (ê¸°ì¡´ SELFëŠ” ë³¸ì¸ë§Œ ëˆŒëŸ¬ì•¼ í•´ì„œ UX í˜¼ë€)
            else if (['Fire-Light'].includes(k)) targetType = 'ANY_ALLY'; 
            else targetType = 'ENEMY'; 
        } 
        else if (idx === 2) { targetType = s.target; }
        
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
        if (!actingUnit) { const tVal = this.queue[this.curr]; actingUnit = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2]; }
        document.querySelectorAll('.unit').forEach(el => { el.classList.remove('target-enemy', 'target-ally', 'target-aoe'); el.onclick = null; });
        
        const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType); 
        // ANY_ALLY ì¶”ê°€: ì•„êµ° ì „ì²´ ëŒ€ìƒì´ì§€ë§Œ í´ë¦­ íŠ¸ë¦¬ê±°ê°€ í•„ìš”í•œ ê²½ìš°
        const isAllyTarget = ['ALLY','ALL_ALLY','SELF','SELF_BUFF', 'ANY_ALLY'].includes(targetType);
        
        const myTeam = actingUnit.team === 0 ? this.pTeam : this.eTeam; 
        const oppTeam = actingUnit.team === 0 ? this.eTeam : this.pTeam;
        const targets = isAllyTarget ? myTeam : oppTeam;
        
        let targetClass = isAllyTarget ? 'target-ally' : 'target-enemy'; 
        if (isAOE && !isAllyTarget) targetClass = 'target-aoe'; 
        
        targets.forEach((t) => { 
            if(!t.isDead) { 
                // Tree-Dark ì˜ˆì™¸ì²˜ë¦¬ ìœ ì§€
                if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2 && t.id === actingUnit.id) return; 
                
                const el = document.getElementById(t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`); 
                el.classList.add(targetClass); 
                
                el.onclick = () => { 
                    if (Game.isProcessing) return; 
                    Game.isProcessing = true; 
                    
                    // SELFì¼ ê²½ìš° ë³¸ì¸ì´ ì•„ë‹ˆë©´ ë¦¬í„´
                    if(targetType === 'SELF' && t.id !== actingUnit.id) return; 
                    
                    this.noInput(); 
                    document.querySelectorAll('.unit').forEach(el => el.classList.remove('target-enemy', 'target-ally', 'target-aoe')); 
                    this.execute(actingUnit, t, this.selectedSkillIdx); 
                }; 
            } 
        });
    },

    ai: function(u) {
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;
        try {
            const silenced = u.hasStatus('SILENCE'); const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if(provoked) { const targetId = parseInt(provoked.type.split('_')[2]); const target = this.pTeam.find(p => p.id === targetId) || this.eTeam.find(e => e.id === targetId); if(!target || target.isDead) { u.status = u.status.filter(s => !s.type.startsWith('PROVOKED')); this.render(); } else { this.execute(u, target, 0); return; } }
            const enemies = u.team === 0 ? this.eTeam : this.pTeam; const aliveEnemies = enemies.filter(e => !e.isDead); if (aliveEnemies.length === 0) { this.endTurn(); return; }
            let skillIdx = 0; const rnd = this.netRandom(); if (!silenced) { if (rnd > 0.7) skillIdx = 2; else if (rnd > 0.4) skillIdx = 1; }
            const k = u.getKey(); const s = SKILL_DB[k]; let potentialTargets = aliveEnemies;
            if (skillIdx === 2) { const isAllySkill = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF'].includes(s.target) || ['HEAL', 'BUFF', 'TARGET_BUFF'].includes(s.type); if (isAllySkill) { const allies = u.team === 0 ? this.pTeam : this.eTeam; potentialTargets = allies.filter(a => !a.isDead); if (s.type === 'HEAL' || k === 'Water') { potentialTargets.sort((a,b) => (a.hp/a.maxHp) - (b.hp/b.maxHp)); if(potentialTargets.length > 0) potentialTargets = [potentialTargets[0]]; } } }
            if (skillIdx === 1) { if (['Tree', 'Fire-Light'].includes(k)) potentialTargets = [u]; }
            let target = potentialTargets[Math.floor(this.netRandom() * potentialTargets.length)];
            
            // [Fix] AI Safety: If no target found, skip turn instead of crashing
            if (!target) { 
                if (skillIdx !== 0) { // Fallback to basic attack
                    skillIdx = 0; 
                    target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
                }
                if (!target) {
                    this.log("AI: íƒ€ê²Ÿ ì—†ìŒ, í„´ ì¢…ë£Œ"); 
                    this.endTurn(); 
                    return; 
                }
            }
            this.execute(u, target, skillIdx);
        } catch (e) { console.error(e); this.endTurn(); }
    },

    die: function(u) { 
        if(u.isDead) return; u.isDead=true; u.hp=0; u.status=[]; Game.log(`${u.name} íƒˆë½`); 
        if (u.base === 'Tree' && u.extra === 'Dark') { Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`); const enemies = u.team===0 ? Game.eTeam : Game.pTeam; enemies.forEach(e => { if(!e.isDead) e.addStatus('POISON', 1, 0, u); }); }
        const allies = u.team===0 ? Game.pTeam : Game.eTeam; const thorns = allies.filter(a => a.base==='Tree' && a.extra==='Dark' && !a.isDead && a.linkedAllyId === u.id); thorns.forEach(thorn => { thorn.revengeAtk += 20; thorn.thornStack += 0.3; thorn.linkedAllyId = -1; Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`); UI.floatText(thorn, "RAGE!", "ft-crit"); });
    },
    endCheck: function() { 
        const pd=this.pTeam.every(u=>u.isDead);
        const ed=this.eTeam.every(u=>u.isDead); 
        
        if(pd||ed) { 
            this.isOver = true; 
            if(this.timer) clearTimeout(this.timer); 
            AudioSys.play('WIN'); 
            
            // [Fix] Draw condition added
            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) { 
                this.challengeStage++; 
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`; 
                if(this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!"; 
                localStorage.setItem('et_challenge_stage', this.challengeStage); 
                UI.showResult(msg); 
            } else { 
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)"); 
            } 
            localStorage.removeItem('et_save_v6'); 
            return true; 
        } 
        return false; 
    },
    log: function(m) { const b=document.getElementById('logs'); const d=document.createElement('div'); d.className='log-entry'; d.innerHTML=m; b.appendChild(d); b.scrollTop = b.scrollHeight; },
    shake: function(u) { const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`; const el = document.getElementById(id); if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); } },
    saveGame: function() { if (this.isOver) { alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; } const saveData = { pTeam: this.pTeam.map(u => this.serializeUnit(u)), eTeam: this.eTeam.map(u => this.serializeUnit(u)), queue: this.queue, curr: this.curr, turnCount: this.turnCount, difficulty: this.difficulty, mode: this.mode, selected: this.selected }; localStorage.setItem('et_save_v6', JSON.stringify(saveData)); UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal"); this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>"); },
    loadGame: function() { const json = localStorage.getItem('et_save_v6'); const savedStage = localStorage.getItem('et_challenge_stage'); if(savedStage) this.challengeStage = parseInt(savedStage); if (!json) { alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`); return; } try { const data = JSON.parse(json); this.difficulty = data.difficulty; this.mode = data.mode; this.turnCount = data.turnCount; this.curr = data.curr; this.queue = data.queue; this.selected = data.selected; this.pTeam = data.pTeam.map(d => this.deserializeUnit(d)); this.eTeam = data.eTeam.map(d => this.deserializeUnit(d)); document.getElementById('selection-screen').style.display = 'none'; document.getElementById('battle-screen').style.display = 'flex'; document.getElementById('logs').innerHTML = ''; this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>"); this.render(); if (this.timer) clearTimeout(this.timer); const tVal = this.queue[this.curr]; const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2]; let turnName = u.name.split(' ')[0]; if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)"); document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`; if (u.team === 1 && this.mode !== 'pvp') { this.noInput(); this.timer = setTimeout(() => this.ai(u), 1000); } else { this.input(u); } } catch (e) { console.error(e); alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤."); } },
    serializeUnit: function(u) { return { id: u.id, team: u.team, base: u.base, extra: u.extra, hp: u.hp, maxHp: u.maxHp, shield: u.shield, atk: u.atk, status: u.status, isDead: u.isDead, thornStack: u.thornStack, linkedAllyId: u.linkedAllyId, s2Count: u.s2Count, elecStacks: u.elecStacks, growthStack: u.growthStack, stats: u.stats, passiveTriggered: u.passiveTriggered, revengeAtk: u.revengeAtk }; },
    deserializeUnit: function(d) { const u = new Unit(d.id, d.team, d.base, d.extra); u.hp = d.hp; u.maxHp = d.maxHp; u.shield = d.shield; u.atk = d.atk; u.status = d.status; u.isDead = d.isDead; if(d.thornStack) u.thornStack = d.thornStack; if(d.linkedAllyId) u.linkedAllyId = d.linkedAllyId; if(d.s2Count) u.s2Count = d.s2Count; if(d.elecStacks) u.elecStacks = d.elecStacks; if(d.growthStack) u.growthStack = d.growthStack; if(d.stats) u.stats = d.stats; if(d.passiveTriggered) u.passiveTriggered = d.passiveTriggered; if(d.revengeAtk) u.revengeAtk = d.revengeAtk; return u; },
    calc: (a,d) => { let v = 1.0; let t = ''; if(a.isNormal) { if(d.isNormal || d.isEnhanced) { v=1.2; t='(ê°•íƒ€)'; } } else { const w={ 'Fire':['Metal','Tree'], 'Water':['Fire','Metal'], 'Tree':['Water','Earth'], 'Metal':['Tree','Earth'], 'Earth':['Fire','Water'] }; const ew={'Light':['Dark'],'Dark':['Light']}; if(!d.isNormal){ if(w[a.base]?.includes(d.base)||ew[a.base]?.includes(d.base)) { v=1.2; t='(ì•½ì )'; } else if(w[d.base]?.includes(a.base)) { v=0.8; t='(ì €í•­)'; } } } if(v===1.2 && a.extra && d.extra && ((a.extra==='Light'&&d.extra==='Dark')||(a.extra==='Dark'&&d.extra==='Light'))) { v=1.3; t='(ì¹˜ëª…íƒ€!)'; } return {v, t}; }
};

window.onload = function() { Game.init(); };
</script>
</body>
</html>
