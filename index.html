<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v5.8 Guidebook Update</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            /* [Theme] Jelly Cat Palette v5.8 */
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255,255,255,0.8), inset 0 -3px 6px rgba(0,0,0,0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body { 
            margin: 0; background-color: var(--bg-main); 
            background-image: var(--paw-pattern);
            background-size: 80px 80px; 
            color: var(--text-main); 
            font-family: var(--font-main);
            overflow: hidden; user-select: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; height: 100dvh; 
        }

        .screen-shake { animation: jelly-bounce 0.5s both; }
        @keyframes jelly-bounce { 
            0% { transform: scale(1, 1); } 
            30% { transform: scale(1.15, 0.85); } 
            40% { transform: scale(0.9, 1.1); }    
            50% { transform: scale(1.05, 0.95); } 
            65% { transform: scale(0.98, 1.02); } 
            100% { transform: scale(1, 1); } 
        }
        
        @keyframes shake-anim {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-5px, 0) rotate(-5deg); }
            50% { transform: translate(5px, 0) rotate(5deg); }
            75% { transform: translate(-5px, 0) rotate(-5deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }
        .shake { animation: shake-anim 0.4s; }

        #flash-overlay { position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 999; transition: opacity 0.1s; }

        #app { width: 100%; max-width: 600px; height: 100%; position: relative; display: flex; flex-direction: column; }
        
        button { 
            font-family: var(--font-main); border-radius: 25px; border: none; 
            background: #fff; color: #777; cursor: pointer; transition: 0.1s; 
            box-shadow: var(--jelly-shadow); 
            transform: translateY(0); 
            position: relative; overflow: hidden;
        }
        button::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
            border-radius: 20px; pointer-events: none;
        }
        button:active { transform: translateY(3px) scale(0.98); box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); }
        
        .btn-restart { padding: 8px 16px; font-size: 14px; color: var(--accent); }
        .btn-restart:hover { background: #fff0f5; }

        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; padding: 15px; z-index: 10; }
        #selection-screen { background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); }
        #battle-screen { display: none; padding: 5px; }

        .hero-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; overflow-y: auto; padding: 10px; flex: 1; }
        
        .hero-card { 
            background: #fff; border-radius: 20px; padding: 8px; 
            cursor: pointer; transition: 0.2s; 
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05), inset 0 0 0 3px #fce4ec; 
            position: relative;
        }
        .hero-card:active { transform: scale(0.95); }
        .hero-card.selected { 
            background: #e1bee7; 
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }
        .hero-card.selected::after {
            content: 'ğŸ¾'; position: absolute; top: -10px; right: -5px;
            background: var(--accent); color: #fff; width: 28px; height: 28px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 16px; box-shadow: 0 3px 6px rgba(0,0,0,0.2); z-index: 5;
            border: 2px solid #fff;
        }

        .field-row { flex: 1; display: flex; justify-content: space-evenly; align-items: center; width: 100%; perspective: 1000px; }
        
        .unit { 
            width: 28vw; max-width: 120px; 
            background: #fff; 
            border-radius: 25px; padding: 8px 5px; position: relative; transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            cursor: default; 
            box-shadow: inset 0 4px 10px rgba(255,255,255,1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0,0,0,0.1);
            text-align: center;
            display: flex; flex-direction: column; align-items: center;
            min-height: 115px; justify-content: flex-end;
            border: 2px solid #f8bbd0;
        }
        
        .unit.active-turn { 
            border-color: var(--accent); 
            transform: translateY(-12px) scale(1.05); 
            z-index: 5; 
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3); 
        }
        .unit.target-enemy:hover { border-color: #ff7043; background: #ffebee; cursor: crosshair; transform: scale(1.05) rotate(2deg); }
        .unit.target-ally:hover { border-color: #66bb6a; background: #e8f5e9; cursor: pointer; transform: scale(1.05) rotate(-2deg); }
        .unit.target-aoe { border-color: #ff7043; background: #ffebee; animation: jelly-bounce 1s infinite; cursor: pointer; }
        .unit.dead { opacity: 0.6; filter: grayscale(1); pointer-events: none; border-color: #cfd8dc; transform: scale(0.9) rotate(5deg); box-shadow: none; }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon { 
            width: 48px; height: 48px; border-radius: 50%; margin-bottom: 4px; 
            display: flex; justify-content: center; align-items: center; font-size: 28px; 
            color: #fff; position: relative; 
            box-shadow: 0 4px 0 rgba(0,0,0,0.1); 
            border: 3px solid #fff;
        }
        
        .mini-attr-box {
            position: absolute; bottom: -2px; right: -2px; 
            display: flex; gap: 1px; background: rgba(255,255,255,0.95); 
            padding: 2px; border-radius: 12px; border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .mini-icon { font-size: 12px; line-height: 1; }
        
        .status-bar { width: 85%; height: 12px; background: #eceff1; border-radius: 12px; overflow: hidden; position: relative; margin-top: 4px; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .hp-fill { height: 100%; background: var(--hp-high); border-radius: 10px; transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .hp-fill::after { content:''; position:absolute; top:2px; left:2px; right:2px; height:3px; background:rgba(255,255,255,0.4); border-radius:10px; }
        .shield-fill { position: absolute; top:0; left:0; height: 100%; background: var(--shield); opacity: 0.8; border-radius: 10px; transition: width 0.3s; }

        .control-panel { 
            flex: 0 0 auto; max-height: 45vh; 
            background: rgba(255,255,255,0.9); border-radius: 35px 35px 0 0; 
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15); 
            display: flex; flex-direction: column; overflow: hidden; width: 100%;
            border-top: 6px solid #ff80ab;
            backdrop-filter: blur(10px);
        }
        .cp-header { padding: 12px 20px; background: #fff8e1; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dashed #ffe082; }
        
        .timeline-container { height: 50px; background: #fff; border-bottom: 2px dashed #ffcdd2; display: flex; align-items: center; padding: 0 15px; overflow: hidden; gap: 10px; }
        .timeline-label { font-size: 13px; font-weight: bold; color: var(--accent); margin-right: 5px; }
        .tl-node { 
            width: 32px; height: 32px; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; font-size: 18px; 
            border: 3px solid #eee; position: relative; flex-shrink: 0; transition:0.3s; 
            background: #fff; box-shadow: 0 3px 0 #ddd;
        }
        .tl-node.curr { 
            border-color: var(--accent); transform: scale(1.2); z-index: 2; 
            box-shadow: 0 0 0 3px #ffecb3, 0 5px 10px rgba(255,64,129,0.2); 
        }
        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container { flex: 1; padding: 15px; overflow-y: auto; font-size: 14px; border-bottom: 2px solid #f0f0f0; background: #fff; line-height: 1.6; display: flex; flex-direction: column; min-height: 60px; }
        .log-entry { margin-bottom: 6px; padding: 8px 12px; background: #fafafa; border-radius: 15px; word-break: keep-all; border-left: 4px solid #eee; }
        .log-ally { color: #29b6f6; font-weight:bold; } .log-enemy { color: #ff7043; font-weight:bold; } .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; font-size: 1.1em; }
        
        .btn-group { display: flex; height: 90px; flex-shrink: 0; padding: 8px; gap: 8px; background: #fff5f8; }
        .skill-btn { 
            flex: 1; border: none; background: #fff; border-radius: 20px;
            cursor: pointer; transition: 0.2s; color: var(--text-main); display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; padding: 5px;
            box-shadow: var(--jelly-shadow); transform: translateY(0);
        }
        .skill-btn::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0));
            border-radius: 15px; pointer-events: none;
        }
        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform:none; }
        .skill-name { font-size: 15px; font-weight: bold; margin-bottom: 3px; }
        .skill-desc { font-size: 11px; color: #90a4ae; line-height: 1.2; }

        .passive-panel {
            background: #e0f2f1; padding: 8px 15px; font-size: 13px; color: #00695c;
            display: flex; align-items: center; border-radius: 15px; margin: 5px 15px;
            border: 2px solid #b2dfdb;
        }
        .passive-icon { margin-right: 8px; font-size: 16px; }
        
        .btn-start { 
            background: var(--accent); color: white; border: none; padding: 18px; 
            border-radius: 35px; font-weight: bold; width: 100%; margin-top: 15px; 
            cursor: pointer; font-size: 22px; box-shadow: 0 8px 0 #c2185b, 0 15px 20px rgba(0,0,0,0.15); 
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn-start::after { content:'ğŸ¾'; font-size:24px; margin-left:10px; opacity:0.8; }
        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(6px); box-shadow: 0 2px 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform:none; }

        .btn-rnd { background:#b39ddb; color:#fff; border:none; padding:10px 20px; border-radius:25px; cursor:pointer; font-weight:bold; margin-left:5px; box-shadow: 0 5px 0 #7e57c2; }
        .btn-rnd:active { transform: translateY(5px); box-shadow:none; }

        .tag-container { 
            position: relative; top: 0; left: 0; 
            width: 100%; display: flex; justify-content: center; 
            gap: 3px; flex-wrap: wrap; margin-bottom: 5px; 
            z-index: 10; 
        }
        .tag { padding: 4px 8px; border-radius: 12px; font-size: 10px; color: #fff; font-weight: bold; box-shadow: 0 2px 0 rgba(0,0,0,0.1); margin-bottom:2px; }
        
        /* Pastel Colors */
        .tag.poison { background: #ab47bc; } .tag.stun { background: #ffd54f; color:#5d4037; }
        .tag.freeze { background: #29b6f6; } .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; } .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; } .tag.bind { background: #66bb6a; } .tag.trap { background: #d4e157; color:#5d4037; }
        .tag.atkdown { background: #5c6bc0; } .tag.growth { background: #9ccc65; color:#33691e; }
        .tag.blind { background: #bdbdbd; color:#5d4037; }
        .tag.immunity { background: #fff; color:#5d4037; border:2px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color:#fff; }
        .tag.atkup { background: #ef5350; color:#fff; }
        .tag.karma { background: #512da8; color:#fff; border: 1px solid #d1c4e9; animation: jelly-bounce 2s infinite; } /* Karma UI Improved */

        /* Pastel Gradients */
        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color:#1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color:#5d4037; }
        
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color:#5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        .float-text {
            position: absolute; font-weight: 900; font-size: 28px; pointer-events: none; z-index: 100;
            text-shadow: 2px 2px 0px #fff; animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; } 
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; } 
        }
        .ft-dmg { color: #ff7043; } .ft-crit { color: #ffa726; font-size: 36px; } 
        .ft-heal { color: #26a69a; } .ft-miss { color: #b0bec5; font-size: 20px; }

        #modal-overlay { position: fixed; inset: 0; background: rgba(255, 248, 225, 0.85); backdrop-filter:blur(5px); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #fff; padding: 25px; border-radius: 35px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3); overflow-y:auto; max-height:80vh; border: 5px solid #ffcc80; position: relative;}
        
        /* Guidebook Tabs */
        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }

        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }

        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }
    </style>
</head>
<body>

<div id="flash-overlay"></div>
<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v5.8 Guidebook Update</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
        </div>
        <div class="hero-grid" id="hero-grid"></div>
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                    <option value="normal" selected>ğŸ¤– ë‚œì´ë„: ë³´í†µ</option>
                    <option value="easy">ğŸ£ ë‚œì´ë„: ì‰¬ì›€ (ëœë¤)</option>
                    <option value="hard">ğŸ”¥ ë‚œì´ë„: ì–´ë ¤ì›€</option>
                    <option value="hell">ğŸ‘¿ ë‚œì´ë„: ì§€ì˜¥ (NEW 8)</option>
                    <option value="pvp">âš”ï¸ 2ì¸ ëŒ€ì „ (ì¹œêµ¬ë‘)</option>
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        <button id="btn-start" class="btn-start" onclick="Game.start()" disabled>ì „íˆ¬ ì‹œì‘ (0/3)</button>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; font-size:16px; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:8px;">
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ  í™ˆ</button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>
  <script>
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

// [ìˆ˜ì •] SKILL_DBì— desc(íŠ¹ì§•) ì¶”ê°€ ë° Fire-Dark íŒ¨ì‹œë¸Œ ìˆ˜ì •
const SKILL_DB = {
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.5ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë”œëŸ¬ | í¡í˜ˆ+í™”ìƒ', passive:'ğŸ©¸ í¡í˜ˆ: ëª¨ë“  ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 20%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì•„êµ°ì „ì²´ HP+110 (20%í™•ë¥  +50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'íëŸ¬ | ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ì‰´ë“œ+30/ê³µ+18 ì„±ì¥', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', desc:'íƒ±ì»¤ | ìê°€ ì„±ì¥', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+í”¼í•´í¡ìˆ˜(30%)', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ì  ë„ë°œ/ì‰´ë“œ+15', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'íƒ±ì»¤ | ë„ë°œ+ìµœëŒ€í”¼í•´ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ25%/ì¹¨ë¬µ20%', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°°', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸœï¸', desc:'ì„œí¬í„° | í™•ë¥ í˜• CC', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+10(1í„´)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ì„œí¬í„° | ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê³µâ†“/ì‰´ë“œ30%ì†Œë©¸', type:'DEBUFF', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ì„œí¬í„° | CCë°˜ì‚¬+ê³µí¬', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ ë˜ëŒë ¤ì¤ë‹ˆë‹¤.' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ì•„êµ°ë³´í˜¸(HPì†Œëª¨)', s2:'ì£¼ì‚¬ìœ„', s2d:'ëœë¤ í”¼í•´', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë”œëŸ¬ | ì™„ì „ ë©´ì—­', passive:'ğŸ² ë©´ì—­: CCê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ ë“±)ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤. (ë„íŠ¸ë”œ ì œì™¸)' },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ì„œí¬í„° | ê´‘ì—­ ì •í™”', passive:null },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ', s2:'ë¸”ë™í™€', s2d:'í„´ ìŠ¤í‚µ(75%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ•³ï¸', desc:'ì„œí¬í„° | ê°•ë ¥í•œ ì¶”ë°©', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ë¸”ë™í™€ ì„±ê³µ ì‹œ ê³µê²©ë ¥ì´ 10 ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'1.4ë°°+ì‹¤ëª…(20%)', s2:'ì•ˆê°œ', s2d:'íƒ€ê²Ÿí+íšŒí”¼(15%)', type:'TARGET_BUFF', target:'ALLY', role:'supp', icon:'â˜ï¸', desc:'ì„œí¬í„° | íšŒí”¼ ë¶€ì—¬', passive:'â˜ï¸ ì¦ê¸°: íšŒí”¼ ì‹œ ê¸°ì ˆ/ë¹™ê²° CCê¸°ë¥¼ 15% í™•ë¥ ë¡œ ë¬´íš¨í™”í•©ë‹ˆë‹¤ (íšŒí”¼ì†Œë©¸).' },
    'Fire-Light': { s1:'ì²­ì—¼', s1d:'1.5ë°°', s2:'í­ì£¼', s2d:'ìì‹  ê³µ+40~ (ìµœëŒ€5íšŒ)', type:'BUFF', target:'SELF', role:'nuker', icon:'ğŸ”·', desc:'ë”œëŸ¬ | ì™•ê·€í˜• ì„±ì¥', passive:'ğŸ”¥ í­ì£¼: ìŠ¤í‚¬ ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ ëŒ€í­ ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 5íšŒ).' },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì‰´ë“œê´€í†µ+í', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ì„œí¬í„° | ì‰´ë“œê´€í†µ+ì •í™”', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.5ë°°+ì‰´ë“œíŒŒê´´(ì„±ê³µì‹œ ì‰´ë“œ)', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…', type:'DEBUFF', target:'ALL_ENEMY', role:'tank', icon:'â˜£ï¸', desc:'íƒ±ì»¤ | ì‰´ë“œíŒŒê´´+ì¤‘ë…', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°+ì‰´ë“œë¬´ì‹œ', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì¹˜ìœ ê°ì†Œ(ê°•)+ë„íŠ¸', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ¦‚', desc:'ì„œí¬í„° | ì¹˜ìœ ê°ì†Œ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'ë”œëŸ¬ | ê°•ë ¥í•œ ë¹™ê²°', passive:null },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'ì²´ë ¥ë¹„ë¡€í”¼í•´', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë”œëŸ¬ | ì²´ë ¥ë¹„ë¡€ë”œ', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' }, // í¡í˜ˆ ì‚­ì œ
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ìŠ¤íƒê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì‚¬ë§ì‹œ í­ì£¼/ê´‘ì—­ë…', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ¥€', desc:'íƒ±ì»¤ | ì‚¬ë§ ì‹œ ë³µìˆ˜', passive:'ğŸ¥€ ë³µìˆ˜: ì‚¬ë§ ì‹œ ì  ì „ì²´ì—ê²Œ ë§¹ë…ì„ ê±¸ê³  ì•„êµ° í•˜ë‚˜ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³¼ë¶€í•˜(ìµœëŒ€5íšŒ)', s2:'ë°©ì „', s2d:'ê´‘ì—­+ê¸°ì ˆ15%/ê³¼ë¶€í•˜', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë”œëŸ¬ | ìŠ¤íƒí˜• ê´‘ì—­ë”œ', passive:'âš¡ ê³¼ë¶€í•˜: ê³µê²© ì‹œ ìŠ¤íƒì´ ìŒ“ì´ë©° ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+1í„´ê¸°ì ˆ(íœ´ì‹)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë”œëŸ¬ | í•œë°© í­ë”œ', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' }
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id; this.team = team;
        this.base = base; this.extra = extra;
        this.maxHp = 600; 
        if(base==='Tree' && extra==='Dark') this.maxHp = 700;
        this.hp = this.maxHp; this.shield = (base==='Metal' && !extra) ? 100 : 0;
        this.atk = 55 + Math.floor(Math.random()*15);
        this.status = []; this.isDead = false;
        this.thornStack = 0; this.linkedAllyId = -1;
        this.resist = 0; 
        this.s2Count = 0;
        this.elecStacks = 0;
        this.stats = { dmg: 0, heal: 0, shieldGiven: 0, taken: 0 }; 

        this.isNormal = (this.base==='Light'&&this.extra==='Dark') || (this.base==='Dark'&&this.extra==='Light');
        this.isEnhanced = (this.base===this.extra && (this.base==='Light'||this.base==='Dark'));
        
        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() { if(this.isNormal) return 'Normal'; if(this.isEnhanced) return `${this.base}-${this.extra}`; return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base; }
    
    getAtk() { 
        let v = this.atk; 
        const ads = this.status.filter(s=>s.type==='ATK_DOWN'); 
        if(ads.length>0) v -= (ads.length*15); 
        if(this.hasStatus('LIGHT_MIGHT')) v += 10;
        return Math.max(10, v); 
    }
    
    takeDamage(dmg, isFire=false, ignoreShield=false) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);
        
        // ì‡ (Metal) íŒ¨ì‹œë¸Œ: ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¡œ ì œí•œ
        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30); 
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal"); 
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) { if(Math.random() < 0.15) return -1; }

        const link = this.status.find(s => s.type.startsWith('REFLECT_LINK_'));
        if (link) Game.recordReflectDamage(this.team, parseInt(link.type.split('_')[2]), dmg);
        
        this.stats.taken += dmg;

        if (!ignoreShield && this.shield > 0) { if(this.shield >= dmg) {this.shield -= dmg; return 0;} else {dmg -= this.shield; this.shield = 0;} }
        
        if (dmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            dmg += 10;
            UI.floatText(this, "Crack!", "ft-crit"); 
        }

        this.hp = Math.max(0, this.hp - dmg);
        return dmg;
    }
    
    revive(hpPercent) {
        this.isDead = false;
        this.hp = Math.floor(this.maxHp * hpPercent);
        this.status = [];
        this.shield = 0;
    }

    addStatus(type, turn, val=0, source=null) {
        if (this.isNormal && ['FREEZE','STUN','SILENCE','BLIND','BANISH','ATK_DOWN','HEAL_DOWN','BIND','KARMA_VICTIM'].includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type)) {
            if (source && source.id !== this.id) {
                if (Math.random() < 0.15) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return; 
                }
            }
        }

        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type.startsWith('KARMA_VICTIM_'));
            if (karma) {
                const ownerId = parseInt(karma.type.split('_')[2]);
                if (ownerId === this.id) {
                    const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
                    const isBanish = type === 'BANISH';
                    const isReflectable = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','ATK_DOWN'].includes(type);

                    if (!isDarkVsDark && !isBanish && isReflectable) {
                        UI.floatText(this, "ë°˜ì‚¬! â†©ï¸", "ft-crit");
                        Game.log(`<span class='log-crit'>ğŸ‘ï¸ [${this.name}] ì—…ë³´ ë°œë™! ${type} ë°˜ì‚¬ â” [${source.name}]</span>`);
                        source.addStatus(type, turn, val, null); 
                        return; 
                    }
                }
            }
        }

        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY')) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            if (!source || source.id !== this.id) {
                this.status.push({type: 'IMMUNITY', turn: turn + 1});
            }
        }

        if (this.resist > 0 && Math.random() < this.resist && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        
        if (type === 'ATK_DOWN') { 
            const s = this.status.filter(s=>s.type==='ATK_DOWN'); 
            if(s.length < 2) {
                this.status.push({type, turn, val}); 
            } else { 
                const shortest = s.sort((a,b) => a.turn - b.turn)[0];
                shortest.turn = turn;
            }
            return; 
        }
        
        if(type==='BURN') { const ex = this.status.find(s=>s.type==='BURN'); if(ex) { ex.turn = turn; return; } }
        if(type==='HEAL_DOWN') { const ex = this.status.find(s=>s.type==='HEAL_DOWN'); if(ex) { ex.turn = turn; return; } }
        if(type==='LIGHT_MIGHT') { const ex = this.status.find(s=>s.type==='LIGHT_MIGHT'); if(ex) { ex.turn = turn; return; } }
        
        if (type.startsWith('KARMA_VICTIM_')) {
             const ex = this.status.find(s => s.type === type);
             if(ex) { ex.turn = turn; return; }
        }

        if (type.startsWith('PROVOKED_BY_') && source) type = `PROVOKED_BY_${source.id}`;

        const idx = this.status.findIndex(s=>s.type===type); if(idx >= 0) this.status[idx].turn = turn; else this.status.push({type, turn, val});
    }
    hasStatus(type) { return this.status.some(s=>s.type===type); }
    
    cleanse() { 
        const bad = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN','KARMA_VICTIM']; 
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM')); 
    }
    dispel() { const buffs = ['EVADE','DMG_RED','ATK_BUFF','GROWTH','LIGHT_MIGHT']; const has=this.status.some(s=>buffs.includes(s.type)); this.status=this.status.filter(s=>!buffs.includes(s.type)); return has; }
    
    tickStatus() {
        let log = [];
        if(this.hasStatus('POISON')) { const d=this.takeDamage(30); UI.floatText(this, d, 'ft-dmg'); log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ ${d}`); }
        if(this.hasStatus('BURN')) { const d=this.takeDamage(20); UI.floatText(this, d, 'ft-dmg'); log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ ${d}`); }
        if(this.hasStatus('TRAP')) { const d=this.takeDamage(40); UI.floatText(this, d, 'ft-dmg'); log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ í”¼í•´ ${d}`); }
        return log;
    }

    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    
    heal(amount) { 
        if(this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4); 
        const prev=this.hp; 
        this.hp=Math.min(this.maxHp, this.hp+amount); 
        const diff=this.hp-prev; 
        if(diff>0) {
            UI.floatText(this, diff, 'ft-heal'); 
        }
        return diff; 
    }
}

const AudioSys = {
    ctx: null,
    init: function() { 
        if(this.ctx) return;
        try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} 
    },
    resume: function() { if(this.ctx&&this.ctx.state==='suspended') this.ctx.resume(); },
    playSoft: function(freq, type, dur, vol=0.3) { 
        if(!this.ctx) return;
        const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const t=this.ctx.currentTime;
        o.type=type; o.frequency.setValueAtTime(freq,t);
        g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.1);
    },
    play: function(type) {
        if(!this.ctx) return;
        if(type==='HIT') this.playSoft(600,'sine',0.1,0.4); 
        else if(type==='SKILL') { this.playSoft(500,'sine',0.15,0.3); setTimeout(()=>this.playSoft(800,'sine',0.2,0.3),100); } 
        else if(type==='HEAL') { this.playSoft(500,'sine',0.2,0.3); setTimeout(()=>this.playSoft(700,'sine',0.3,0.3),150); }
        else if(type==='DEBUFF') { this.playSoft(300,'triangle',0.2,0.35); setTimeout(()=>this.playSoft(200,'triangle',0.2,0.35), 150); } 
        else if(type==='MISS') this.playSoft(900,'square',0.05,0.2); 
        else if(type==='WIN') { setTimeout(()=>this.playSoft(523,'sine',0.2,0.5),0); setTimeout(()=>this.playSoft(659,'sine',0.2,0.5),200); setTimeout(()=>this.playSoft(784,'sine',0.4,0.5),400); }
        else if(type==='POWER_UP') { 
            this.playSoft(440,'sine',0.2,0.35); setTimeout(()=>this.playSoft(554,'sine',0.2,0.35), 100); setTimeout(()=>this.playSoft(659,'sine',0.3,0.35), 200); 
        }
        else if(type==='CRITICAL') { this.playSoft(150,'triangle',0.1,0.6); setTimeout(()=>this.playSoft(880,'sine',0.3,0.7), 50); } 
    }
};

const UI = {
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() { document.getElementById('modal-overlay').style.display = 'none'; },
    
    // [ìˆ˜ì •] ê°€ì´ë“œë¶ (íƒ­ ê¸°ëŠ¥)
    showGuide: function() {
        let heroList = '';
        Object.keys(SKILL_DB).forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if(k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if(parts.length===2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';

            heroList += `
            <div class="guide-item">
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div>
                <div class="guide-info">
                    <div class="guide-name">${name}</div>
                    <div class="guide-desc">${s.desc}</div>
                    <div style="font-size:10px; color:#555; margin-top:2px;">
                        <div>S1: ${s.s1} (${s.s1d})</div>
                        <div>S2: ${s.s2} (${s.s2d})</div>
                    </div>
                </div>
            </div>`;
        });

        const content = `
            <div class="tab-header">
                <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button>
                <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button>
            </div>
            <div id="tab-0" class="tab-content active">
                <table class="chart-table">
                    <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                    <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                    <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                    <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                    <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                    <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                    <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
                    <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr>
                </table>
                <div class="dual-chart">
                    <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                    <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div>
                </div>
            </div>
            <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;">
                ${heroList}
            </div>
        `;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if(i===idx) b.classList.add('active'); else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if(i===idx) c.classList.add('active'); else c.classList.remove('active');
        });
    },

    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id); if(!unitEl) return;
        const el = document.createElement('div'); el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        el.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px'; el.style.top = (rect.top + window.scrollY) + 'px';
        document.body.appendChild(el); setTimeout(() => el.remove(), 800);
    },
    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);

        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        
        const mvp = allUnits.sort((a,b)=>(b.stats.dmg+b.stats.heal+b.stats.shieldGiven)-(a.stats.dmg+a.stats.heal+a.stats.shieldGiven))[0];

        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            
            return `
            <div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
                ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''}
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div>
                    <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div>
                </div>
                <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;">
                    <span style="width:30px; color:#888;">ë”œ</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span>
                </div>
                <div style="display:flex; align-items:center; font-size:11px;">
                    <span style="width:30px; color:#888;">í</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span>
                </div>
            </div>`;
        };

        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },
    checkMode: function() {
        Game.checkMode();
    }
};

const Game = {
    pool: [], selected: [], pTeam: [], eTeam: [], queue: [], curr: 0, selectedSkillIdx: -1, timer: null, turnCount: 1, difficulty: 'normal', watchdog: null,
    isOver: false, mode: 'pve', isProcessing: false,

    init: function() {
        if(this.timer) clearTimeout(this.timer);
        this.isOver = false;
        let combos = [];
        const bases = ['Fire','Water','Tree','Metal','Earth','Light','Dark'];
        const extras = [null, 'Light', 'Dark'];
        bases.forEach(b => extras.forEach(e => combos.push({b, e})));
        combos = combos.filter(c => !(c.b === 'Dark' && c.e === 'Light')); 
        combos.sort(() => Math.random() - 0.5);

        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        this.pool = []; this.selected = [];

        for(let i=0; i<12; i++) {
            const c = combos[i];
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
            const el = document.createElement('div');
            el.className = 'hero-card';
            // [ìˆ˜ì •] ì¹´ë“œ í…ìŠ¤íŠ¸: ì—­í• êµ° + íŠ¹ì§•(desc) í‘œì‹œ
            el.innerHTML = this.renderCard(u);
            el.onclick = () => this.toggle(i, el);
            grid.appendChild(el);
        }
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
    },

    renderCard: function(u) {
        let bgClass = `bg-${u.base}`;
        if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
        if(u.isNormal) bgClass = 'bg-Normal';
        const info = SKILL_DB[u.getKey()];
        const icon = info.icon || ''; 
        // [ìˆ˜ì •] desc ì‚¬ìš©
        return `<div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div><div style="font-weight:bold; margin-bottom:2px; font-size:15px;">${u.name.split(' ')[0]}</div><div style="font-size:11px; color:#999;">${u.name}</div><div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">${info.desc}</div>`;
    },

    toggle: function(i, el) {
        if(this.selected.includes(i)) { this.selected = this.selected.filter(x=>x!==i); el.classList.remove('selected'); }
        else { if(this.selected.length>=3) return; this.selected.push(i); el.classList.add('selected'); }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (${this.selected.length}/3)`;
        btn.disabled = this.selected.length !== 3;
    },

    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if(el) el.classList.remove('selected');
        });
        Game.selected = [];
        while(Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 12);
            if(!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if(el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    
    checkMode: function() {
        // UI Interaction placeholder
    },

    start: function() {
        AudioSys.init(); AudioSys.resume();
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = diffVal === 'pvp' ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => { const u = this.pool[idx]; u.id=i; u.team=0; return u; });
        this.eTeam = [];
        this.isOver = false;
        
        const makeEnemy = (idx, b, e) => { const u = new Unit(idx + 3, 1, b, e); return u; };

        if (this.difficulty === 'hell') {
            const decks = [
                [{b:'Metal',e:'Light'}, {b:'Earth',e:'Light'}, {b:'Normal',e:null}], 
                [{b:'Metal',e:null}, {b:'Light',e:null}, {b:'Fire',e:'Light'}], 
                [{b:'Normal',e:null}, {b:'Light',e:'Light'}, {b:'Tree',e:null}], 
                [{b:'Fire',e:'Light'}, {b:'Earth',e:'Dark'}, {b:'Normal',e:null}], 
                [{b:'Dark',e:'Dark'}, {b:'Water',e:'Dark'}, {b:'Earth',e:null}], 
                [{b:'Tree',e:null}, {b:'Water',e:null}, {b:'Water',e:'Light'}], 
                [{b:'Earth',e:'Dark'}, {b:'Light',e:'Light'}, {b:'Metal',e:'Light'}], 
                [{b:'Tree',e:'Dark'}, {b:'Tree',e:null}, {b:'Water',e:'Light'}]
            ];
            const d = decks[Math.floor(Math.random()*decks.length)];
            this.eTeam = d.map((c, i) => makeEnemy(i, c.b, c.e));
        } else {
            const used = new Set();
            while(this.eTeam.length<3) {
                const b = ['Fire','Water','Tree','Metal','Earth','Light','Dark'][Math.floor(Math.random()*7)];
                const e = [null,'Light','Dark'][Math.floor(Math.random()*3)];
                if(b==='Dark'&&e==='Light') continue; 
                
                let key = `${b}-${e}`;
                if(b==='Light'&&e==='Dark') key = 'Normal';
                
                if(!used.has(key)) { 
                    used.add(key); 
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); 
                }
            }
        }
        this.queue = [0,1,2,3,4,5]; this.curr = Math.floor(Math.random()*6);
        this.turnCount = 1;
        this.isProcessing = false; // Reset processing flag
        document.getElementById('selection-screen').style.display='none';
        document.getElementById('battle-screen').style.display='flex';
        document.getElementById('logs').innerHTML = ''; 
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! (${this.mode==='pvp'?'2ì¸ ëŒ€ì „':'vs AI'})</span>`);
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1000);
    },

    reset: function() {
        if(this.timer) clearTimeout(this.timer);
        if(this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display='none';
        document.getElementById('selection-screen').style.display='flex';
        this.init();
    },

    recordReflectDamage: function(teamId, ownerId, amount) {},
    
    recordStat: function(unit, type, amount) {
        if(!unit || amount <= 0) return;
        if(type === 'dmg') unit.stats.dmg += amount;
        if(type === 'shield') unit.stats.shieldGiven += amount;
        if(type === 'heal') unit.stats.heal += amount;
    },

    turn: function() {
        this.isProcessing = false; // Unlock input

        if (this.isOver) return;

        if(this.watchdog) clearTimeout(this.watchdog);
        this.watchdog = setTimeout(() => {
            console.log("AI Stuck Detected. Forcing next turn.");
            this.endTurn();
        }, 3000);

        if(this.endCheck()) return;
        const tVal = this.queue[this.curr];
        const u = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];

        if(u.isDead) { this.endTurn(); return; }

        if(u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) {
            UI.floatText(u, "SKIP", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`);
            setTimeout(() => this.endTurn(), 800);
            return;
        }
        
        const tickLogs = u.tickStatus();
        tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if(u.hp<=0) { this.die(u); this.endTurn(); return; }

        let turnName = u.name.split(' ')[0];
        if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
        document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
        this.turnCount++;
        
        if(u.team===0) { 
            if(this.watchdog) clearTimeout(this.watchdog);
            this.input(u); 
        } else { 
            if (this.mode === 'pvp') {
                if(this.watchdog) clearTimeout(this.watchdog);
                this.input(u); 
            } else {
                this.noInput(); 
                this.timer=setTimeout(()=>this.ai(u), 800); 
            }
        }
    },

    input: function(u) {
        const k=u.getKey(); const s=SKILL_DB[k];
        const silenced = u.hasStatus('SILENCE');
        
        document.getElementById('p-icon').innerText = s.icon;
        document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';

        document.getElementById('sk-1').innerHTML = `<span class="skill-name">${s.s1}</span><br><span class="skill-desc">${s.s1d}</span>`;
        document.getElementById('sk-2').innerHTML = `<span class="skill-name">${s.s2}</span><br><span class="skill-desc">${s.s2d}</span>`;
        document.getElementById('sk-0').disabled = false;
        document.getElementById('sk-1').disabled = silenced;
        
        let s2Limit = false;
        if (k === 'Fire-Light' && u.s2Count >= 5) s2Limit = true;
        let sk2Disable = silenced || s2Limit;
        
        if (k === 'Tree-Dark') {
            const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
            const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
            if (aliveAllies.length === 0 || u.linkedAllyId !== -1) sk2Disable = true;
        }
        
        document.getElementById('sk-2').disabled = sk2Disable;
        
        if(silenced) this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
        
        const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
        if(provoked) {
            const targetId = parseInt(provoked.type.split('_')[2]);
            const enemies = u.team === 0 ? this.eTeam : this.pTeam;
            const allies = u.team === 0 ? this.pTeam : this.eTeam;
            const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
            
            if(!target || target.isDead) {
                u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
                UI.floatText(u, "ììœ !", "ft-heal");
                this.render();
            } else {
                this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
                this.noInput(); 
                setTimeout(() => this.execute(u, target, 0), 1000);
                return;
            }
        }
        this.selectedSkillIdx = -1;
    },
    
    noInput: function() { [0,1,2].forEach(i=>{ const b = document.getElementById(`sk-${i}`); b.disabled=true; b.classList.remove('selected'); }); },

    prepareSkill: function(idx) {
        [0,1,2].forEach(i => { const b = document.getElementById(`sk-${i}`); if(i===idx) b.classList.add('selected'); else b.classList.remove('selected'); });
        this.selectedSkillIdx = idx;
        
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        
        const k = u.getKey(); const skillInfo = SKILL_DB[k];
        let targetType = (idx === 0 || idx === 1) ? 'ENEMY' : skillInfo.target;
        if(k==='Tree') { if(idx===1) targetType = 'SELF'; else if(idx===2) targetType = 'ALLY'; }
        if(k==='Water-Light' && idx===2) targetType = 'ALLY';
        this.highlightTargets(targetType, u);
    },

    highlightTargets: function(targetType, actingUnit) {
        if (!actingUnit) {
            const tVal = this.queue[this.curr];
            actingUnit = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        }

        document.querySelectorAll('.unit').forEach(el => { 
            el.classList.remove('target-enemy', 'target-ally', 'target-aoe'); 
            el.onclick = null; 
        });

        const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
        const isAllyTarget = ['ALLY','ALL_ALLY','SELF','SELF_BUFF'].includes(targetType);
        
        const myTeam = actingUnit.team === 0 ? this.pTeam : this.eTeam;
        const oppTeam = actingUnit.team === 0 ? this.eTeam : this.pTeam;
        
        const targets = isAllyTarget ? myTeam : oppTeam;
        let targetClass = isAllyTarget ? 'target-ally' : 'target-enemy';
        if (isAOE && !isAllyTarget) targetClass = 'target-aoe'; 

        targets.forEach((t) => {
            if(!t.isDead) {
                if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2 && t.id === actingUnit.id) return;

                const el = document.getElementById(t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`);
                el.classList.add(targetClass);
                el.onclick = () => {
                    if (Game.isProcessing) return; // Anti-Rapid Click
                    Game.isProcessing = true;

                    if(targetType === 'SELF' && t.id !== actingUnit.id) return;
                    this.noInput();
                    document.querySelectorAll('.unit').forEach(el => el.classList.remove('target-enemy', 'target-ally', 'target-aoe'));
                    this.execute(actingUnit, t, this.selectedSkillIdx);
                };
            }
        });
    },

    ai: function(u) {
        try {
            const silenced = u.hasStatus('SILENCE');
            
            const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if(provoked) {
                const targetId = parseInt(provoked.type.split('_')[2]);
                const target = this.pTeam.find(p => p.id === targetId) || this.eTeam.find(e => e.id === targetId);
                
                if(!target || target.isDead) {
                    u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                    this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
                    UI.floatText(u, "ììœ !", "ft-heal");
                    this.render();
                } else {
                    this.execute(u, target, 0); 
                    return; 
                }
            }

            const enemies = u.team === 0 ? this.eTeam : this.pTeam; 
            const allies = u.team === 0 ? this.pTeam : this.eTeam; 
            const aliveEnemies = enemies.filter(e => !e.isDead);
            const aliveAllies = allies.filter(a => !a.isDead);

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            const k = u.getKey(); 
            const info = SKILL_DB[k];
            
            let attackTarget = aliveEnemies[0];
            let bestScore = -9999;

            aliveEnemies.forEach(e => {
                let score = 0;
                let multi = Game.calc(u, e).v;
                if (multi >= 1.5) score += 150;
                else if (multi >= 1.2) score += 80;
                else if (multi < 1.0) score -= 50;

                let estDmg = u.getAtk() * multi;
                if (e.hp <= estDmg) score += 1000; 

                if (this.difficulty === 'hell' || this.difficulty === 'hard') {
                    const role = SKILL_DB[e.getKey()].role;
                    if (role === 'supp') score += 100; 
                    else if (role === 'nuker') score += 50; 
                }

                if (k === 'Earth-Dark') {
                    if (e.hp < 200 && e.hp > estDmg) score -= 50; 
                }
                if (k === 'Metal-Light') {
                    if (e.shield > 0) score += 100;
                }
                if (k === 'Fire-Dark') {
                    if (e.hp > 400) score += 60;
                }

                if (['STUN','FREEZE','BANISH'].some(s => e.hasStatus(s))) score -= 40;

                // [ìˆ˜ì •] AI ë¡œì§: ë©´ì—­ ëŒ€ìƒì—ê²Œ CCê¸° ì‚¬ìš© ë°©ì§€
                const isImmune = e.isNormal || e.hasStatus('IMMUNITY');
                if (isImmune) {
                    // ë¹™ê²°(Water-Dark), ê¸°ì ˆ(Earth), ì¶”ë°©(Dark-Dark), ê¸°ì ˆ(Metal-Dark S2)
                    if (k === 'Water-Dark' || k === 'Dark-Dark') score -= 9999;
                    if (k === 'Earth') score -= 50; // EarthëŠ” ë”œë„ ìˆìœ¼ë¯€ë¡œ ì•½ê°„ ëœ ê¹ìŒ
                }

                if (score > bestScore) { bestScore = score; attackTarget = e; }
            });

            if (this.difficulty === 'easy') attackTarget = aliveEnemies[Math.floor(Math.random()*aliveEnemies.length)];

            if (k === 'Tree') {
                const lowestAlly = aliveAllies.sort((a,b) => a.hp - b.hp)[0];
                if (lowestAlly.hp < lowestAlly.maxHp * 0.5 && !silenced) {
                    this.execute(u, lowestAlly, 2); 
                    return;
                } else if (u.hp < u.maxHp * 0.4 && !silenced) {
                    this.execute(u, u, 1); 
                    return;
                }
                if (!silenced) {
                    this.execute(u, u, 1);
                    return;
                }
            }

            let supportTarget = aliveAllies.sort((a,b) => a.hp - b.hp)[0]; 
            let blockS2 = false;

            if (k === 'Fire-Light') {
                const hasBuff = u.status.some(s => s.type === 'ATK_BUFF'); 
                if (hasBuff || u.s2Count >= 5) blockS2 = true; 
            }
            if (k === 'Tree-Dark') {
                const otherAllies = aliveAllies.filter(a => a.id !== u.id);
                if (otherAllies.length === 0 || u.linkedAllyId !== -1) blockS2 = true; 
                const others = aliveAllies.filter(a => a.id !== u.id).sort((a,b) => a.hp - b.hp);
                if (others.length > 0) supportTarget = others[0];
            }

            let action = 0;
            let finalTarget = attackTarget; 

            if (!silenced) {
                const isS2Support = ['BUFF','SELF_BUFF','HEAL','TARGET_BUFF','ALL_ALLY'].includes(info.type);
                let useS2 = false;
                
                if (info.type === 'HEAL') {
                    const totalMissing = aliveAllies.reduce((sum, a) => sum + (a.maxHp - a.hp), 0);
                    if (totalMissing > 300 || supportTarget.hp < supportTarget.maxHp * 0.6) useS2 = true;
                } else if (this.difficulty === 'hell' || this.difficulty === 'hard') {
                      useS2 = true; 
                } else {
                      useS2 = Math.random() > 0.4;
                }

                // AIê°€ ë©´ì—­ ëŒ€ìƒì—ê²Œ CC ìŠ¤í‚¬(S2)ì„ ì“°ë ¤ëŠ”ì§€ ì²´í¬
                if (useS2) {
                     const isImmune = (info.type === 'DEBUFF' || k === 'Water-Dark' || k === 'Dark-Dark') && 
                                      (attackTarget.isNormal || attackTarget.hasStatus('IMMUNITY'));
                     if (isImmune) useS2 = false;
                }

                if (useS2 && !blockS2) {
                    if (isS2Support) {
                        action = 2;
                        finalTarget = supportTarget; 
                        if (info.type === 'SELF_BUFF') finalTarget = u;
                    } else {
                        action = 2; 
                    }
                } else {
                    action = 1; 
                }
            }
            
            if (['HEAL'].includes(info.type) && !silenced) {
                const totalMissing = aliveAllies.reduce((sum, a) => sum + (a.maxHp - a.hp), 0);
                if (totalMissing > 300 || supportTarget.hp < supportTarget.maxHp * 0.6) {
                    action = 2;
                    finalTarget = supportTarget;
                } else {
                    action = 1; 
                    finalTarget = attackTarget;
                }
            }

            if (!finalTarget) {
                this.endTurn();
                return;
            }

            this.execute(u, finalTarget, action);
        } catch (e) {
            console.error(e);
            this.endTurn(); 
        }
    },

    execute: function(atk, def, sIdx) {
        document.querySelectorAll('.unit').forEach(el=>el.onclick=null);
        const k = atk.getKey(); const s = SKILL_DB[k];
        
        const aff = (def && def.team !== atk.team) ? this.calc(atk, def) : {v:1, t:''};
        let defMod = 1.0;
        
        if (def && def.team !== atk.team) {
            const defAff = this.calc(def, atk); 
            if (aff.v < 1.2) {
                if (defAff.v === 1.3) defMod = 0.76; 
                else if (defAff.v === 1.2) defMod = 0.83;
            }
        }

        let m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ${sIdx===0?'ê³µê²©':(sIdx===1?s.s1:s.s2)}`;
        
        const isGlobal = ['AOE','HEAL','BUFF','ALL_ALLY'].includes(s.type) && sIdx === 2;
        if (!isGlobal && def) {
             m += ` â” <b class="${def.team===0?'log-ally':'log-enemy'}">[${def.name}]</b>`;
        }

        if (atk.hasStatus('BLIND') && Math.random() < 0.20) { 
            m += " (ì‹¤ëª…ìœ¼ë¡œ ë¹—ë‚˜ê°!)"; UI.floatText(atk, "MISS", "ft-miss"); AudioSys.play('MISS');
            this.log(m); this.endTurn(); return;
        }

        const baseAtk = atk.getAtk();
        let playedSound = false;

        if(sIdx === 0) {
            AudioSys.play('HIT'); playedSound=true;
            const dmg = Math.floor(baseAtk * 1.0 * aff.v * defMod);
            const act = def.takeDamage(dmg);
            Game.recordStat(atk, 'dmg', act); 
            if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            else { 
                m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg");
                if (aff.v > 1.2 || act > 150) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; } 
                
                // [ìˆ˜ì •] í¡í˜ˆ: ê¸°ì´ˆ ë¶ˆ(Fire)ë§Œ ê°€ëŠ¥
                if (k === 'Fire') {
                    const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                    const h = atk.heal(healAmt);
                    Game.recordStat(atk, 'heal', h); 
                }
            }
        } 
        else if (sIdx === 1) {
            if(k === 'Tree') {
                atk.shield += 30; Game.recordStat(atk, 'shield', 30);
                atk.atk += 18; atk.addStatus('GROWTH', 99); 
                m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ê´‘í•©ì„±! (ì„±ì¥)`;
                UI.floatText(atk, "GROWTH", "ft-heal");
                AudioSys.play('POWER_UP'); playedSound=true;
            } else {
                let mult = 1.5; if(k==='Tree-Dark') mult += atk.thornStack; if(k==='Water-Light') mult = 1.4;
                if (k==='Metal-Light') mult = 0.5;
                if (k==='Metal') mult = 1.3;
                if (k==='Dark-Dark') mult = 0.9; 

                if(k==='Fire') mult = 1.5;

                let rawDmg = Math.floor(baseAtk * mult * aff.v * defMod);
                
                if(k==='Metal-Light' || k==='Earth') { AudioSys.play('DEBUFF'); playedSound=true; }

                if(k==='Earth') { if(Math.random() < 0.25) { def.addStatus('STUN', 1, 0, atk); m+='(ê¸°ì ˆ) '; } else if(Math.random() < 0.20) { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; } }
                
                if(k==='Metal-Light') { 
                    const broken = def.shield > 0;
                    def.shield=0; def.addStatus('POISON', 3, 0, atk); m+='(ì‰´ë“œíŒŒê´´+ì¤‘ë…) '; 
                    if (broken) {
                        const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                        const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                        if(lowest) { lowest.shield += 30; Game.recordStat(atk, 'shield', 30); UI.floatText(lowest, "+30ğŸ›¡ï¸", "ft-heal"); m+=`(ì•„êµ°ë³´í˜¸) `; }
                    }
                }

                if(k==='Dark-Dark') { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; }
                if(k==='Water-Light' && Math.random()<0.2) { def.addStatus('BLIND', 1, 0, atk); m+='(ì‹¤ëª… ì„±ê³µ) '; }
                if(k==='Fire') { def.addStatus('BURN', 2, 0, atk); m+='(í™”ìƒ) '; }
                if(k==='Fire-Dark') { (atk.team===0 ? this.eTeam : this.pTeam).forEach(e => { if(!e.isDead) e.addStatus('BURN', 2, 0, atk); }); m += '(ì „ì²´ í™”ìƒ) '; }
                if(k==='Tree-Light') {
                    const allies = atk.team===0 ? this.pTeam : this.eTeam;
                    const alive = allies.filter(a=>!a.isDead);
                    if(alive.length > 0) { 
                        const lucky = alive[Math.floor(Math.random()*alive.length)]; 
                        const h = lucky.heal(20); 
                        Game.recordStat(atk, 'heal', h); 
                        m+=`(ì•„êµ° íšŒë³µ) `; 
                    }
                }
                if(k==='Metal-Dark' && Math.random()<0.1) { 
                    const extra = Math.floor(baseAtk * 1.0 * aff.v * defMod); rawDmg += extra; 
                    if(atk.elecStacks < 5) { atk.atk += 25; atk.elecStacks++; AudioSys.play('POWER_UP'); } 
                    m += `<span class='log-crit'>(âš¡ê³¼ë¶€í•˜!+${extra})</span>`; 
                }

                if (k === 'Normal') {
                    atk.hp = Math.max(1, atk.hp - 30); 
                    const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                    const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                    if (lowest) {
                        const shieldAmt = (lowest.id === atk.id) ? 60 : 50;
                        lowest.shield += shieldAmt; Game.recordStat(atk, 'shield', shieldAmt); UI.floatText(lowest, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                    m += ` (HPì†Œëª¨/ë³´í˜¸)`;
                }

                if (k === 'Dark') {
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                    m += ' (ì—…ë³´ ì‹¬ê¸°)';
                }

                if (k === 'Earth-Light' || k === 'Tree-Light') { 
                    let actual = def.takeDamage(rawDmg, false, true);
                    Game.recordStat(atk, 'dmg', actual);
                    if (actual === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { m += ` ${actual} í”¼í•´ (ì‰´ë“œë¬´ì‹œ) ${aff.t}`; this.shake(def); UI.floatText(def, actual, "ft-crit"); }
                } else {
                    const act = def.takeDamage(rawDmg, k.startsWith('Fire'));
                    Game.recordStat(atk, 'dmg', act);
                    if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { 
                        m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg"); 
                        if (k === 'Metal') {
                            const absorb = Math.floor(act * 0.3); atk.shield += absorb; Game.recordStat(atk, 'shield', absorb); UI.floatText(atk, `+${absorb}`, "ft-heal");
                        }
                        // [ìˆ˜ì •] í¡í˜ˆ: ê¸°ì´ˆ ë¶ˆ(Fire)ë§Œ ê°€ëŠ¥
                        if (k === 'Fire') {
                            const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                            const h = atk.heal(healAmt);
                            Game.recordStat(atk, 'heal', h); 
                        }
                    }
                }
            }
        } 
        else {
            if (k === 'Fire-Light') { 
                if(atk.s2Count < 5) {
                    const bonuses = [40, 30, 20, 30, 40];
                    const bonus = bonuses[atk.s2Count];
                    atk.s2Count++; 
                    atk.atk += bonus;
                    AudioSys.play('POWER_UP'); 
                    m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ğŸ”¥í­ì£¼! (ê³µê²©ë ¥ +${bonus})`;
                }
                playedSound=true; 
            }

            if (k === 'Dark-Dark') {
                atk.takeDamage(20); AudioSys.play('DEBUFF'); playedSound=true;
                if(Math.random() < 0.75) { 
                    def.addStatus('BANISH', 1); m += " (ğŸŒŒì¶”ë°© ì„±ê³µ)"; UI.floatText(def,"ì¶”ë°©!","ft-miss"); 
                    atk.atk += 10;
                } 
                else { m += " (ì¶”ë°© ì‹¤íŒ¨)"; UI.floatText(def,"ì €í•­","ft-miss"); }
            }
            else if (k === 'Water-Dark') {
                const act = def.takeDamage(Math.floor(baseAtk));
                if (act === -1) { m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ${act} í”¼í•´`; UI.floatText(def, act, "ft-dmg");
                    if(Math.random() < 0.35) { def.addStatus('FREEZE', 1); m += " (â„ï¸ë¹™ê²°)"; UI.floatText(def,"ë¹™ê²°","ft-miss"); }
                }
            }
            else if (k === 'Normal') {
                const rnd = Math.random() * 1.7 + 0.8;
                const dmg = Math.floor(baseAtk * rnd * aff.v * defMod);
                const act = def.takeDamage(dmg); 
                if (act === -1) { m += " ì£¼ì‚¬ìœ„ ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                else {
                    Game.recordStat(atk, 'dmg', act); m += ` ì£¼ì‚¬ìœ„(x${rnd.toFixed(2)}) ${act}`; this.shake(def); UI.floatText(def, act, "ft-dmg");
                    if(rnd > 2.0) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; }
                }
            }
            else if(s.type === 'AOE') {
                m += " (ì „ì²´ ê³µê²©!)";
                (atk.team===0?this.eTeam:this.pTeam).forEach(e => { if(!e.isDead) {
                    let indDefMod = 1.0;
                    const da = Game.calc(atk, e); 
                    const dd = Game.calc(e, atk); 
                    
                    if (da.v < 1.2) { 
                        if(dd.v===1.3) indDefMod=0.76; 
                        else if(dd.v===1.2) indDefMod=0.83;
                    }

                    const dmg = Math.floor(baseAtk * 0.8 * da.v * indDefMod);
                    const act = e.takeDamage(dmg, k.startsWith('Fire'));
                    Game.recordStat(atk, 'dmg', act);
                    if(act !== -1) { 
                        this.shake(e); UI.floatText(e, act, "ft-dmg"); 
                        if(k==='Earth-Light') e.addStatus('BLIND', 2); 
                        if(k==='Metal-Dark'&&Math.random()<0.15) e.addStatus('STUN', 1);
                        if(k==='Fire' && Math.random()<0.25) e.addStatus('BURN', 2, 0, atk); 
                        // [ìˆ˜ì •] í¡í˜ˆ: ê¸°ì´ˆ ë¶ˆ(Fire)ë§Œ ê°€ëŠ¥
                        if (k === 'Fire') {
                            const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                            const h = atk.heal(healAmt);
                            Game.recordStat(atk, 'heal', h); 
                        }
                    } else {
                        UI.floatText(e, "MISS", "ft-miss");
                    }
                }});
            } 
            else if(s.type === 'HEAL') { 
                AudioSys.play('HEAL'); playedSound=true;
                (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{
                    if(!a.isDead) {
                        const h = a.heal(110);
                        Game.recordStat(atk, 'heal', h); 
                    }
                });
                m+=" (ì•„êµ° ì „ì²´ íšŒë³µ +110)"; 
                if(k==='Water' && Math.random() < 0.2) {
                    const lowest = (atk.team===0?this.pTeam:this.eTeam).filter(a=>!a.isDead).sort((a,b)=>a.hp-b.hp)[0];
                    if(lowest) { 
                        const h = lowest.heal(50); 
                        Game.recordStat(atk, 'heal', h); 
                        m+=` (ğŸ’§ëŒ€ë°•í +50)`; UI.floatText(lowest, "+50", "ft-heal"); 
                    }
                }
            }
            else if(s.type === 'BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(k !== 'Fire-Light') m += " (ì•„êµ° ì „ì²´ ê°•í™”)";
                
                const allies = atk.team===0?this.pTeam:this.eTeam;
                if(k==='Light') allies.forEach(a=>{if(!a.isDead) { 
                    a.shield=Math.min(300, a.shield+70); 
                    a.addStatus('LIGHT_MIGHT', 1); 
                    Game.recordStat(atk,'shield',70); 
                }}); 
                else if(k==='Light-Light') allies.forEach(a=>{if(!a.isDead) {a.shield=Math.min(300, a.shield+50); Game.recordStat(atk,'shield',50); a.cleanse();}}); 
                else if(k==='Tree-Light') allies.forEach(a=>{if(!a.isDead) {
                    const h = a.heal(70); 
                    Game.recordStat(atk, 'heal', h); 
                    a.cleanse();
                }});
            } 
            else if(s.type === 'TARGET_BUFF' || s.type === 'SELF_BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(def) { 
                    if(k==='Tree') { 
                        const h = def.heal(150); 
                        Game.recordStat(atk, 'heal', h); 
                        def.cleanse(); m+=` ì¹˜ìœ /ì •í™”`; 
                    }
                    else if(k==='Tree-Dark') { 
                        if (atk.id === def.id) {
                        } else {
                            atk.linkedAllyId = def.id; def.addStatus('BIND', 99); atk.resist += 0.3; m+=` ê²°ì†! (í­ì£¼ëŒ€ê¸°/ì €í•­â†‘)`; 
                        }
                    }
                    else if(k==='Water-Light') {
                        (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{if(!a.isDead) a.addStatus('EVADE', 2)});
                        const healAmt = Math.floor((def.maxHp - def.hp) * 0.15); 
                        const h = def.heal(healAmt); 
                        Game.recordStat(atk, 'heal', h); 
                        m += ` (íšŒí”¼ì¦ê°€+ì¹˜ìœ )`;
                    }
                }
            } 
            else if(s.type === 'DEBUFF') {
                AudioSys.play('DEBUFF'); playedSound=true;
                if(k==='Metal') { 
                    // [ìˆ˜ì •] ë„ë°œì€ 1ëª…ì—ê²Œë§Œ ìœ ì§€ (ê¸°ì¡´ ë„ë°œ ì œê±°)
                    const enemies = (atk.team===0?this.eTeam:this.pTeam);
                    enemies.forEach(e => {
                        e.status = e.status.filter(s => s.type !== `PROVOKED_BY_${atk.id}`);
                    });
                    
                    def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk); 
                    atk.shield+=15; Game.recordStat(atk,'shield',15); m += ` ë„ë°œ! (ì‰´ë“œ+15)`; 
                }
                else if(k==='Dark') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{if(!e.isDead){ e.addStatus('ATK_DOWN', 2); e.shield=Math.floor(e.shield*0.7); if(Math.random()<0.2) e.dispel(); }}); m+=" (ì  ì „ì²´ ê³µí¬)"; }
                else if(k==='Metal-Light') { 
                    (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{
                        if(!e.isDead) { e.addStatus('POISON', 3); }
                    }); 
                    m+=" (ê´‘ì—­ ì¤‘ë… ì‚´í¬)"; 
                }
                else if(k==='Earth-Light') { 
                    def.addStatus('TRAP', 2); 
                    def.addStatus('HEAL_DOWN', 2); 
                    m+=` ëª¨ë˜ì§€ì˜¥(ì†ë°•+ì¹˜ìœ ê°ì†Œ)`; 
                }
            } 
            else if(s.type === 'NUKE' || s.type === 'NUKE_PER' || s.type === 'ATK') {
                let dmg = 0;
                if (s.type === 'NUKE_PER') dmg = Math.floor(baseAtk * 1.2 * aff.v * defMod + def.maxHp * 0.1);
                else if (k === 'Earth-Dark') dmg = Math.floor(baseAtk * 2.5 * aff.v * defMod);
                else dmg = Math.floor(baseAtk * 2.0 * aff.v * defMod);

                if(k==='Earth-Dark') atk.addStatus('STUN', 2, 0, atk);
                
                const act = def.takeDamage(dmg, k.startsWith('Fire'));
                Game.recordStat(atk, 'dmg', act);
                if(act!==-1) { 
                    m+=` ${act} í­ë°œì  í”¼í•´!`; this.shake(def); UI.floatText(def, act, "ft-crit"); 
                    AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true;
                    // [ìˆ˜ì •] í¡í˜ˆ: ê¸°ì´ˆ ë¶ˆ(Fire)ë§Œ ê°€ëŠ¥
                    if (k === 'Fire') {
                        const healAmt = Math.min(30, Math.floor(act * 0.2)); 
                        const h = atk.heal(healAmt);
                        Game.recordStat(atk, 'heal', h); 
                    }
                } else {
                    m+=" ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss");
                    AudioSys.play('MISS');
                }
            }
        }
        
        if (!playedSound) AudioSys.play('SKILL');

        if(k === 'Metal-Dark' && sIdx===2 && Math.random() < 0.1) {
            const aliveE = (atk.team===0?this.eTeam:this.pTeam).filter(e=>!e.isDead);
            if(aliveE.length>0) { const target = aliveE[Math.floor(Math.random()*aliveE.length)]; const extra = Math.floor(baseAtk); 
            const act = target.takeDamage(extra, false);
            if(act !== -1) {
                Game.recordStat(atk,'dmg',extra); m += `<br>âš¡ ê³¼ë¶€í•˜! +${extra}`; UI.floatText(target, extra, "ft-crit"); 
            } else {
                UI.floatText(target, "MISS", "ft-miss");
            }
          }
        }
        this.log(m); this.endTurn();
    },

    endTurn: function() {
        if(this.isOver) return; 
        if(this.watchdog) clearTimeout(this.watchdog);
        
        const u = this.queue[this.curr]%2===0 ? this.pTeam[this.queue[this.curr]/2] : this.eTeam[(this.queue[this.curr]-1)/2];
        if(u && !u.isDead) u.decayStatus();

        if (this.curr === 0 && this.turnCount > 20) {
            [...this.pTeam, ...this.eTeam].forEach(u => {
                if(!u.isDead) u.atk += 10;
            });
            this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
        }

        [...this.pTeam, ...this.eTeam].forEach(u=>{if(u.hp<=0) this.die(u)});
        this.curr = (this.curr+1)%6;
        if(this.curr===0) this.turnCount++;
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1500);
    },

    calc: (a,d) => {
        let v = 1.0;
        let t = '';
        if(a.isNormal) {
            if(d.isNormal || d.isEnhanced) { v=1.2; t='(ê°•íƒ€)'; }
        } else {
            const w={'Fire':['Metal','Tree'],'Water':['Fire','Metal'],'Tree':['Water','Earth'],'Metal':['Tree','Earth'],'Earth':['Fire','Water']};
            const ew={'Light':['Dark'],'Dark':['Light']};
            if(!d.isNormal){ 
                if(w[a.base]?.includes(d.base)||ew[a.base]?.includes(d.base)) { v=1.2; t='(ì•½ì )'; }
            }
        }
        if(v===1.2 && a.extra && d.extra && ((a.extra==='Light'&&d.extra==='Dark')||(a.extra==='Dark'&&d.extra==='Light'))) { v=1.3; t='(ì¹˜ëª…íƒ€!)'; }
        return {v, t};
    },
    
    die: function(u) { 
        if(u.isDead) return; 
        u.isDead=true; u.hp=0; u.status=[]; 
        Game.log(`${u.name} íƒˆë½`); 
        
        const allies = u.team===0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base==='Tree' && a.extra==='Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.thornStack += 0.3; thorn.atk += 20; thorn.linkedAllyId = -1; 
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê´‘ì—­ë…)`);
            const enemies = u.team===0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => { if(!e.isDead) e.addStatus('POISON', 1, 0); });
            UI.floatText(thorn, "RAGE!", "ft-crit"); 
        });
    },
    endCheck: function() {
        const pd=this.pTeam.every(u=>u.isDead), ed=this.eTeam.every(u=>u.isDead);
        if(pd||ed) { 
            this.isOver = true; 
            if(this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN'); 
            UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)"); 
            return true; 
        } 
        return false;
    },
    log: function(m) { const b=document.getElementById('logs'); const d=document.createElement('div'); d.className='log-entry'; d.innerHTML=m; b.appendChild(d); b.scrollTop = b.scrollHeight; },
    
    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for(let i=0; i<6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx]; 
            const isP = qId % 2 === 0;
            const uIdx = isP ? qId/2 : (qId-1)/2;
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if(u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }

        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if(!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });

            team.forEach((u) => {
                const cardId = tid===0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);

                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }

                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;

                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;
                
                let tags = u.status.map(s => {
                    let c='tag'; 
                    const map = {'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn','BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown','BLIND':'blind','ATK_BUFF':'growth','IMMUNITY':'immunity','HEAL_DOWN':'healdown','LIGHT_MIGHT':'atkup'};
                    if(s.type.includes('PROVOKED')) c+=' taunt';
                    else if(s.type.startsWith('KARMA_VICTIM')) c+=' karma';
                    else if(map[s.type]) c+=` ${map[s.type]}`;
                    
                    let txt = s.type;
                    const tMap = {'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ','TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…','ATK_BUFF':'í­ì£¼','IMMUNITY':'ë©´ì—­','HEAL_DOWN':'ì¹˜ìœ â†“','LIGHT_MIGHT':'ê³µê²©â†‘'};
                    if(s.type.includes('PROVOKED')) txt='ë„ë°œ';
                    else if(s.type.startsWith('KARMA_VICTIM')) txt='ğŸ‘ï¸ì—…ë³´';
                    else if(tMap[s.type]) txt = tMap[s.type];

                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');

                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;

                let bgClass = `bg-${u.base}`;
                if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if(u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || ''; 

                const innerHTML = `
                    <div class="tag-container">${tags}</div>
                    <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div>
                    <div class="unit-name">${u.name.split(' ')[0]} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div>
                    <div class="status-bar"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div>
                    <div style="font-size:10px; margin-top:3px; color:#aaa;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div>
                `;
                if(d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0); draw('enemy-row', this.eTeam, 1);
    },
    shake: function(u) { const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`; const el = document.getElementById(id); if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); } }
};

window.onload = function() { Game.init(); };
</script>
</body>
</html>
