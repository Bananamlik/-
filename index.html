<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v12.1 Fixed</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.8), inset 0 -3px 6px rgba(0, 0, 0, 0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body {
            margin: 0;
            background-color: var(--bg-main);
            background-image: var(--paw-pattern);
            background-size: 80px 80px;
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: 0.3s;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
        .screen-shake {
            animation: jelly-bounce 0.5s both;
        }

        @keyframes jelly-bounce {
            0% { transform: scale(1, 1); }
            30% { transform: scale(1.15, 0.85); }
            40% { transform: scale(0.9, 1.1); }
            50% { transform: scale(1.05, 0.95); }
            65% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); }
        }

        /* ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ */
        button {
            font-family: var(--font-main);
            border-radius: 25px;
            border: none;
            background: #fff;
            color: #777;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-radius: 20px;
            pointer-events: none;
        }

        button:active {
            transform: translateY(3px) scale(0.98);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .btn-restart {
            padding: 8px 12px;
            font-size: 14px;
            color: var(--accent);
        }

        .btn-restart:hover {
            background: #fff0f5;
        }

        .mute-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #eee;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: 0.2s;
        }

        .mute-btn:active {
            transform: scale(0.9);
        }

        .mute-btn.muted {
            background: #ffebee;
            color: #e57373;
            border-color: #ffcdd2;
        }

        /* ë ˆì´ì•„ì›ƒ */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden;
        }

        #selection-screen {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        #battle-screen {
            display: none;
            padding: 5px;
            height: 100%;
            justify-content: space-between;
        }

        /* ì˜ì›… ì¹´ë“œ (ì„ íƒ í™”ë©´) */
        .hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            overflow-y: auto;
            padding: 5px;
            flex: 1;
        }

        .hero-card {
            background: #fff;
            border-radius: 20px;
            padding: 6px;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05), inset 0 0 0 3px #fce4ec;
            position: relative;
            min-height: 100px;
            justify-content: center;
        }

        .hero-card:active {
            transform: scale(0.95);
        }

        .hero-card.selected {
            background: #e1bee7;
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }

        .hero-card.selected::after {
            content: 'ğŸ¾';
            position: absolute;
            top: -10px;
            right: -5px;
            background: var(--accent);
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            z-index: 5;
            border: 2px solid #fff;
        }

        /* ì „íˆ¬ ìœ ë‹› (Battle Unit) */
        .field-row {
            flex: 1;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            perspective: 1000px;
            padding: 5px 0;
            min-height: 0;
        }

        .unit {
            width: 30vw;
            max-width: 130px;
            background: #fff;
            border-radius: 20px;
            padding: 8px 4px;
            position: relative;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: default;
            box-shadow: inset 0 4px 10px rgba(255, 255, 255, 1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 110px;
            justify-content: flex-end;
            border: 2px solid #f8bbd0;
            flex-shrink: 1;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ê°ì„± ìŠ¤íƒ€ì¼ (Super Hero) */
        .unit.super-hero {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.5) !important;
            animation: super-pulse 1.5s infinite alternate;
            z-index: 10;
        }

        @keyframes super-pulse {
            0% { box-shadow: 0 0 10px #ffb300; border-color: #ffb300; }
            100% { box-shadow: 0 0 25px #ff6f00; border-color: #ffca28; }
        }

        .unit.active-turn {
            border-color: var(--accent);
            transform: translateY(-12px) scale(1.05);
            z-index: 5;
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3);
        }

        .unit.target-enemy:hover {
            border-color: #ff7043;
            background: #ffebee;
            cursor: crosshair;
            transform: scale(1.05) rotate(2deg);
        }

        .unit.target-ally:hover {
            border-color: #66bb6a;
            background: #e8f5e9;
            cursor: pointer;
            transform: scale(1.05) rotate(-2deg);
        }

        .unit.target-aoe {
            border-color: #ff7043;
            background: #ffebee;
            animation: jelly-bounce 1s infinite;
            cursor: pointer;
        }

        .unit.dead {
            opacity: 0.6;
            filter: grayscale(1);
            pointer-events: none;
            border-color: #cfd8dc;
            transform: scale(0.9) rotate(5deg);
            box-shadow: none;
        }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-bottom: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            color: #fff;
            position: relative;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            border: 3px solid #fff;
            flex-shrink: 0;
        }

        .mini-attr-box {
            position: absolute;
            bottom: -2px;
            right: -2px;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 12px;
            border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mini-icon { font-size: 10px; line-height: 1; }

        .elec-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ffeb3b;
            color: #f57f17;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        .status-bar {
            width: 85%;
            height: 10px;
            background: #eceff1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .hp-fill {
            height: 100%;
            background: var(--hp-high);
            border-radius: 10px;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
        }

        .shield-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--shield);
            opacity: 0.8;
            border-radius: 10px;
            transition: width 0.3s;
        }

        .control-panel {
            flex: 0 0 auto;
            max-height: 45vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px 30px 0 0;
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            border-top: 5px solid #ff80ab;
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        .cp-header {
            padding: 8px 15px;
            background: #fff8e1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px dashed #ffe082;
            font-size: 14px;
        }

        .timeline-container {
            height: 40px;
            background: #fff;
            border-bottom: 2px dashed #ffcdd2;
            display: flex;
            align-items: center;
            padding: 0 10px;
            overflow: hidden;
            gap: 5px;
            flex-shrink: 0;
        }

        .timeline-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
            margin-right: 5px;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); }
        }

        .tl-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            border: 2px solid #eee;
            position: relative;
            flex-shrink: 0;
            transition: 0.3s;
            background: #fff;
            box-shadow: 0 2px 0 #ddd;
        }

        .tl-node.curr {
            border-color: var(--accent);
            transform: scale(1.3);
            z-index: 2;
            border-width: 3px;
            animation: active-pulse 1.5s infinite;
        }

        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            border-bottom: 2px solid #f0f0f0;
            background: #fff;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            min-height: 50px;
            max-height: 120px;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            background: #fafafa;
            border-radius: 10px;
            word-break: keep-all;
            border-left: 3px solid #eee;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .log-ally { color: #29b6f6; font-weight: bold; }
        .log-enemy { color: #ff7043; font-weight: bold; }
        .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }

        /* [UI ê°œì„ ] ë†’ì´ ìœ ë™ì  ë³€ê²½ (ì˜ë¦¼ ë°©ì§€) */
        .btn-group {
            display: flex;
            min-height: 80px;
            height: auto;
            flex-shrink: 0;
            padding: 5px;
            gap: 5px;
            background: #fff5f8;
        }

        .skill-btn {
            flex: 1;
            border: none;
            background: #fff;
            border-radius: 15px;
            cursor: pointer;
            transition: 0.2s;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 4px;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
        }

        .skill-btn::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            border-radius: 15px;
            pointer-events: none;
        }

        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }

        .passive-panel {
            background: #e0f2f1;
            padding: 5px 10px;
            font-size: 11px;
            color: #00695c;
            display: flex;
            align-items: center;
            border-radius: 10px;
            margin: 4px 10px;
            border: 1px solid #b2dfdb;
            flex-shrink: 0;
        }

        .passive-icon { margin-right: 5px; font-size: 14px; }

        .btn-start {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 20px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 5px 0 #c2185b, 0 10px 15px rgba(0, 0, 0, 0.15);
            transition: 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(5px); box-shadow: 0 0 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-rnd {
            background: #b39ddb;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            box-shadow: 0 4px 0 #7e57c2;
        }

        .btn-rnd:active { transform: translateY(4px); box-shadow: none; }

        .tag-container {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
            max-height: 36px;
            overflow: hidden;
            align-content: flex-start;
        }

        .tag {
            padding: 2px 4px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 1px;
            white-space: nowrap;
            height: 14px;
            display: flex;
            align-items: center;
        }

        .tag.poison { background: #ab47bc; }
        .tag.stun { background: #ffd54f; color: #5d4037; }
        .tag.freeze { background: #29b6f6; }
        .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; }
        .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; }
        .tag.bind { background: #66bb6a; }
        .tag.trap { background: #d4e157; color: #5d4037; }
        .tag.atkdown { background: #5c6bc0; }
        .tag.growth { background: #9ccc65; color: #33691e; }
        .tag.blind { background: #bdbdbd; color: #5d4037; }
        .tag.immunity { background: #fff; color: #5d4037; border: 1px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color: #fff; }
        .tag.atkup { background: #ef5350; color: #fff; }
        .tag.taunt {
            background: #212121;
            color: #ff5252;
            border: 1px solid #ff1744;
            box-shadow: 0 0 4px rgba(255, 23, 68, 0.6);
            font-weight: 900;
        }
        .tag.karma {
            background: #512da8;
            color: #fff;
            border: 1px solid #d1c4e9;
            animation: jelly-bounce 2s infinite;
        }
        /* ì„ ê³µë°©ì–´ ë©´ì—­ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.start-immunity { background: #00bcd4; color: #fff; border: 1px solid #80deea; box-shadow: 0 0 5px #00e5ff; }
        /* [ì‹ ê·œ] ì„¸ë‡Œ ê´€ë ¨ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.mc-wait { background: #5e35b1; color: #fff; border: 1px solid #b39ddb; animation: jelly-bounce 2s infinite; }
        .tag.mc-ready { background: #d500f9; color: #fff; border: 2px solid #ea80fc; box-shadow: 0 0 10px #d500f9; font-weight:900; }

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color: #1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color: #5d4037; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color: #5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        /* [ë°ë¯¸ì§€ í°íŠ¸ ì„¸ë¶„í™”] */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 28px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        .ft-dmg { color: #ff7043; }
        .ft-crit { color: #ffa726; font-size: 36px; text-shadow: 2px 2px 0 #d84315; }
        .ft-heal { color: #26a69a; animation: floatUpSlow 1.2s ease-out forwards; }
        .ft-miss { color: #b0bec5; font-size: 20px; }
        .ft-weak { color: #d32f2f; font-size: 32px; font-weight: 900; animation: shake-dmg 0.4s ease-in-out; }
        .ft-resist { color: #78909c; font-size: 18px; opacity: 0.8; }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        @keyframes floatUpSlow {
            0% { transform: translate(-50%, 0); opacity: 0; }
            50% { transform: translate(-50%, -40px); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        @keyframes shake-dmg {
            0%, 100% { transform: translate(-50%, -20px); }
            25% { transform: translate(-55%, -20px); }
            75% { transform: translate(-45%, -20px); }
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 248, 225, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 35px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3);
            overflow-y: auto;
            max-height: 80vh;
            border: 5px solid #ffcc80;
            position: relative;
        }

        /* [ì»·ì‹ ] ìŠ¤íƒ€ì¼ */
        #cut-in-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cut-in-img {
            font-size: 120px;
            animation: cut-in-zoom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .cut-in-text {
            font-size: 40px;
            color: #fff;
            font-weight: 900;
            margin-top: 20px;
            animation: slide-up 0.5s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes cut-in-zoom {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes slide-up {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* [íˆ´íŒ] ìŠ¤íƒ€ì¼ */
        #tooltip-view {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 150;
            max-width: 200px;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
            text-align: left;
        }

        .tooltip-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 45vh; }
            .btn-group { min-height: 72px; height: auto; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 10px; display: block; line-height: 1.2; }
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
/* [ì‹ ê·œ] ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸° & ê°ì •í‘œí˜„ */
        .hp-preview {
            position: absolute; top: 0; right: 0; bottom: 0;
            background: rgba(255, 23, 68, 0.6); /* ë¶‰ì€ìƒ‰ ë¹—ê¸ˆ */
            z-index: 2; pointer-events: none;
            transition: width 0.2s;
            box-shadow: -2px 0 0 rgba(255,255,255,0.5);
        }
        .emote-bubble {
            position: absolute; top: -45px; left: 50%; transform: translateX(-50%);
            background: #fff; border: 3px solid #333; border-radius: 20px;
            padding: 8px 12px; font-size: 24px; z-index: 50;
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            white-space: nowrap; pointer-events: none;
        }
        @keyframes pop-in { from { transform: translateX(-50%) scale(0); } to { transform: translateX(-50%) scale(1); } }
        
        .emote-menu {
            position: absolute; display: flex; gap: 8px; 
            background: rgba(255,255,255,0.95); padding: 8px; 
            border-radius: 50px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            z-index: 100; border: 2px solid #eee;
            animation: fade-up 0.2s;
        }
        @keyframes fade-up { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
        .emote-btn { 
            font-size: 22px; cursor: pointer; transition: 0.2s; 
            width: 36px; height: 36px; border-radius: 50%; 
            display:flex; align-items:center; justify-content:center;
        }
        .emote-btn:hover { transform: scale(1.2); background: #f0f0f0; }
        /* [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (ì‹œê°„ ì •ì§€ íš¨ê³¼) */
        body.hit-stopped .unit,
        body.hit-stopped .float-text {
            animation-play-state: paused !important;
            transition: none !important;
        }
       /* [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë° íƒ€ê²© ì´í™íŠ¸ */
        .projectile {
            position: absolute;
            font-size: 24px;
            z-index: 150;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.8));
        }
        .impact-effect {
            position: absolute;
            font-size: 40px;
            z-index: 151;
            pointer-events: none;
            animation: impact-pop 0.3s ease-out forwards;
        }
        @keyframes impact-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
/* [ì‹ ê·œ] ì˜¤ë””ì˜¤ ì„¤ì • UI */
        .settings-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .settings-btn:active { transform: scale(0.9); }

        .settings-modal {
            display: none; position: absolute; top: 60px; right: 15px;
            width: 240px; background: rgba(255, 255, 255, 0.95);
            border-radius: 20px; padding: 15px; z-index: 110;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); border: 2px solid #ffcc80;
            backdrop-filter: blur(5px); flex-direction: column; gap: 10px;
        }
        .set-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; color: #5d4037; font-weight: bold; }
        .vol-slider { flex: 1; margin-left: 10px; accent-color: #ff80ab; height: 6px; }
        
        .bgm-select { display: flex; gap: 5px; margin-top: 5px; }
        .bgm-opt { 
            flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 10px; 
            background: #fff; font-size: 11px; cursor: pointer; text-align: center; color: #888;
        }
        .bgm-opt.active { background: #fff8e1; border-color: #ffb74d; color: #f57c00; font-weight: bold; }
        
        .toggle-btn {
            width: 40px; height: 20px; background: #ccc; border-radius: 20px;
            position: relative; cursor: pointer; transition: 0.3s;
        }
        .toggle-btn.on { background: #66bb6a; }
        .toggle-btn::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 16px; height: 16px; background: #fff; border-radius: 50%;
            transition: 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .toggle-btn.on::after { left: 22px; }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div>
<!-- [ì»·ì‹ ] ì˜¤ë²„ë ˆì´ -->
<div id="cut-in-overlay">
    <div class="cut-in-img" id="cut-in-emoji">ğŸ¦</div>
    <div class="cut-in-text" id="cut-in-msg">FINISH!</div>
</div>
<!-- [íˆ´íŒ] ë·° -->
<div id="tooltip-view"></div>

<div class="settings-btn" onclick="UI.toggleSettings()">ğŸµ</div>
<div id="audio-settings" class="settings-modal">
    <div class="set-row">
        <span>ë³¼ë¥¨</span>
        <input type="range" class="vol-slider" min="0" max="100" value="50" oninput="AudioSys.setMasterVolume(this.value)">
    </div>
    <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
    <div class="set-row">
        <span>ë°°ê²½ìŒì•… (BGM)</span>
        <div class="toggle-btn on" id="tog-bgm" onclick="AudioSys.toggleChannel('bgm')"></div>
    </div>
    <div class="bgm-select">
        <div class="bgm-opt active" onclick="BGM.setStyle(1, this)">ğŸ¹ í”¼ì•„ë…¸</div>
        <div class="bgm-opt" onclick="BGM.setStyle(2, this)">ğŸ» í•˜í”„</div>
        <div class="bgm-opt" onclick="BGM.setStyle(3, this)">âœ¨ ë¯¹ìŠ¤</div>
    </div>
    <hr style="border:0; border-top:1px dashed #eee; width:100%; margin:5px 0;">
    <div class="set-row">
        <span>íš¨ê³¼ìŒ (SFX)</span>
        <div class="toggle-btn on" id="tog-sfx" onclick="AudioSys.toggleChannel('sfx')"></div>
    </div>
</div>

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v12.1 Fixed (AI Crash & Save/Load)</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="UI.showCollection()">ğŸ’ Codex</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="btn-online" class="btn-start" style="flex:1; background:#7e57c2; font-size:16px;" onclick="UI.openOnlineModal()">
                ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
            </button>
            <button id="btn-start" class="btn-start" style="flex:1; font-size:16px;" onclick="Game.start()" disabled>
                âš”ï¸ ì „íˆ¬ ì‹œì‘
            </button>
        </div>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
let socket;
if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {},
        emit: () => {},
        connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ");
}

let myRole = null;
let myRoom = null;
let isOnlineMode = false;
let netRndBuffer = [];
let netRndIdx = 0;
let isReplaying = false;

// [ì¶”ê°€] ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('âš ï¸ Global Error:', {
        message: msg,
        line: lineNo,
        column: columnNo,
        error: error
    });
    
    // ê²Œì„ì´ ì´ë¯¸ ëë‚¬ê±°ë‚˜, Game ê°ì²´ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    if (typeof Game === 'undefined' || Game.isOver) return false;

    // ê²Œì„ ì¤‘ë‹¨ ë°©ì§€ (ìë™ ë³µêµ¬ ì‹œë„)
    if (Game.timer) clearTimeout(Game.timer);
    if (Game.watchdog) clearTimeout(Game.watchdog);
    
    // UIì— ì•Œë¦¼ í‘œì‹œ (Game.logê°€ ìˆë‹¤ë©´)
    if (Game.log) {
        Game.log("<span class='log-sys' style='color:red;'>âš ï¸ ì˜¤ë¥˜ ë°œìƒ! ìë™ ë³µêµ¬(í„´ ë„˜ê¸°ê¸°) ì‹œë„ ì¤‘...</span>");
    }

    // 1ì´ˆ ë’¤ ê°•ì œë¡œ í„´ì„ ë„˜ê²¨ì„œ ê²Œì„ì„ ì‚´ë¦¼
    setTimeout(() => {
        try {
            if (Game.endTurn) Game.endTurn();
        } catch(e) {
            console.error('Recovery failed:', e);
            alert("ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
        }
    }, 1000);
    
    return true; // ì—ëŸ¬ê°€ ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë¹¨ê°›ê²Œ ë„ë°°ë˜ëŠ” ê²ƒì„ ë°©ì§€
};

function getNetRandom() {
    if (isOnlineMode && isReplaying) return netRndBuffer[netRndIdx++] || Math.random();
    const val = Math.random();
    if (isOnlineMode) netRndBuffer.push(val);
    return val;
}

socket.on('gameStart', (data) => {
    isOnlineMode = true;
    myRole = data.role;
    myRoom = data.room;
    UI.closeModal();
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display = 'none';
    document.getElementById('battle-screen').style.display = 'flex';
    document.getElementById('logs').innerHTML = '';
    Game.difficulty = 'online';
    Game.mode = 'pvp';
    Game.turnCount = 1;
    Game.isOver = false;

    if (myRole === 'player2') Game.queue = [1, 0, 3, 2, 5, 4];
    else Game.queue = [0, 1, 2, 3, 4, 5];
    Game.curr = 0;
    Game.isProcessing = false;
    Game.netRndBuffer = [];
    Game.netRndIdx = 0;
    Game.isReplaying = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra);
    });
    const enemyIndices = data.enemyDeck;
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(enIds[i], 1, original.base, original.extra);
    });
    Game.render();

    // [ì„ /í›„ê³µ ë³´ì •] ì˜¨ë¼ì¸ ëª¨ë“œ: í›„ê³µì—ê²Œ ë°©ì–´ë§‰ ë¶€ì—¬
    if (myRole === 'player2') {
        Game.pTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.log("<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ ë³´ë„ˆìŠ¤: ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ìƒíƒœ!</span>");
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.eTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.timer = setTimeout(() => Game.turn(), 1000);
    }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    if (attacker) {
        netRndBuffer = data.rndBuffer;
        netRndIdx = 0;
        isReplaying = true;
        Game.execute(attacker, target, data.skillIdx, true);
        isReplaying = false;
    }
});

socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)");
    isOnlineMode = false;
});

socket.on('waiting', (msg) => {
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.innerText = "â³ " + msg;
        btn.disabled = true;
    }
});

socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.disabled = false;
        btn.innerText = "ì…ì¥í•˜ê¸° ğŸš€";
    }
});

function startOnlineGame(code) {
    AudioSys.init();
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
    }
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    socket.emit('findMatch', {
        deck: Game.selected,
        roomCode: code
    });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+30%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15/ë°ë¯¸ì§€X', type:'CC', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë°›ëŠ” í”¼í•´ MaxHP 30% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ê³µ+18/ì‰´ë“œ+30(ì˜êµ¬ì¤‘ì²©)', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'ALLY', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤<br>ìê°€ì„±ì¥ + í', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(2í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 25%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ 1íšŒ ìë™ íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.6ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ (ìœ í†µê¸°í•œ)', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2í„´ ê³µ+20, 3~6í„´ ê³µ+10, 7í„´ ì´í›„ 0' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°©', passive:'ğŸ² ë©´ì—­: í–‰ë™ ì œì–´ê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ,ì„¸ë‡Œ)ì— ê±¸ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'1.0ë°°+ì MaxHP 10%ì¶”ê°€íƒ€', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì²´ë ¥ë¹„ë¡€ ë¸Œë£¨ì €', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+ìê°€ê¸°ì ˆ(2í„´)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ/ì¹¨ë¬µ', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ê¸°ì ˆ / ì¹¨ë¬µ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²°', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.3ë°°/í•´ì œ/ìŠ¤íƒíŒŒê´´', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…(3í„´)', type:'DEBUFF', target:'ALL_ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë²„í”„ ì œê±° + ìŠ¤íƒ íŒŒê´´', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°(ì‰´ë“œë¬´ì‹œ)', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•+ì¹˜ìœ ê°ì†Œ(60%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì†ë°• + ì¹˜ìœ ê°ì†Œ', passive:null },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë°˜ì‚¬ê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì˜êµ¬ ì¦ê°€.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´120+(20%í™•ë¥ 50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì•„êµ°ëœë¤í20', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + íšŒë³µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.3ë°°/ê³µ35%â†“/ì‰´ë“œ30%íŒŒê´´', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ(1í„´)', s2:'ì •ì‹ ì§€ë°°', s2d:'HP15%ì†Œëª¨/ì  1íšŒ ì¡°ì¢…(ì„±ê³µë¥  20~45%/ìŠ¤í„´X)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ§ ', desc:'ì‹¬ì—°ì˜ ì§€ë°°ì<br>ì  ì œì–´ê¶Œ íƒˆì·¨', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ì„¸ë‡Œ ì„±ê³µë¥ ì€ ê¸°ë³¸ 20%ì´ë©°, ëŒ€ìƒì˜ ì²´ë ¥ì´ ë‚®ì„ìˆ˜ë¡ ìµœëŒ€ 45%ê¹Œì§€ ì¦ê°€í•©ë‹ˆë‹¤. ì„±ê³µ ì‹œ ë‹¤ìŒ í„´ ì ì„ 1íšŒ ì¡°ì¢…í•©ë‹ˆë‹¤. í–‰ë™ í›„ ì¦‰ì‹œ í’€ë ¤ë‚©ë‹ˆë‹¤.' }
};

// [ì‹ ê·œ] Emotion Alias Database (English)
const EMOTION_DB = {
    'Fire': { t: 'Rage', d: 'Burning instinct of destruction' },
    'Water': { t: 'Sorrow', d: 'Cold grief that freezes the heart' },
    'Tree': { t: 'Vigor', d: 'Unstoppable life force' },
    'Metal': { t: 'Coldness', d: 'Reason without emotion' },
    'Earth': { t: 'Stoicism', d: 'Unshakable calmness' },
    'Light': { t: 'Bliss', d: 'Pure joy and light' },
    'Dark': { t: 'Terror', d: 'Fear of the unknown' },
    'Normal': { t: 'Void', d: 'Emptiness unaffected by anything' },
    
    'Fire-Light': { t: 'Passion', d: 'Rage sublimated into positivity' },
    'Fire-Dark': { t: 'Madness', d: 'Uncontrollable frenzy' },
    'Water-Light': { t: 'Compassion', d: 'Sorrow that embraces others' },
    'Water-Dark': { t: 'Misery', d: 'Solidified pain and cold' },
    'Tree-Light': { t: 'Hope', d: 'A forest embracing everyone' },
    'Tree-Dark': { t: 'Obsession', d: 'Twisted love and pain' },
    'Metal-Light': { t: 'Critique', d: 'Sharp and piercing analysis' },
    'Metal-Dark': { t: 'Thrill', d: 'Hidden stimulating excitement' },
    'Earth-Light': { t: 'Tenacity', d: 'Persistence that never lets go' },
    'Earth-Dark': { t: 'Pride', d: 'Overwhelming weight of arrogance' },
    'Light-Light': { t: 'Salvation', d: 'Liberation from suffering' },
    'Dark-Dark': { t: 'Domination', d: 'Power to control minds' }
};

// [ì‹ ê·œ] Title Manager (Unlock System)
const TitleManager = {
    unlocked: JSON.parse(localStorage.getItem('et_titles_en') || '[]'),
    unlock: function(key) {
        if (!this.unlocked.includes(key)) {
            this.unlocked.push(key);
            localStorage.setItem('et_titles_en', JSON.stringify(this.unlocked));
            return true;
        }
        return false;
    }
};

const ChallengeDB = [
    { name: "ë‰´ë¹„ ì ˆë‹¨ê¸°", desc: "ë‹¨ë‹¨í•œ ì‡ (Metal)ì™€ íëŸ¬ ì¡°í•©. ë”œì´ ë¶€ì¡±í•˜ë©´ ëš«ë‹¤ê°€ ì§€ì¹©ë‹ˆë‹¤.", team: ['Metal', 'Water', 'Fire'] },
    { name: "ë¹™ê²° ì§€ì˜¥", desc: "ì–¼ë¦¬ê³ (Water-Dark) ê¸°ì ˆ(Earth)ì‹œí‚¤ëŠ” ë¬´í•œ CC ì¡°í•©.", team: ['Water-Dark', 'Earth', 'Water'] },
    { name: "íšŒí”¼ & ìœ ì§€ë ¥", desc: "ì•ˆê°œ(Water-Light)ì™€ ìˆ²(Tree)ì˜ ë¬´í•œ ìœ ì§€ë ¥ ì¢€ë¹„ ë±.", team: ['Water-Light', 'Tree', 'Light-Light'] },
    { name: "CC ë©´ì—­ & ê¹¡ë”œ", desc: "CCë¥¼ ë¬´ì‹œí•˜ëŠ” ë…¸ë§(Normal)ê³¼ ê°•ë ¥í•œ í•œë°©.", team: ['Normal', 'Earth-Dark', 'Fire-Light'] },
    { name: "í„´ ì‚­ì œ (í˜ì˜¤)", desc: "ì–´ë‘  ê°•í™”(Dark-Dark)ì˜ í„´ ìŠ¤í‚µ ì–µê¹Œ ì¡°í•©. ê¸°ë„í•˜ì„¸ìš”.", team: ['Dark-Dark', 'Earth', 'Metal-Dark'] },
    { name: "ì ˆëŒ€ ë°©ì–´", desc: "ì‰´ë“œ, ì •í™”, íë¡œ ë¬´ì¥í•˜ì—¬ ì£½ì§€ ì•ŠëŠ” í†µê³¡ì˜ ë²½.", team: ['Light-Light', 'Tree-Light', 'Metal'] },
    { name: "ë””ë²„í”„ êµ°ë‹¨", desc: "í™”ìƒ, ë…, ê³µí¬, ë°˜ì‚¬ë¡œ ë§ë ¤ ì£½ì…ë‹ˆë‹¤.", team: ['Fire-Dark', 'Metal-Light', 'Dark'] },
    { name: "ì§€ì§„ ì„¤ê³„ì", desc: "ë°”ìœ„(Earth-Dark)ì˜ ê¸°ì ˆì„ ì •í™”í•˜ê³  ê³µë²„í”„ë¥¼ ì£¼ëŠ” ì—°ê³„ í”Œë ˆì´.", team: ['Earth-Dark', 'Light-Light', 'Light'] },
    { name: "ìµœì¢… ë³´ìŠ¤ (Ver.1)", desc: "ê°œë°œì ê³µì¸ 0í‹°ì–´. ì •í™”+CC+í„´ìŠ¤í‚µì˜ ì™„ë²½í•œ ì¡°í™”.", team: ['Dark-Dark', 'Light-Light', 'Water-Dark'] },
    { name: "ë°¸ëŸ°ìŠ¤ íŒŒê´´ì", desc: "í˜„ì¡´ ìµœê°•ì˜ ì‚¬ê¸°ìºë§Œ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì´ê¸°ë©´ ê³ ìˆ˜ ì¸ì •.", team: ['Dark-Dark', 'Light-Light', 'Metal'] }
];

const Common = {
    logAction: function(game, type, source, target, value, extra='') {
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else { msg = `[${source.name.split(' ')[0]}] ${extra}`; }
        game.log(msg);
    },
    basicAttack: function(atk, def, game) {
        AudioSys.play('HIT');
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); UI.floatText(atk, "BLINDED", "ft-miss"); return; }
        const baseAtk = atk.getAtk();
        const aff = (def && def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * 1.0 * aff.v * blindMod);
        const act = def.takeDamage(dmg, false, false, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) {
            Common.logAction(game, 'dmg', atk, def, act, aff.t);
            const isCrit = (act >= 200) || (atk.isNormal && def.isNormal && act > baseAtk);
            let type = isCrit ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type);
            if (isCrit || aff.v > 1.0) { 
                AudioSys.play('CRITICAL'); 
                UI.screenShake(); 
                UI.hitStop(150); // âš¡ íˆíŠ¸ ìŠ¤í†± ì¶”ê°€! (0.15ì´ˆ ë©ˆì¶¤)
            } else {
                game.shake(def);
            }
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.20));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else {
            Common.logAction(game, 'miss', atk, def, 0); UI.floatText(def, "MISS", "ft-miss");
        }
    },
    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { UI.floatText(atk, "BLINDED", "ft-miss"); Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); return -1; }
        const baseAtk = atk.getAtk();
        const aff = (def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * mult * aff.v);
        const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) { 
            let type = act>=200 ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type); 
            game.shake(def); 
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.20));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else { 
            UI.floatText(def, "MISS", "ft-miss"); 
        }
        return act;
    },
    // [ìˆ˜ì •] ì„¸ë‡Œ ìƒíƒœì¼ ë•Œ í”¼ì•„ì‹ë³„ ë°˜ì „ ë¡œì§ (ê´‘ì—­ê¸° ë²„ê·¸ ìˆ˜ì •)
    forEachAlly: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì ì´ ë‚´ ì•„êµ°
        }
        const team = effectiveTeam === 0 ? game.pTeam : game.eTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    },
    forEachEnemy: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (game.isMindControlling && unit.id === game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì›ë˜ ì•„êµ°ì´ ì 
        }
        const team = effectiveTeam === 0 ? game.eTeam : game.pTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    }
};

const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.6, game, false, true);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) def.addStatus('BURN', 2, 0, atk);
            } else {
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.25) e.addStatus('BURN', 2, 0, atk);
                });
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    let amt = 120;
                    if (game.netRandom() < 0.2) {
                        amt += 50;
                        UI.floatText(a, "Lucky!", "ft-crit");
                    }
                    const h = a.heal(amt);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
                return false;
            }
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê´‘í•©ì„± ğŸŒ¿`);
                AudioSys.play('POWER_UP');
                atk.atk += 18;
                atk.shield += 30;
                atk.growthStack = (atk.growthStack || 0) + 1;
                atk.addStatus('GROWTH', 99);
                game.recordStat(atk, 'shield', 30);
                UI.floatText(atk, "ì„±ì¥", "ft-heal");
                Common.logAction(game, 'shield', atk, atk, 30, "(ì„±ì¥)");
                return false;
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                const h = def.heal(150);
                def.cleanse();
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(ì •í™”)");
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const absorb = Math.floor(act * 0.3);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸª¨`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if (game.netRandom() < 0.25) def.addStatus('STUN', 1, 0, atk);
                    else if (game.netRandom() < 0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u => !u.isDead).length;
                const eAlive = game.eTeam.filter(u => !u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, mult, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 70;
                    const existing = a.status.find(s => s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    a.addStatus('LIGHT_MIGHT', 2, nextVal);
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.3, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s => s.type === 'ATK_DOWN');
                        e.status = e.status.filter(s => s.type !== 'ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear ? 35 : 20, atk);
                        if (e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                if (atk.hp > 30) {
                    atk.hp -= 30;
                    UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                    if (target) {
                        target.shield += 60;
                        game.recordStat(atk, 'shield', 60);
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì²­ì—¼ (í¡í˜ˆë¶€ì—¬)`);
                AudioSys.play('POWER_UP');
                Common.forEachAlly(atk, game, (a) => a.addStatus('LIFESTEAL_BUFF', 2));
                return false;
            } else {
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                Common.forEachAlly(atk, game, (a) => a.addStatus('ATK_BUFF_SMALL', 1));
                return false;
            }
        }
    },
    'Water-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.3) {
                        def.addStatus('BLIND', 1, 0, atk);
                        game.log(" (ì‹¤ëª…!)");
                    }
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ ğŸŒ«ï¸`);
                AudioSys.play('HEAL');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt);
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id !== atk.id) a.addStatus('EVADE', 2);
                });
                return false;
            }
        }
    },
    'Tree-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                const act = Common.applyDamage(atk, def, 1.2, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const alive = allies.filter(a => !a.isDead);
                    if (alive.length > 0) {
                        const t = alive[Math.floor(game.netRandom() * alive.length)];
                        const h = t.heal(20);
                        game.recordStat(atk, 'heal', h);
                        Common.logAction(game, 'heal', atk, t, h, "(ëœë¤í)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.cleanse();
                    const h = a.heal(70);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT'];
                const hadBuff = def.status.some(s => buffs.includes(s.type));
                def.status = def.status.filter(s => !buffs.includes(s.type));
                if (hadBuff) UI.floatText(def, "í•´ì œ", "ft-miss");
                let reduced = false;
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) {
                    def.s2Count--;
                    def.atk -= 20;
                    reduced = true;
                }
                if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) {
                    def.elecStacks--;
                    def.atk -= 10;
                    reduced = true;
                }
                if (def.getKey() === 'Tree' && def.growthStack > 0) {
                    def.growthStack--;
                    def.atk -= 18;
                    def.shield = Math.max(0, def.shield - 30);
                    reduced = true;
                }
                if (reduced) {
                    game.log(" (ğŸ“‰ìŠ¤íƒ ë‹¤ìš´)");
                    UI.floatText(def, "ìŠ¤íƒ-1", "ft-miss");
                }
                const act = Common.applyDamage(atk, def, 0.3, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => e.addStatus('POISON', 3, 0, atk));
            }
        }
    },
    'Earth-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game, true);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "(ì‰´ë“œë¬´ì‹œ)");
            } else {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                def.addStatus('TRAP', 2, 0, atk);
                def.addStatus('HEAL_DOWN', 2, 0, atk);
            }
        }
    },
    'Water-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => e.addStatus('BURN', 2, 0, atk));
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    const extra = Math.floor(def.maxHp * 0.1);
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act + extra, "(ì²´ë ¥ë¹„ë¡€)");
                } else {
                    Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (atk.elecStacks < 3) {
                        atk.elecStacks++;
                        atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                const act = Common.applyDamage(atk, def, 2.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (atk.hasStatus('IMMUNITY')) {
                    atk.status = atk.status.filter(s => s.type !== 'IMMUNITY');
                    UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss");
                }
                const ex = atk.status.find(s => s.type === 'STUN');
                if (ex) ex.turn = 2;
                else atk.status.push({
                    type: 'STUN',
                    turn: 2,
                    val: 0
                });
                UI.floatText(atk, "ğŸ’¤íœ´ì‹", "ft-miss");
                game.log("(ë°˜ë™:íœ´ì‹)");
            }
        }
    },
    'Light-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 50;
                    a.cleanse();
                    game.recordStat(atk, 'shield', 50);
                    Common.logAction(game, 'shield', atk, a, 50, "(ì •í™”)");
                });
                return false;
            }
        }
    },
'Dark-Dark': {
    useSkill: function(atk, def, sIdx, game) {
        if (sIdx === 0) Common.basicAttack(atk, def, game);
        else if (sIdx === 1) {
            game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`); // âœ… ê´„í˜¸ () í•„ìš”
            const act = Common.applyDamage(atk, def, 0.9, game);
            if (act !== -1) {
                Common.logAction(game, 'dmg', atk, def, act, "");
                def.addStatus('SILENCE', 1, 0, atk);
            }
        } else {
            // âœ… ì˜¨ë¼ì¸ ëª¨ë“œ ì²´í¬ ì¶”ê°€
            if (isOnlineMode) {
                game.log("<span class='log-sys'>âš ï¸ ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œëŠ” ì„¸ë‡Œë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>");
                UI.floatText(atk, "ì˜¨ë¼ì¸ì œí•œ", "ft-miss");
                return;
            }
            
            game.log(`<b>[${atk.name}]</b> ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ ğŸ§ `); // âœ… í•œ ë²ˆë§Œ
            
            // [ì œì•½ 1] ì´ë¯¸ ëˆ„êµ°ê°€ë¥¼ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
            if (game.isMindControlling) {
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                return;
            }
            
            // [ì œì•½ 2] ë©´ì—­ ì²´í¬
            if (def.getKey() === 'Dark-Dark' || def.hasStatus('IMMUNITY') || (def.isNormal && !def.extra)) {
                game.log("<span class='log-sys'>ğŸš« ì •ì‹  ì§€ë°°ê°€ í†µí•˜ì§€ ì•ŠëŠ” ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                UI.floatText(def, "ë©´ì—­", "ft-miss");
                return;
            }

            // 1. ì½”ìŠ¤íŠ¸ ì§€ë¶ˆ
            const cost = Math.floor(atk.hp * 0.15);
            atk.hp = Math.max(1, atk.hp - cost);
            UI.floatText(atk, `HPì†Œëª¨(-${cost})`, "ft-miss");
            
            // 2. í™•ë¥  ê³„ì‚°
            const missingPct = 1.0 - (def.hp / def.maxHp);
            const chance = 0.20 + (missingPct * 0.25);

            if (game.netRandom() < chance) {
                def.addStatus('MC_WAIT', 1, 0, atk, true); 
                game.log(` ğŸŒ€ <b>[${def.name}]</b> ì •ì‹  ì§€ë°° ì‹œì‘! (1í„´ í›„ ìŠ¤í‚µ, ê·¸ ë‹¤ìŒ ì¡°ì¢…)`);
                UI.floatText(def, "ì„¸ë‡Œ ëŒ€ê¸°", "ft-crit");
                AudioSys.play('DEBUFF');
            } else if (def.hasStatus('MC_WAIT') || def.hasStatus('MC_READY')) {
                // ì´ë¯¸ ê±¸ë ¤ìˆëŠ” ê²½ìš°
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì •ì‹  ì§€ë°°ê°€ ì§„í–‰ ì¤‘ì¸ ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                UI.floatText(def, "ì¤‘ë³µë¶ˆê°€", "ft-miss");
            } else {
                game.log(" (ì •ì‹  ì§€ë°° ì‹¤íŒ¨)");
                UI.floatText(def, "ì €í•­", "ft-miss");
            }
        }
    }
}
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id;
        this.team = team;
        this.base = base;
        this.extra = extra;
        this.maxHp = 600;
        if (base === 'Tree' && extra === 'Dark') this.maxHp = 700;
        if (base === 'Fire' && extra === 'Light') this.maxHp = 650;
        this.hp = this.maxHp;
        this.evadeTriggered = false;
        this.revengeAtk = 0;
        this.shield = (base === 'Metal' && !extra) ? 100 : 0;

        if (this.team === 1 && typeof Game !== 'undefined' && Game.difficulty === 'hell') {
            this.atk = 70;
        } else {
            this.atk = 55 + (id * 7 % 15);
        }

        this.status = [];
        this.isDead = false;
        this.thornStack = 0;
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.growthStack = 0;
        this.resist = 0;
        this.stats = {
            dmg: 0,
            heal: 0,
            shieldGiven: 0,
            taken: 0,
            kills: 0
        };
        this.isSuper = false;
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base === 'Light' && this.extra === 'Dark') || (this.base === 'Dark' && this.extra === 'Light');
        this.isEnhanced = (this.base === this.extra && (this.base === 'Light' || this.base === 'Dark'));

        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() {
        if (this.isNormal) return 'Normal';
        if (this.isEnhanced) return `${this.base}-${this.extra}`;
        return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base;
    }

    checkAwakening() {
        if (this.isSuper) return;
        const key = this.getKey();
        const role = SKILL_DB[key].role;
        let awakened = false;
        if (role === 'nuker') {
            if (this.stats.kills >= 2 || this.stats.dmg >= 1500) awakened = true;
        } else if (role === 'tank') {
            if (this.stats.taken >= 1000) awakened = true;
        } else if (role === 'supp') {
            if ((this.stats.heal + this.stats.shieldGiven) >= 1000) awakened = true;
        }
if (awakened) {
            this.isSuper = true;
            
            // [Modified] Emotion Awakening Logic
            const emo = EMOTION_DB[key];
            if (emo) {
                const isNew = TitleManager.unlock(key);
                const titleText = `[${emo.t}] Awakened!`;
                UI.floatText(this, titleText, "ft-crit");
                
                if (isNew) {
                    setTimeout(() => {
                        Game.log(`<span class="log-crit" style="color:#d500f9;">ğŸ† New Title Unlocked: [${emo.t}]</span>`);
                        // ì•Œë¦¼ ë©”ì‹œì§€ëŠ” í•œ ë²ˆë§Œ
                        const bubble = document.createElement('div');
                        bubble.style.cssText = "position:fixed; top:20%; left:50%; transform:translate(-50%, -50%); background:rgba(0,0,0,0.8); color:#fff; padding:15px 25px; border-radius:30px; z-index:9999; font-size:18px; box-shadow:0 5px 15px rgba(0,0,0,0.3); animation:floatUp 2s forwards;";
                        bubble.innerHTML = `ğŸ’ New Emotion: <b>${emo.t}</b><br><span style='font-size:12px; color:#aaa;'>${emo.d}</span>`;
                        document.body.appendChild(bubble);
                        setTimeout(() => bubble.remove(), 2500);
                    }, 500);
                }
            } else {
                UI.floatText(this, "âš¡AWAKENING!!âš¡", "ft-crit");
            }

            AudioSys.play('AWAKEN');
            Game.render();
        }
    }

    getAtk() {
        let v = this.atk;
        if (this.base === 'Fire' && !this.extra) {
            const turn = Game.turnCount;
            if (turn <= 12) v += 20;
            else if (turn <= 36) v += 10;
        }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        const lightMight = this.status.find(s => s.type === 'LIGHT_MIGHT');
        if (lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        if (this.hasStatus('ATK_BUFF_SMALL')) v += 10;
        v = Math.max(10, v);
        const ads = this.status.filter(s => s.type === 'ATK_DOWN');
        if (ads.length > 0) {
            ads.forEach(s => {
                if (s.val > 0) v -= Math.floor(v * (s.val / 100));
                else v -= 15;
            });
        }
        return Math.max(0, v);
    }

    resetTurn() {
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
    }

    takeDamage(dmg, isFire = false, ignoreShield = false, source = null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);

        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30);
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal");
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) {
            if (Game.netRandom() < 0.40) {
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                this.status = this.status.filter(s => s.type !== 'EVADE');
                return -1;
            }
        }
        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            if (karma && !isDarkVsDark) {
                const reflectDmg = Math.floor(dmg * 0.3);
                if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null);
                    this.stats.dmg += actualReflect;
                    UI.floatText(source, reflectDmg, "ft-crit");
                }
            }
        }

        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) {
            if (this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg;
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield;
                this.shield = 0;
            }
        } else {
            hpDmg = dmg;
        }
        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            hpDmg += 10;
            this.stats.taken += 10;
            UI.floatText(this, "Crack!", "ft-crit");
        }
        this.hp = Math.max(0, this.hp - hpDmg);

        if (this.hp <= 0 && source) {
            source.stats.kills = (source.stats.kills || 0) + 1;
            if (source.isSuper && !source.isDead) {
                const allies = source.team === 0 ? Game.pTeam : Game.eTeam;
                const aliveAllies = allies.filter(a => !a.isDead);
                if (aliveAllies.length === 1 && aliveAllies[0].id === source.id) {
                    UI.showCutIn(source);
                }
            }
            if (source.checkAwakening) source.checkAwakening();
        }

        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.evadeTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        this.checkAwakening();
        return hpDmg + shieldDmg;
    }

    addStatus(type, turn, val = 0, source = null, force = false) {
        const CC_LIST = ['STUN', 'FREEZE', 'BANISH', 'SILENCE', 'SLEEP'];
        
        if (this.hasStatus('START_IMMUNITY') && !force) {
            if (CC_LIST.includes(type) || type.startsWith('PROVOKED')) { 
                UI.floatText(this, "ğŸ›¡ï¸CCë°©ì–´", "ft-miss");
                return;
            }
        }

        if (source && source.id !== this.id && !force) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            if (karma) {
                if (Game.netRandom() < 0.5) {
                    UI.floatText(this, "ë°˜ì‚¬!", "ft-crit");
                    source.addStatus(type, turn, val, null);
                    return;
                }
            }
        }
        // 1. ë…¸ë§ ë©´ì—­ ì²´í¬ (PROVOKED ì œì™¸)
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE'];
        if (this.isNormal && !force && NORMAL_IMMUNE.includes(type)) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        
        // 2. íšŒí”¼ ì²´í¬ (ë…¸ë§ë„ ê°€ëŠ¥)
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return;
                }
            }
        }

        // 3. ë„ë°œì€ ë³„ë„ ì²´í¬
        if (this.isNormal && !force && type.startsWith('PROVOKED')) {
            UI.floatText(this, "Immune", "ft-miss");
            return;
        }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY') && !force) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            if (!source || source.id !== this.id || force) {
                this.status.push({
                    type: 'IMMUNITY',
                    turn: turn + 1
                });
            }
        }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN'].includes(type)) return;
        
        if (type === 'ATK_DOWN') {
            const s = this.status.filter(s => s.type === 'ATK_DOWN');
            if (s.length < 2) {
                this.status.push({
                    type,
                    turn,
                    val,
                    sourceId: source ? source.id : -1
                });
            } else {
                const shortest = s.sort((a, b) => a.turn - b.turn)[0];
                shortest.turn = turn;
                if(source) shortest.sourceId = source.id;
            }
            return;
        }

        const idx = this.status.findIndex(s => s.type === type);
    if (idx >= 0) {
        this.status[idx].turn = turn;
        if (val !== 0) this.status[idx].val = val;
        if (source) this.status[idx].sourceId = source.id; // âœ… ê°±ì‹  ì‹œì—ë„ sourceId ì €ì¥
    } else {
        this.status.push({
            type,
            turn,
            val,
            sourceId: source ? source.id : -1 // âœ… ì‹ ê·œ ìƒì„± ì‹œ sourceId ì €ì¥
        });
    }
}
    hasStatus(type) {
        return this.status.some(s => s.type === type);
    }
    cleanse() {
        const bad = ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'KARMA_VICTIM', 'MC_WAIT', 'MC_READY'];
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM'));
    }
    dispel() {
        const buffs = ['EVADE', 'DMG_RED', 'ATK_BUFF', 'GROWTH', 'LIGHT_MIGHT'];
        const has = this.status.some(s => buffs.includes(s.type));
        this.status = this.status.filter(s => !buffs.includes(s.type));
        return has;
    }

    tickStatus() {
        let log = [];
        if (this.hasStatus('POISON')) {
            const d = this.takeDamage(35, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`);
        }
        if (this.hasStatus('BURN')) {
            const d = this.takeDamage(20, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`);
        }
        if (this.hasStatus('TRAP')) {
            const d = this.takeDamage(40, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`);
        }
        return log;
    }
    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    heal(amount) {
        if (this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4);
        const prev = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + amount);
        const diff = this.hp - prev;
        if (diff > 0) {
            UI.floatText(this, diff, 'ft-heal');
        }
        this.checkAwakening();
        return diff;
    }
}

const AudioSys = {
    ctx: null,
    masterVol: 0.5,
    bgmMuted: false,
    sfxMuted: false,

    init: function() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    
    // ğŸŸ¢ [ì¶”ê°€] ì´ ë¶€ë¶„ì´ ë¹ ì ¸ìˆì–´ì„œ ì‹¤í–‰ì´ ì•ˆ ëœ ê²ƒì…ë‹ˆë‹¤!
    resume: function() {
        this.init();
    },
    
    // [ì‹ ê·œ] ë³¼ë¥¨ ì¡°ì ˆ
    setMasterVolume: function(val) {
        this.masterVol = val / 100;
    },

    // [ì‹ ê·œ] ì±„ë„ í† ê¸€ (bgm/sfx)
    toggleChannel: function(type) {
        if (type === 'bgm') {
            this.bgmMuted = !this.bgmMuted;
            document.getElementById('tog-bgm').classList.toggle('on');
            if(this.bgmMuted) BGM.stop(); else BGM.start();
        } else {
            this.sfxMuted = !this.sfxMuted;
            document.getElementById('tog-sfx').classList.toggle('on');
        }
    },

    // ì†Œë¦¬ ì¬ìƒ (ì œê³µí•´ì£¼ì‹  ë¡œì§ í†µí•©)
    playTone: function(freq, type, duration, vol, detune = 0, isBGM = false) {
        if (!this.ctx) return;
        if (isBGM && this.bgmMuted) return;
        if (!isBGM && this.sfxMuted) return;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        if (detune !== 0) osc.detune.value = detune;

        // ë§ˆìŠ¤í„° ë³¼ë¥¨ ì ìš©
        const finalVol = vol * this.masterVol;

        // ë³¼ë¥¨ ì—”ë²¨ë¡œí”„ (ë¶€ë“œëŸ¬ìš´ ì‹œì‘ê³¼ ë)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(finalVol, t + 0.05); // Attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration); // Decay

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start(t);
        osc.stop(t + duration + 0.1);
    },

    // íš¨ê³¼ìŒ ì „ìš© ë˜í¼ (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ìš©)
    play: function(type) {
        if (this.sfxMuted) return;
        this.init();
        // ê¸°ì¡´ íš¨ê³¼ìŒ ë¡œì§ ìœ ì§€ (playTone í˜¸ì¶œ ì‹œ íŒŒë¼ë¯¸í„° ì „ë‹¬)
        switch (type) {
            case 'HIT': this.playTone(150, 'square', 0.1, 0.2); break;
            case 'CRITICAL': 
                this.playTone(800, 'sawtooth', 0.2, 0.3); 
                setTimeout(()=>this.playTone(1200, 'square', 0.1, 0.2), 50);
                break;
            case 'SKILL': this.playTone(400, 'sine', 0.3, 0.2); break;
            case 'HEAL': 
                this.playTone(600, 'sine', 0.15, 0.2);
                setTimeout(()=>this.playTone(800, 'sine', 0.3, 0.2), 150);
                break;
            case 'DEBUFF': this.playTone(300, 'sawtooth', 0.3, 0.15); break;
            case 'POWER_UP':
                this.playTone(300, 'square', 0.1, 0.15);
                setTimeout(()=>this.playTone(450, 'square', 0.1, 0.15), 100);
                break;
            case 'WIN': 
                [0,200,400,600].forEach((d,i)=> setTimeout(()=>this.playTone(523+(i*100),'triangle',0.3,0.3), d));
                break;
            case 'CUTIN': this.playTone(100, 'sawtooth', 0.8, 0.4); break;
            case 'AWAKEN': this.playTone(200, 'square', 0.5, 0.3); break;
        }
    },
    speak: function(unit) {
        if(this.sfxMuted) return;
        this.init();
        const base = 400 + (unit.id*50);
        for(let i=0; i<2; i++) {
            setTimeout(()=> this.playTone(base+(Math.random()*100-50), 'triangle', 0.08, 0.15), i*80);
        }
    }
};
// [ì‹ ê·œ] ë°°ê²½ìŒì•… ê´€ë¦¬ì (Canon in C Major - Music Box Ver.)
const BGM = {
    timer: null,
    isPlaying: false,
    style: 1, // 1:Piano, 2:Harp, 3:Mix
    state: 'NORMAL', // [ë³µêµ¬ë¨] ìƒíƒœ ë³€ìˆ˜ (NORMAL / DANGER)
    step: 0,
    
    // ìºë…¼ ë©œë¡œë”” (Extended)
    melody: [587, 554, 494, 440, 392, 370, 392, 440, 587, 0, 494, 0, 494, 554, 587, 659, 740, 587, 659, 587, 554, 494, 554, 440, 392, 440, 494, 554, 370, 440, 494, 554],
    bass:   [293, 0, 220, 0, 246, 0, 185, 0, 196, 0, 293, 0, 196, 0, 220, 0, 293, 220, 246, 293, 185, 246, 196, 220, 196, 220, 293, 220, 293, 370, 440, 554],

    start: function() {
        if (this.isPlaying) return;
        if (AudioSys.bgmMuted) return;
        this.isPlaying = true;
        this.step = 0;
        this.loop();
    },
    
    stop: function() {
        this.isPlaying = false;
        if (this.timer) clearTimeout(this.timer);
    },

    // [ë³µêµ¬ë¨] ì´ í•¨ìˆ˜ê°€ ì—†ì–´ì„œ ì—ëŸ¬ê°€ ë‚¬ìŠµë‹ˆë‹¤!
    setState: function(newState) {
        this.state = newState;
    },

    setStyle: function(num, el) {
        this.style = num;
        // UI ì—…ë°ì´íŠ¸
        document.querySelectorAll('.bgm-opt').forEach(e => e.classList.remove('active'));
        if(el) el.classList.add('active');
        
        // ì¦‰ì‹œ ë°˜ì˜ì„ ìœ„í•´ ì¬ì‹œì‘
        if (this.isPlaying) {
            this.stop();
            this.isPlaying = true;
            this.loop();
        }
    },

    loop: function() {
        if (!this.isPlaying) return;
        if (AudioSys.bgmMuted) { this.stop(); return; }

        // [ê¸°ëŠ¥ ì¶”ê°€] ìœ„ê¸° ìƒí™©(DANGER)ì´ë©´ í…œí¬ê°€ 400ms -> 250msë¡œ ë¹¨ë¼ì§
        const tempo = this.state === 'DANGER' ? 250 : 400; 
        const idx = this.step;
        const mNote = this.melody[idx];
        const bNote = this.bass[idx];

        // === 3ê°€ì§€ ìŠ¤íƒ€ì¼ ë¡œì§ ===
        if (this.style === 1) { 
            // [1. ì†Œí”„íŠ¸ í”¼ì•„ë…¸]
            if(mNote) {
                AudioSys.playTone(mNote, 'sine', 0.6, 0.3, 0, true);
                AudioSys.playTone(mNote, 'triangle', 0.6, 0.2, 0, true);
            }
            if (bNote) AudioSys.playTone(bNote, 'sine', 0.8, 0.4, 0, true);
        } 
        else if (this.style === 2) {
            // [2. í´ë˜ì‹ í•˜í”„]
            if(mNote) AudioSys.playTone(mNote, 'triangle', 0.3, 0.3, 0, true);
            if (bNote) {
                AudioSys.playTone(bNote, 'triangle', 0.4, 0.3, 0, true);
                setTimeout(() => AudioSys.playTone(bNote * 1.5, 'sine', 0.2, 0.1, 0, true), 50);
            }
        } 
        else if (this.style === 3) {
            // [3. ë¯¹ìŠ¤]
            if(mNote) {
                AudioSys.playTone(mNote, 'sine', 0.5, 0.3, 0, true); 
                AudioSys.playTone(mNote * 2, 'triangle', 0.2, 0.1, 0, true); 
            }
            if (bNote) {
                AudioSys.playTone(bNote, 'square', 0.6, 0.05, 0, true);
                AudioSys.playTone(bNote, 'sine', 0.8, 0.3, 0, true);
            }
        }

        this.step = (this.step + 1) % this.melody.length;
        this.timer = setTimeout(() => this.loop(), tempo);
    }
};

const UI = {
    toggleSettings: function() {
        const el = document.getElementById('audio-settings');
        el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
    },
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() {
        document.getElementById('modal-overlay').style.display = 'none';
    },

    // [UI ê°œì„ ] ì˜¨ë¼ì¸ ì½”ë“œ ì…ë ¥ ëª¨ë‹¬
    openOnlineModal: function() {
        if (!socket || !socket.connected) {
            alert("âš ï¸ ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n(ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” AIì™€ ëŒ€ê²°í•˜ì„¸ìš”)");
            return;
        }
        if (Game.selected.length !== 3) {
            alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        const content = `
            <div style="text-align:center;">
                <p style="color:#555; margin-bottom:15px;">ì¹œêµ¬ì™€ ê³µìœ í•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple)</p>
                <input type="text" id="modal-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥" 
                    style="font-size:20px; padding:15px; width:80%; text-align:center; border-radius:15px; border:2px solid #ddd; outline:none; font-weight:bold; color:#7e57c2;">
                <button id="modal-submit-btn" onclick="Game.submitOnline()" 
                    style="width:100%; margin-top:20px; padding:15px; background:#7e57c2; color:white; border:none; border-radius:15px; font-weight:bold; cursor:pointer; font-size:18px;">
                    ì…ì¥í•˜ê¸° ğŸš€
                </button>
            </div>
        `;
        this.showModal("ğŸŒ ì˜¨ë¼ì¸ ë§¤ì¹­", content);
        setTimeout(() => document.getElementById('modal-room-code').focus(), 100);
    },

    showGuide: function() {
        let heroList = '';
        const guideOrder = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark'];
        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if (k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if (parts.length === 2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';
            heroList += `<div class="guide-item"> <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> <div class="guide-info"> <div class="guide-name">${name}</div> <div class="guide-desc">${s.desc}</div> <div style="font-size:10px; color:#555; margin-top:2px;"> <div>S1: ${s.s1} (${s.s1d})</div> <div>S2: ${s.s2} (${s.s2d})</div> </div> </div> </div>`;
        });
        const content = `<div class="tab-header"> <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button> <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button> </div> <div id="tab-0" class="tab-content active"> <table class="chart-table"> <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr> <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr> <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr> <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr> <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr> <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr> <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr> <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr> </table> <div class="dual-chart"> <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div> <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div> </div> </div> <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;"> ${heroList} </div>`;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if (i === idx) b.classList.add('active');
            else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if (i === idx) c.classList.add('active');
            else c.classList.remove('active');
        });
    },

    // [ë°ë¯¸ì§€ í°íŠ¸] ì„¸ë¶„í™” ì ìš©
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id);
        if (!unitEl) return;
        const el = document.createElement('div');
        el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        const randomX = (Math.random() - 0.5) * 40;
        const randomY = (Math.random() - 0.5) * 20;
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px';
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    },

    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)";
        }
        banner.style.animation = 'none';
        void banner.offsetWidth;
        const duration = Game.turnCount > 5 ? '0.6s' : '1.2s';
        banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`;
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);
        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        const mvp = allUnits.sort((a, b) => (b.stats.dmg + b.stats.heal + b.stats.shieldGiven) - (a.stats.dmg + a.stats.heal + a.stats.shieldGiven))[0];
        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`;
        };
        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },

    // [íˆ´íŒ] ì •ë³´ í‘œì‹œ
    showTooltip: function(u, el) {
        const info = SKILL_DB[u.getKey()];
        const statusText = u.status.map(s => `â€¢ ${s.type} (${s.turn}í„´)`).join('<br>') || 'ì—†ìŒ';
        const html = `
            <div class="tooltip-title">${u.name} (HP: ${u.hp})</div>
            <div style="margin-bottom:5px;">${info.desc}</div>
            <div style="color:#aaa; border-top:1px solid #555; padding-top:3px; margin-top:3px;">
                <b>ìƒíƒœì´ìƒ:</b><br>${statusText}
            </div>
        `;
        const tooltip = document.getElementById('tooltip-view');
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';

        const rect = el.getBoundingClientRect();
        let top = rect.top - 100;
        let left = rect.left + rect.width / 2 - 100;
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
    },
    hideTooltip: function() {
        document.getElementById('tooltip-view').style.display = 'none';
    },

    // [ì»·ì‹ ] ì—°ì¶œ
    showCutIn: function(unit) {
        const ov = document.getElementById('cut-in-overlay');
        const em = document.getElementById('cut-in-emoji');
        const msg = document.getElementById('cut-in-msg');

        const key = unit.getKey();
        em.innerText = SKILL_DB[key].icon || ATTR[unit.base].i;
        msg.innerText = "HEROIC FINISH!";

        ov.style.display = 'flex';
        AudioSys.play('CUTIN');

        // 1.2ì´ˆ í›„ ì¢…ë£Œ
        setTimeout(() => {
            ov.style.display = 'none';
        }, 1200);
    }, 

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ë©”ë‰´ ì—´ê¸°
    showEmoteMenu: function(u, el) {
        const existing = document.querySelector('.emote-menu');
        if (existing) existing.remove();

        const menu = document.createElement('div');
        menu.className = 'emote-menu';
        const emojis = ['ğŸ‘', 'ğŸ˜¡', 'ğŸ˜±', 'ğŸ˜œ', 'ğŸ³ï¸'];
        emojis.forEach(e => {
            const btn = document.createElement('span');
            btn.className = 'emote-btn';
            btn.innerText = e;
            btn.onclick = (ev) => {
                ev.stopPropagation();
                UI.triggerEmote(u, e);
                menu.remove();
            };
            menu.appendChild(btn);
        });
        
        const rect = el.getBoundingClientRect();
        // ìœ ë‹› ë¨¸ë¦¬ ìœ„ì— í‘œì‹œ
        menu.style.top = (rect.top - 60 + window.scrollY) + 'px';
        menu.style.left = (rect.left + rect.width/2 - 100 + window.scrollX) + 'px';
        
        document.body.appendChild(menu);
        
        // ë°”ê¹¥ í´ë¦­ ì‹œ ë‹«ê¸°
        setTimeout(() => {
            document.addEventListener('click', function close() {
                if(menu.parentNode) menu.remove();
                document.removeEventListener('click', close);
            }, {once:true});
        }, 0);
    },

    // [ì‹ ê·œ] ê°ì •í‘œí˜„ ì‹¤í–‰
    triggerEmote: function(u, emoji) {
        // ìœ ë‹› ì¹´ë“œ ìœ„ì¹˜ ì°¾ê¸°
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (!el) return;
        
        const rect = el.getBoundingClientRect();
        
        // ë§í’ì„  ìƒì„± (bodyì— ì§ì ‘ ì¶”ê°€í•˜ì—¬ ìµœìƒìœ„ ë ˆì´ì–´ ë³´ì¥)
        const bubble = document.createElement('div');
        bubble.className = 'emote-bubble';
        bubble.innerText = emoji;
        
        // ìœ„ì¹˜ ì ˆëŒ€ê°’ ê³„ì‚° (ìŠ¤í¬ë¡¤ í¬í•¨)
        bubble.style.left = (rect.left + rect.width / 2) + 'px'; 
        bubble.style.top = (rect.top - 50 + window.scrollY) + 'px';
        // z-indexë¥¼ ì•„ì£¼ ë†’ê²Œ ì„¤ì •
        bubble.style.zIndex = "9999"; 
        
        document.body.appendChild(bubble);
        
        setTimeout(() => bubble.remove(), 2000);
    }, 

// [New] Emotion Codex UI
    showCollection: function() {
        const list = Object.keys(EMOTION_DB);
        let html = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:8px;">`;
        let unlockedCount = 0;

        list.forEach(key => {
            const isUnlocked = TitleManager.unlocked.includes(key);
            if (isUnlocked) unlockedCount++;
            
            const data = EMOTION_DB[key];
            const base = key.split('-')[0] === 'Normal' ? 'Normal' : key.split('-')[0];
            let bgClass = `bg-${base}`;
            if (key.includes('-') && key.split('-')[0] === key.split('-')[1]) bgClass += '-Enhanced';
            if (key === 'Normal') bgClass = 'bg-Normal';

            // Style: Unlocked vs Locked
            const style = isUnlocked 
                ? `border:2px solid #ff80ab; background:#fff; color:#333;` 
                : `background:#eee; color:#aaa; border:2px dashed #ccc; opacity:0.7;`;
            
            const icon = isUnlocked ? (SKILL_DB[key].icon || ATTR[base].i) : 'ğŸ”’';
            const title = isUnlocked ? data.t : '???';
            const desc = isUnlocked ? data.d : 'Unlock by Awakening';

            html += `
                <div style="padding:10px; border-radius:15px; display:flex; flex-direction:column; align-items:center; text-align:center; ${style}">
                    <div class="attr-icon ${isUnlocked ? bgClass : ''}" style="width:36px; height:36px; font-size:20px; margin-bottom:5px; ${!isUnlocked?'background:#ccc;':''}">${icon}</div>
                    <div style="font-weight:bold; font-size:14px; margin-bottom:3px;">${title}</div>
                    <div style="font-size:10px; line-height:1.2;">${desc}</div>
                </div>
            `;
        });
        html += `</div>`;
        
        const pct = Math.floor((unlockedCount / list.length) * 100);
        const header = `
            <div style="text-align:center; margin-bottom:15px; padding-bottom:10px; border-bottom:2px dashed #ffcdd2;">
                <h3 style="margin:0 0 5px 0; color:#ff80ab;">ğŸ’ Emotion Codex</h3>
                <div style="font-size:14px; color:#888;">
                    Collection: <b style="color:${pct===100?'#ffca28':'#5d4037'}">${unlockedCount} / ${list.length}</b> (${pct}%)
                </div>
            </div>
        `;

        this.showModal("Codex", header + html);
    },
    // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ ì• ë‹ˆë©”ì´ì…˜
    fireProjectile: function(atk, def, icon) {
        return new Promise(resolve => {
            // ìœ„ì¹˜ ê³„ì‚°
            const startId = atk.team === 0 ? `p-card-${atk.id}` : `e-card-${atk.id}`;
            const endId = def.team === 0 ? `p-card-${def.id}` : `e-card-${def.id}`;
            const sEl = document.getElementById(startId);
            const eEl = document.getElementById(endId);
            
            if (!sEl || !eEl) { resolve(); return; }

            const sRect = sEl.getBoundingClientRect();
            const eRect = eEl.getBoundingClientRect();

            // íˆ¬ì‚¬ì²´ ìƒì„±
            const p = document.createElement('div');
            p.className = 'projectile';
            p.innerText = icon;
            p.style.left = (sRect.left + sRect.width/2) + 'px';
            p.style.top = (sRect.top + sRect.height/2) + 'px';
            document.body.appendChild(p);

            // ë°œì‚¬ (ê°•ì œ ë¦¬í”Œë¡œìš° í›„ ì´ë™)
            requestAnimationFrame(() => {
                p.style.left = (eRect.left + eRect.width/2) + 'px';
                p.style.top = (eRect.top + eRect.height/2) + 'px';
            });

            // ë„ì°© í›„ ì²˜ë¦¬
            setTimeout(() => {
                p.remove();
                // íƒ€ê²© ì´í™íŠ¸
                const boom = document.createElement('div');
                boom.className = 'impact-effect';
                boom.innerText = 'ğŸ’¥';
                boom.style.left = (eRect.left + eRect.width/2) + 'px';
                boom.style.top = (eRect.top + eRect.height/2) + 'px';
                document.body.appendChild(boom);
                setTimeout(() => boom.remove(), 300);
                resolve();
            }, 400); // 0.4ì´ˆ ë¹„í–‰
        });
    },

    // [ì‹ ê·œ] íˆíŠ¸ ìŠ¤í†± (íƒ€ê²©ê° ê·¹ëŒ€í™”)
    hitStop: function(duration = 150) {
        document.body.classList.add('hit-stopped');
        setTimeout(() => {
            document.body.classList.remove('hit-stopped');
        }, duration);
    }
};

const Game = {
    // [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
    DEBUG_MODE: true, // ê°œë°œ ì¤‘ì—” true, ë°°í¬ ì‹œ falseë¡œ ë³€ê²½

    debugLog: function(msg, data) {
        if (this.DEBUG_MODE) {
            // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê°ì²´ë¡œ, ì—†ìœ¼ë©´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
            if (data) console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;', data);
            else console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;');
        }
    },
    pool: [],
    selected: [],
    pTeam: [],
    eTeam: [],
    queue: [],
    curr: 0,
    selectedSkillIdx: -1,
    timer: null,
    turnCount: 1,
    difficulty: 'normal',
    watchdog: null,
    isOver: false,
    mode: 'pve',
    isProcessing: false,
    challengeStage: 0,
    isMindControlling: null, // [ì‹ ê·œ] ì„¸ë‡Œ ì¡°ì¢… ìƒíƒœ í”Œë˜ê·¸
    currentMCCasterId: null,
	
    netRandom: function() {
        return getNetRandom();
    },

    init: function() {
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        this.isOver = false;
        this.isMindControlling = null; // ì´ˆê¸°í™”
        this.pool = [];
        this.selected = [];
        const allCombos = [{
            b: 'Metal',
            e: null
        }, {
            b: 'Tree',
            e: null
        }, {
            b: 'Fire',
            e: 'Light'
        }, {
            b: 'Water',
            e: 'Light'
        }, {
            b: 'Fire',
            e: null
        }, {
            b: 'Normal',
            e: null
        }, {
            b: 'Fire',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: null
        }, {
            b: 'Water',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Light'
        }, {
            b: 'Earth',
            e: 'Light'
        }, {
            b: 'Tree',
            e: 'Dark'
        }, {
            b: 'Water',
            e: null
        }, {
            b: 'Tree',
            e: 'Light'
        }, {
            b: 'Light',
            e: null
        }, {
            b: 'Light',
            e: 'Light'
        }, {
            b: 'Dark',
            e: null
        }, {
            b: 'Dark',
            e: 'Dark'
        }];
        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // [UI ê°œì„ ] ì˜¨ë¼ì¸ ë²„íŠ¼ì€ í•­ìƒ í™œì„±í™”, í´ë¦­ ì‹œ ëª¨ë‹¬ ì²˜ë¦¬
        const btnOnline = document.getElementById('btn-online');
        if (btnOnline) {
            btnOnline.style.backgroundColor = '#7e57c2';
        }

        this.checkMode();
    },

    // [UI ê°œì„ ] ëª¨ë‹¬ì—ì„œ ì½”ë“œ ì…ë ¥ í›„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    submitOnline: function() {
        const codeInput = document.getElementById('modal-room-code');
        const code = codeInput.value.trim();
        if (!code) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            codeInput.focus();
            return;
        }

        const btn = document.getElementById('modal-submit-btn');
        if (btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
        btn.disabled = true;
        btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";

        startOnlineGame(code);
    },

    renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block';
        grid.style.overflowY = 'auto';
        const categories = [{
            name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)",
            range: [0, 3],
            color: "#e3f2fd",
            border: "#90caf9"
        }, {
            name: "âš”ï¸ ë”œëŸ¬ (Dealer)",
            range: [4, 13],
            color: "#ffebee",
            border: "#ef9a9a"
        }, {
            name: "ğŸ§© ì§€ì› (Support)",
            range: [14, 19],
            color: "#f1f8e9",
            border: "#a5d6a7"
        }];
        categories.forEach(cat => {
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:10px; border-radius:5px; color:#455a64; text-align:left; box-sizing:border-box;`;
            header.innerText = cat.name;
            grid.appendChild(header);
            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; padding:10px 0;";
            for (let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const el = document.createElement('div');
                el.className = 'hero-card';
                el.id = `card-${i}`;
                el.innerHTML = this.renderCard(u);
                el.onclick = () => {
                    this.toggle(i, el);
                };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },
    renderCard: function(u) {
    if (!u) return '';

    let bgClass = 'bg-' + u.base;
    if (u.isEnhanced) {
        bgClass = 'bg-' + u.base + '-Enhanced';
    } else if (u.isNormal) {
        bgClass = 'bg-Normal';
    }

    const key = u.getKey();
    const info = SKILL_DB[key];
    
    if (!info) {
        console.error('SKILL_DB missing for key:', key);
        return '<div class="attr-icon bg-Normal">?</div><div style="font-weight:bold;">ERROR</div>';
    }

    const mainIcon = info.icon || (ATTR[u.base] ? ATTR[u.base].i : '?');
    const baseIcon = ATTR[u.base] ? ATTR[u.base].i : '?';
    const extraIcon = (u.extra && ATTR[u.extra]) ? ATTR[u.extra].i : '';
    const displayName = u.name ? u.name.split(' ')[0] : 'Unknown';
    const fullName = u.name || 'Unknown';
    const description = info.desc || 'ì •ë³´ ì—†ìŒ';

    let html = '<div class="attr-icon ' + bgClass + '">';
    html += mainIcon;
    html += '<div class="mini-attr-box">';
    html += '<div class="mini-icon">' + baseIcon + '</div>';
    if (extraIcon) {
        html += '<div class="mini-icon">' + extraIcon + '</div>';
    }
    html += '</div></div>';
    html += '<div style="font-weight:bold; margin-bottom:2px; font-size:15px;">' + displayName + '</div>';
    html += '<div style="font-size:11px; color:#999;">' + fullName + '</div>';
    html += '<div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">';
    html += description + '</div>';
    
    return html;
},
    toggle: function(i, el) {
        if (!el) el = document.getElementById(`card-${i}`);
        if (this.selected.includes(i)) {
            this.selected = this.selected.filter(x => x !== i);
            el.classList.remove('selected');
        } else {
            if (this.selected.length >= 3) {
                el.classList.add('shake');
                setTimeout(() => el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },
    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if (el) el.classList.remove('selected');
        });
        Game.selected = [];
        while (Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if (!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if (el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            if (this.challengeStage > maxStage) this.challengeStage = maxStage;
            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }
    },
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },

    start: function() {
        AudioSys.init();
        AudioSys.resume();
        BGM.start(); // ìŒì•… í!
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => {
            const u = this.pool[idx];
            u.id = i;
            u.team = 0;
            return u;
        });
        this.eTeam = [];
        this.isOver = false;
        const makeEnemy = (idx, b, e) => {
            const u = new Unit(idx + 3, 1, b, e);
            return u;
        };

        if (this.difficulty === 'hell') {
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            const stageData = ChallengeDB[this.challengeStage];

            // [AI ê°•í™”] ì±Œë¦°ì§€ ëª¨ë“œ ë± ìˆœì„œ ëœë¤ ì„ê¸° (ë°°ì¹˜ ì¹´ìš´í„° ë°©ì§€)
            const shuffledTeam = [...stageData.team].sort(() => Math.random() - 0.5);

            this.eTeam = shuffledTeam.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
        } else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => {
                const u = new Unit(i + 3, 1, pu.base, pu.extra);
                u.maxHp = Math.floor(u.maxHp * 1.15);
                u.hp = u.maxHp;
                u.atk = Math.floor(u.atk * 1.15);
                return u;
            });
        } else if (this.difficulty === 'easy') {
            const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
            while (this.eTeam.length < 3) {
                const b = basics[Math.floor(Math.random() * basics.length)];
                if (!this.eTeam.some(u => u.base === b)) {
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, null));
                }
            }
        } else if (this.difficulty === 'hard') {
            let bestIdx = Math.floor(Math.random() * ChallengeDB.length);
            let maxScore = -999;
            ChallengeDB.forEach((stage, idx) => {
                let score = 0;
                stage.team.forEach(key => {
                    let b, e, isN = false,
                        isEnh = false;
                    if (key === 'Normal') {
                        b = 'Normal';
                        isN = true;
                    } else {
                        const parts = key.split('-');
                        b = parts[0];
                        e = parts[1] || null;
                        if (b === e) isEnh = true;
                    }
                    const dumE = {
                        base: b,
                        extra: e,
                        isNormal: isN,
                        isEnhanced: isEnh
                    };
                    this.pTeam.forEach(p => {
                        const atkRel = this.calc(dumE, p);
                        if (atkRel.v > 1.0) score += 3;
                        const defRel = this.calc(p, dumE);
                        if (defRel.v < 1.0) score += 2;
                    });
                });
                score += Math.random();
                if (score > maxScore) {
                    maxScore = score;
                    bestIdx = idx;
                }
            });
            const targetDeck = ChallengeDB[bestIdx].team;
            this.eTeam = targetDeck.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
            this.log(`<span class='log-sys'>ğŸ”¥ ì–´ë ¤ì›€(Counter): ì ì´ ë‹¹ì‹ ì˜ ì•½ì ì„ ê°„íŒŒí–ˆìŠµë‹ˆë‹¤! (${ChallengeDB[bestIdx].name})</span>`);
        } else {
            const used = new Set();
            while (this.eTeam.length < 3) {
                const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                if (b === 'Dark' && e === 'Light') continue;
                let key = `${b}-${e}`;
                if (b === 'Light' && e === 'Dark') key = 'Normal';
                if (!used.has(key)) {
                    used.add(key);
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, e));
                }
            }
        }

        this.queue = [0, 1, 2, 3, 4, 5];
        this.curr = Math.floor(Math.random() * 6);
        this.turnCount = 1;
        this.isProcessing = false;
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('battle-screen').style.display = 'flex';
        document.getElementById('logs').innerHTML = '';
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);

        // [ì„ /í›„ê³µ ë³´ì •] í›„ê³µ íŒ€ì—ê²Œ ë©´ì—­ ë¶€ì—¬
        // queue[curr]ì´ ì„ ê³µì˜ ì²« í„´ ì¸ë±ìŠ¤.
        // ë§Œì•½ queue[curr]ì´ 0,2,4 ì¤‘ í•˜ë‚˜ë©´ PíŒ€ì´ ì„ ê³µ -> EíŒ€(1)ì—ê²Œ ë©´ì—­
        // ë§Œì•½ queue[curr]ì´ 1,3,5 ì¤‘ í•˜ë‚˜ë©´ EíŒ€ì´ ì„ ê³µ -> PíŒ€(0)ì—ê²Œ ë©´ì—­
        const firstTurnUnitId = (this.queue[this.curr] % 2 === 0 ? this.queue[this.curr] / 2 : (this.queue[this.curr] - 1) / 2 + 3);
        const firstTurnTeam = this.queue[this.curr] % 2; // 0 (PíŒ€) or 1 (EíŒ€)
        const secondTeam = firstTurnTeam === 0 ? this.eTeam : this.pTeam;

        secondTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        this.log(`<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ íŒ€(${firstTurnTeam===0?'ì êµ°':'ì•„êµ°'})ì—ê²Œ ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ë¶€ì—¬!</span>`);

        this.render();
        this.timer = setTimeout(() => this.turn(), 1000);
    },

turn: function() {
        this.isProcessing = false;
        if (this.isOver) return;
        const round = Math.ceil(this.turnCount / 6);
        const tVal = this.queue[this.curr];
        
        // 1. ìœ ë‹› ì •ì˜ (ê¸°ì¡´ ì°Œêº¼ê¸° ì˜¤ë¥˜ í•´ê²°ë¨) - ì •ìˆ˜ ë³€í™˜ ì¶”ê°€
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // 2. [ë¡œì§ ì‚­ì œë¨] ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ë˜ì–´, ì‚¬ì „ ì¤€ë¹„(MC_READY) ë‹¨ê³„ê°€ ë¶ˆí•„ìš”í•©ë‹ˆë‹¤.
        // (ì´ê³³ì— ìˆë˜ ë¬¸ë²• ì˜¤ë¥˜ ë° êµ¬ë²„ì „ ë¡œì§ì„ ì‚­ì œí–ˆìŠµë‹ˆë‹¤.)


        // 3. [ê¶Œí•œ íŒì •] ì¡°ì‘ ê¶Œí•œ ì„¤ì • (ëª¨ë“  ìœ ë‹› ê³µí†µ ë¡œì§)
        // ê¸°ë³¸ì ìœ¼ë¡œ ë‚´ íŒ€(0)ì´ë©´ ë‚´ í„´.
        let isMyTurn = (u.team === 0);
        let isPuppetTurn = false;

        // ì„¸ë‡Œ ìƒíƒœ ì²´í¬: í˜„ì¬ í„´ ìœ ë‹›ì´ ì„¸ë‡Œëœ ëŒ€ìƒì´ê³ , ì„¸ë‡Œì˜ ì£¼ì²´ê°€ 'ë‚˜'ì¸ê°€?
        if (this.isMindControlling && this.isMindControlling.id === u.id) {
            // ê°„ë‹¨ í•´ê²°: ë‚´ íŒ€ì´ ì•„ë‹Œë°(ì êµ°ì¸ë°) ì„¸ë‡Œ ë³€ìˆ˜ê°€ ì¼œì ¸ìˆë‹¤ë©´, ë‚´ê°€ ì¡°ì¢…í•˜ëŠ” ê²ƒì„.
            if (u.team !== 0) { 
                isMyTurn = true; 
                isPuppetTurn = true; 
            } else {
                // ë°˜ëŒ€ë¡œ ë‚´ ìœ ë‹›ì´ ì ì—ê²Œ ì„¸ë‡Œë‹¹í–ˆë‹¤ë©´? -> ì¡°ì‘ ê¶Œí•œ ë°•íƒˆ
                isMyTurn = false;
            }
        }

        // 4. AI ê°ì‹œì (Watchdog) ë° ì¢…ë£Œ ì²´í¬
        if (this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            this.watchdog = setTimeout(() => {
                console.log("AI Stuck. Forcing next.");
                this.endTurn();
            }, 3000);
        }
        if (this.endCheck()) return;

        // 5. [ìˆ˜ì •] í„´ ì‹œì‘ ìƒíƒœì´ìƒ ì²˜ë¦¬ (ë„íŠ¸ ë°ë¯¸ì§€ -> ì‚¬ë§ ì²´í¬ -> CC ì²´í¬)
        if (!u.isDead) {
            u.resetTurn();
            
            // 5-1. ë„íŠ¸ ë°ë¯¸ì§€ ì²˜ë¦¬ (ë§¹ë…, í™”ìƒ ë“±)
            const dotLogs = u.tickStatus();
            dotLogs.forEach(log => this.log(log));
            
            // ë„íŠ¸ ë°ë¯¸ì§€ë¡œ ì‚¬ë§ ì‹œ í„´ ì¢…ë£Œ
            if (u.isDead) {
                this.endTurn(true);
                return;
            }

            // [í›„ê³µ ë³´ì •] í•´ì œ
            if (u.hasStatus('START_IMMUNITY')) {
                const myTeam = u.team === 0 ? this.pTeam : this.eTeam;
                myTeam.forEach(member => {
                    member.status = member.status.filter(s => s.type !== 'START_IMMUNITY');
                });
                this.log(`<span class='log-sys'>ğŸ”“ [${u.team===0?'ì•„êµ°':'ì êµ°'}] í›„ê³µ ë³´í˜¸ë§‰ í•´ì œ!</span>`);
                this.render();
            }
        }

        // 5-2. í–‰ë™ ë¶ˆê°€(CC) ì²´í¬ (ìš°ì„ ìˆœìœ„: ì‚¬ë§ > ê¸°ì ˆ/ë¹™ê²° > ì„¸ë‡Œ)
        const hasCC = u.hasStatus('STUN') || u.hasStatus('FREEZE') || u.hasStatus('SLEEP');
        
        // [ìˆ˜ì •] ì„¸ë‡Œ ëŒ€ê¸° ì¤‘ì´ì–´ë„ ê¸°ì ˆí•˜ë©´ í„´ì„ ë‚ ë ¤ì•¼ í•¨ (ì„¸ë‡Œ ë¶ˆë°œ ì²˜ë¦¬)
        if (hasCC) {
            UI.floatText(u, "í–‰ë™ë¶ˆê°€", "ft-miss");
            this.log(`<span class='log-crit'>ğŸš« [${u.name}] ìƒíƒœì´ìƒìœ¼ë¡œ í–‰ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
            
            // ê¸°ì ˆë¡œ ì¸í•´ ì„¸ë‡Œ íƒ€ì´ë°ì„ ë†“ì³¤ë‹¤ë©´ ì˜ˆì•½ ì·¨ì†Œ
            if (u.hasStatus('MC_WAIT')) {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸŒ€ [${u.name}] ê¸°ì ˆí•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ ë¶ˆë°œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
            
            setTimeout(() => this.endTurn(), 1000);
            return;
        }
        
        // (ì—¬ê¸° ìˆë˜ ì¤‘ë³µ ì½”ë“œë“¤ì„ ê¹¨ë—ì´ ì§€ì› ìŠµë‹ˆë‹¤)

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        // 6. [ì„¸ë‡Œ ë°œë™] í„´ í•˜ì´ì¬í‚¹ (ì¦‰ì‹œ ì œì–´ê¶Œ íƒˆì·¨)
        const mcWaitStatus = u.status.find(s => s.type === 'MC_WAIT');
        if (mcWaitStatus) {
            // ì‹œì „ì(ì£¼ì¸) í™•ì¸
            let caster = null;
            if (mcWaitStatus.sourceId !== undefined && mcWaitStatus.sourceId !== -1) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                caster = allUnits.find(unit => unit.id === mcWaitStatus.sourceId);
            }

                    // ì‹œì „ìê°€ ë‚´ íŒ€ì´ë©´ -> ë‚´ í„´ìœ¼ë¡œ ê°•ì œ ì „í™˜ (ëª¨ë“  ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥)
        if (caster && !caster.isDead && caster.team === 0) {
            // [ìˆ˜ì •] ì„¸ë‡Œ ì„±ê³µ ì‹œ, ì´ë¯¸ ëŒì•„ê°€ê³  ìˆëŠ” AI ê°ì‹œì(Watchdog)ë¥¼ ë°˜ë“œì‹œ êº¼ì•¼ í•¨
            if (this.watchdog) clearTimeout(this.watchdog);

            isMyTurn = true;
            isPuppetTurn = true;
            this.isMindControlling = u; // ì „ì—­ ë³€ìˆ˜ ì„¤ì •
            this.currentMCCasterId = caster.id; // [ì¶”ê°€] ì‹œì „ì ID ì €ì¥ (ì‚¬ë§ íŒì •ìš©)

            this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°° ì„±ê³µ! ì œì–´ê¶Œì„ íƒˆì·¨í–ˆìŠµë‹ˆë‹¤.</span>`);

                UI.floatText(u, "ì œì–´ê¶Œ íšë“", "ft-crit");
                
                // ìƒíƒœ ì œê±° (ì´ë²ˆ í„´ì— ë°”ë¡œ í–‰ë™í•˜ë¯€ë¡œ ìƒíƒœ ì•„ì´ì½˜ ì‚­ì œ)
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            } 
            // ì‹œì „ìê°€ ì  íŒ€ì´ë©´ -> ì ì´ ì¡°ì¢… (ë‚´ ì…ë ¥ ì°¨ë‹¨)
            else if (caster && !caster.isDead && caster.team === 1) {
                isMyTurn = false;
                this.isMindControlling = u;
                
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì ì—ê²Œ ì¡°ì¢…ë‹¹í•©ë‹ˆë‹¤!</span>`);
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
            }
            // ì‹œì „ìê°€ ì£½ì—ˆìœ¼ë©´ í•´ì œ
            else {
                u.status = u.status.filter(s => s.type !== 'MC_WAIT');
                this.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ìê°€ ì‚¬ë§í•˜ì—¬ ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤.</span>`);
            }
            
            // ì£¼ì˜: ê¸°ì¡´ì˜ 'return'ì„ ì‚­ì œí•˜ì—¬ ì•„ë˜ì˜ input() ë¡œì§ìœ¼ë¡œ íë¥´ê²Œ í•¨
        }

        // 7. [UI ì—…ë°ì´íŠ¸] ë°°ë„ˆ ë° ë©”ì‹œì§€
        let turnName = u.name.split(' ')[0];
        let indicatorText = `Round ${round} : ${turnName}`;
        
        if (isPuppetTurn) {
            UI.showTurnBanner(true);
            indicatorText = `ğŸ§  ì •ì‹  ì§€ë°° ì¤‘! [${turnName}] ì¡°ì¢…í•˜ì„¸ìš”!`;
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #d500f9";
        } else if (isMyTurn) {
            UI.showTurnBanner(true);
            if (this.mode === 'pvp') indicatorText += " (ë‚˜)";
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ff80ab";
        } else {
            UI.showTurnBanner(false);
            if (this.mode === 'pvp') indicatorText = "ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
            if (this.isMindControlling && u.id === this.isMindControlling.id && u.team === 0) {
                 indicatorText = "ğŸ§  ë‚´ ìœ ë‹›ì´ ì¡°ì¢…ë‹¹í•˜ê³  ìˆìŠµë‹ˆë‹¤...";
            }
            const cp = document.querySelector('.control-panel');
            if(cp) cp.style.borderTop = "5px solid #ccc";
        }
        
        document.getElementById('turn-indicator').innerText = indicatorText;
        // [ì‹ ê·œ] BGM ìƒíƒœ ì—…ë°ì´íŠ¸ (ì•„êµ° ì²´ë ¥ 30% ë¯¸ë§Œ ìœ ë‹› ìˆìœ¼ë©´ ìœ„ê¸°)
        const danger = this.pTeam.some(u => !u.isDead && u.hp < u.maxHp * 0.3);
        BGM.setState(danger ? 'DANGER' : 'NORMAL');
        this.turnCount++;

        // 8. [ì…ë ¥ í™œì„±í™” ì—¬ë¶€ ê²°ì •]
        if (isMyTurn || this.difficulty === 'local') {
            this.input(u);
            // ë§Œì•½ ê¼­ë‘ê°ì‹œ í„´ì´ë¼ë©´ íˆ´íŒ ë„ì›Œì£¼ê¸°
            if (isPuppetTurn) {
                setTimeout(() => {
                    const cardId = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                    const el = document.getElementById(cardId);
                    if(el) UI.showTooltip(u, el);
                }, 100);
            }
        } else {
            this.noInput();
            if (this.mode !== 'pvp') {
                this.timer = setTimeout(() => this.ai(u), 800);
            }
        }
    },

    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for (let i = 0; i < 6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx];
            const isP = qId % 2 === 0;
            const uIdx = isP ? Math.floor(qId / 2) : Math.floor((qId - 1) / 2);
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            if (!u) continue; // null ì²´í¬ ì¶”ê°€
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if (u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if (!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });
            team.forEach((u) => {
                const cardId = tid === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                
                d.className = `unit role-${role} ${u.isSuper ? 'super-hero' : ''} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;

                // [íˆ´íŒ & ê°ì •í‘œí˜„ ë¡œì§ í†µí•©]
                d.onmousedown = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return;
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.onmouseup = () => { clearTimeout(d.pressTimer); UI.hideTooltip(); };
                d.onmouseleave = () => { 
                    clearTimeout(d.pressTimer); UI.hideTooltip();
                    // ë¯¸ë¦¬ë³´ê¸° ì œê±°
                    const p = d.querySelector('.hp-preview');
                    if(p) p.remove();
                };
                d.ontouchstart = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return;
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.ontouchend = () => { clearTimeout(d.pressTimer); UI.hideTooltip(); };

                // [ì‹ ê·œ] í´ë¦­ ì‹œ ê°ì •í‘œí˜„ ë©”ë‰´ (ìŠ¤í‚¬ ì„ íƒ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
                d.onclick = (e) => {
                    if (Game.selectedSkillIdx !== -1) return; // íƒ€ê²ŸíŒ… ì¤‘ì´ë©´ ë¬´ì‹œ
                    if (u.team === 0) { // ë‚´ ìœ ë‹›ë§Œ
                        UI.showEmoteMenu(u, d);
                        e.stopPropagation();
                    }
                };

                // [ì‹ ê·œ] ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ë°ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
                d.onmouseenter = () => {
                    // ìŠ¤í‚¬ ì„ íƒ ì¤‘ì´ê³  + ì êµ°ì´ë©° + ë‚´ê°€ ì¡°ì‘ ì¤‘ì¼ ë•Œ
                    if (Game.selectedSkillIdx !== -1 && tid !== 0 && !Game.isProcessing) {
                        const pred = Game.predictDmg(u);
                        if (pred > 0) {
                            const bar = d.querySelector('.status-bar');
                            if (bar) {
                                const preview = document.createElement('div');
                                preview.className = 'hp-preview';
                                // ì²´ë ¥ë°” ë¹„ìœ¨ ê³„ì‚°
                                const widthPct = Math.min(100, (pred / u.maxHp) * 100);
                                preview.style.width = widthPct + '%';
                                bar.appendChild(preview);
                            }
                        }
                    }
                };

                let tags = u.status.map(s => {
                    let c = 'tag';
                    const map = {
                        'POISON': 'poison', 'FREEZE': 'freeze', 'SILENCE': 'silence',
                        'EVADE': 'evade', 'BURN': 'burn', 'BANISH': 'banish',
                        'TRAP': 'trap', 'BIND': 'bind', 'GROWTH': 'growth',
                        'ATK_DOWN': 'atkdown', 'BLIND': 'blind', 'IMMUNITY': 'immunity',
                        'HEAL_DOWN': 'healdown', 'LIGHT_MIGHT': 'atkup', 'LIFESTEAL_BUFF': 'lifesteal',
                        'ATK_BUFF_SMALL': 'atkup_s', 'START_IMMUNITY': 'start-immunity',
                        'MC_WAIT': 'mc-wait', 'MC_READY': 'mc-ready'
                    };
                    if (s.type.includes('PROVOKED')) c += ' taunt';
                    else if (s.type.startsWith('KARMA_VICTIM')) c += ' karma';
                    else if (map[s.type]) c += ` ${map[s.type]}`;
                    let txt = s.type;
                    const tMap = {
                        'POISON': 'ë…', 'FREEZE': 'ë¹™ê²°', 'SILENCE': 'ì¹¨ë¬µ', 'DMG_RED': 'ë°©ì–´â†‘',
                        'EVADE': 'íšŒí”¼', 'BURN': 'í™”ìƒ', 'TRAP': 'ì†ë°•', 'BANISH': 'ì¶”ë°©',
                        'BIND': 'ê²°ì†', 'GROWTH': 'ì„±ì¥', 'ATK_DOWN': 'ê³µê²©â†“', 'BLIND': 'ì‹¤ëª…',
                        'IMMUNITY': 'ë©´ì—­', 'HEAL_DOWN': 'ì¹˜ìœ â†“', 'LIGHT_MIGHT': 'ê³µê²©â†‘',
                        'LIFESTEAL_BUFF': 'ğŸ©¸í¡í˜ˆ', 'ATK_BUFF_SMALL': 'ğŸ”¥ê³µê²©â†‘', 'START_IMMUNITY': 'ğŸ›¡ï¸ì„ ê³µë°©ì–´',
                        'MC_WAIT': 'ğŸŒ€ì„¸ë‡Œì¤‘...', 'MC_READY': 'ğŸ§ ì¡°ì¢…ê°€ëŠ¥'
                    };
                    if (s.type.includes('PROVOKED')) txt = 'ë„ë°œ';
                    else if (s.type.startsWith('KARMA_VICTIM')) txt = 'ğŸ‘ï¸ì—…ë³´';
                    else if (tMap[s.type]) txt = tMap[s.type];
                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');
                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;
                let bgClass = `bg-${u.base}`;
                if (u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if (u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || '';
                let extraBadge = '';
                if (u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;

                let displayName = u.name.split(' ')[0];
                if (u.isSuper) {
                    const emo = EMOTION_DB[u.getKey()];
                    // 1. ê°ì • DBì— ìˆê³ , í•´ê¸ˆëœ ìƒíƒœë¼ë©´ íƒ€ì´í‹€ í‘œì‹œ
                    if (emo) {
                        displayName = `[${emo.t}] ${displayName}`;
                    } else {
                        // 2. ì˜ˆì™¸ ì²˜ë¦¬ (ê¸°ì¡´ ë¡œì§)
                        if (role === 'nuker') displayName = `ğŸ‘¹God ${displayName}`;
                        else if (role === 'tank') displayName = `ğŸ›¡ï¸Lord ${displayName}`;
                        else if (role === 'supp') displayName = `ğŸ˜‡Saint ${displayName}`;
                    }
                }

                // [ì‹ ê·œ] ë™ì  ì²´ë ¥ë°” ìƒ‰ìƒ (Dynamic HP Color)
                const hpPct = (u.hp / u.maxHp) * 100;
                let hpColor = '#66bb6a'; // Green (Safe)
                if (hpPct <= 25) hpColor = '#ef5350'; // Red (Danger)
                else if (hpPct <= 50) hpColor = '#ffb74d'; // Orange (Warning)

                const innerHTML = ` ${extraBadge} <div class="tag-container">${tags}</div> <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div> <div class="unit-name" style="font-size:15px; margin-bottom:3px; ${u.isSuper ? 'color:#fbc02d; text-shadow:0 0 5px rgba(255,235,59,0.5);' : ''}">${displayName} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div> <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${hpPct}%; background:${hpColor};"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div> <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div> `;
                if (d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0);
        draw('enemy-row', this.eTeam, 1);
    },

endTurn: function(isFast = false) {
        if (this.isOver) return;
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // í˜„ì¬ í„´ ì£¼ì¸ ìœ ë‹› ì°¾ê¸°
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];

        // [ë°¸ëŸ°ìŠ¤ ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§
        // "í˜„ì¬ í„´ì„ ë§ˆì¹œ ìœ ë‹›(u)"ì´ "ì¡°ì¢… ì¤‘ì¸ ìœ ë‹›(isMindControlling)"ì¼ ë•Œë§Œ í•´ì œ
        if (this.isMindControlling && u && u.id === this.isMindControlling.id) {
             const puppet = this.isMindControlling;
             
             this.log(`<span class='log-sys'>ğŸ•Šï¸ [${puppet.name}] ì¡°ì¢… ì™„ë£Œ. ì •ì‹  ì§€ë°°ê°€ í•´ì œë©ë‹ˆë‹¤.</span>`); // ë©”ì‹œì§€ ë³€ê²½
             UI.floatText(puppet, "ì§€ë°° ì¢…ë£Œ", "ft-miss"); // í…ìŠ¤íŠ¸ ë³€ê²½
             
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             this.isMindControlling = null;
             
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab";
        }

        if (u && !u.isDead) u.decayStatus();
        
        [...this.pTeam, ...this.eTeam].forEach(u => {
            if (u.hp <= 0) this.die(u)
        });
        
        this.curr = (this.curr + 1) % 6;
        
        // ë°ìŠ¤ë§¤ì¹˜ ë¡œì§
        if (this.curr === 0) {
            const round = Math.ceil(this.turnCount / 6);
            if (round > 20) {
                [...this.pTeam, ...this.eTeam].forEach(u => {
                    if (!u.isDead) u.atk += 10;
                });
                this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
            }
        }
        
        this.render();
        const delay = isFast ? 100 : 1500;
        this.timer = setTimeout(() => this.turn(), delay);
    }, 

    // [ìˆ˜ì •] async í‚¤ì›Œë“œ ì¶”ê°€ (íˆ¬ì‚¬ì²´ ëŒ€ê¸°ìš©)
    execute: async function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el => el.onclick = null);
        AudioSys.speak(atk);

        if (isOnlineMode && !isRemote) {
            const isMindControlAction = this.isMindControlling && atk.id === this.isMindControlling.id;
            if (atk.team !== 0 && !isMindControlAction) {
                alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!");
                return;
            }
            netRndBuffer = [];
        }

        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];
        if (!logic) {
            this.endTurn(); 
            return;
        }

        if (sIdx > 0 && !def) {
             const needsTarget = !['SELF', 'SELF_BUFF', 'ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(SKILL_DB[key].type);
             if (needsTarget) {
                 this.log(`<span class='log-sys'>âš ï¸ [${atk.name}] ëŒ€ìƒì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</span>`);
                 this.endTurn();
                 return;
             }
        }

        // [ì‹ ê·œ] íˆ¬ì‚¬ì²´ ë°œì‚¬ (íƒ€ê²Ÿì´ ìˆê³ , ìì‹ ì´ ì•„ë‹ ë•Œ)
        if (def && atk.id !== def.id) {
            const skillType = (sIdx === 0) ? 'ATTACK' : SKILL_DB[key].type;
            // ìŠ¤í‚¬ íƒ€ì…ì´ ë²„í”„/íì´ ì•„ë‹ˆê±°ë‚˜, íì´ë¼ë„ ì ì—ê²Œ ì“¸ ë•Œ(ì„¸ë‡Œ)ëŠ” ê³µê²© ì´í™íŠ¸
            // ê°„ë‹¨í•˜ê²Œ ì•„ì´ì½˜ ë§¤í•‘
            let pIcon = 'âœ¨';
            if (atk.base === 'Fire') pIcon = 'ğŸ”¥';
            else if (atk.base === 'Water') pIcon = 'ğŸ’§';
            else if (atk.base === 'Tree') pIcon = 'ğŸƒ';
            else if (atk.base === 'Metal') pIcon = 'âš”ï¸';
            else if (atk.base === 'Earth') pIcon = 'ğŸª¨';
            else if (atk.base === 'Dark') pIcon = 'ğŸ’€';
            else if (atk.base === 'Normal') pIcon = 'ğŸ‘Š';
            
            // íŠ¹ìˆ˜ ìŠ¤í‚¬ ì•„ì´ì½˜ ì˜¤ë²„ë¼ì´ë“œ
            if (sIdx === 1 && atk.base === 'Metal-Light') pIcon = 'â˜£ï¸'; // ë…ê°€ìŠ¤
            if (sIdx === 2 && atk.base === 'Water-Dark') pIcon = 'â„ï¸'; // ì ˆëŒ€ì˜ë„

            // ì• ë‹ˆë©”ì´ì…˜ ëŒ€ê¸° (0.4ì´ˆ)
            await UI.fireProjectile(atk, def, pIcon);
        }
        
        // âœ… try-catchë¡œ ìŠ¤í‚¬ ì‹¤í–‰ ë³´í˜¸
        try {
            const playedSound = logic.useSkill(atk, def, sIdx, this);
            if (!playedSound) AudioSys.play('SKILL');

            // [ê°ì„± ì²´í¬] ìŠ¤í‚¬ ì‚¬ìš© í›„ í†µê³„ ê°±ì‹  ì‹œ ê°ì„± í™•ì¸
            atk.checkAwakening();

            // âœ… ì„±ê³µ ì‹œì—ë§Œ ë„¤íŠ¸ì›Œí¬ ì „ì†¡
            if (isOnlineMode && !isRemote) {
                socket.emit('action', {
                    room: myRoom,
                    attackerId: atk.id,
                    attackerTeam: atk.team,
                    targetId: def ? def.id : null,
                    targetTeam: def ? def.team : null,
                    skillIdx: sIdx,
                    rndBuffer: netRndBuffer
                });
            }
        } catch(e) {
            console.error('âŒ Skill execution failed:', e);
            this.log(`<span class='log-sys' style='color:red;'>âš ï¸ [${atk.name}] ìŠ¤í‚¬ ì‹¤í–‰ ì˜¤ë¥˜ ë°œìƒ</span>`);
            netRndBuffer = []; // ì‹¤íŒ¨ ì‹œ ë²„í¼ ì´ˆê¸°í™”
        }
        
        // [ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ì€ endTurn()ìœ¼ë¡œ ì´ë™ë¨
        this.endTurn();
    },

    reset: function() {
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));
        this.selected = [];
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        this.init();
    },
    // [ê°ì„± ì²´í¬] ìŠ¤íƒ¯ ê¸°ë¡ ì‹œ ê°ì„± í™•ì¸
    recordStat: function(unit, type, amount) {
        if (!unit || amount <= 0) return;
        if (type === 'dmg') unit.stats.dmg += amount;
        if (type === 'shield') unit.stats.shieldGiven += amount;
        if (type === 'heal') unit.stats.heal += amount;
        unit.checkAwakening();
    },
    input: function(u) {
    // ì„¸ë‡Œ ìƒíƒœ UI í‘œì‹œ
    const cp = document.querySelector('.control-panel');
    if (cp) {
        cp.style.borderTop = this.isMindControlling ? "5px solid #d500f9" : "5px solid #ff80ab";
    }
    
    const k = u.getKey();
    const s = SKILL_DB[k];
    
    // ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ ë°©ì–´ ì½”ë“œ
    if (!s) {
        console.error("âŒ SKILL_DB missing for key:", k, "Unit:", u.name);
        document.getElementById('p-icon').innerText = 'â“';
        document.getElementById('p-desc').innerText = 'ERROR: ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ';
        document.getElementById('sk-0').innerHTML = '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br><span class="skill-desc">1.0ë°°</span>';
        document.getElementById('sk-1').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        document.getElementById('sk-2').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        [0, 1, 2].forEach(i => document.getElementById(`sk-${i}`).disabled = true);
        this.log(`<span class='log-sys'>âš ï¸ [${u.name}] ìŠ¤í‚¬ ì •ë³´ ì˜¤ë¥˜ ë°œìƒ</span>`);
        return;
    }
    
    const silenced = u.hasStatus('SILENCE');
    
    // íŒ¨ì‹œë¸Œ ì •ë³´
    document.getElementById('p-icon').innerText = s.icon || 'â“';
    document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
    
    // ìŠ¤í‚¬ ë²„íŠ¼ ì •ë³´
    document.getElementById('sk-0').innerHTML = 
        '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br>' +
        '<span class="skill-desc">1.0ë°° í”¼í•´</span>';
    
    document.getElementById('sk-1').innerHTML = 
        '<span class="skill-name">' + (s.s1 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s1d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    document.getElementById('sk-2').innerHTML = 
        '<span class="skill-name">' + (s.s2 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s2d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ
    document.getElementById('sk-0').disabled = false;
    document.getElementById('sk-1').disabled = silenced;
    
    // S2 ë¹„í™œì„±í™” ì¡°ê±´
    let sk2Disable = silenced;
    
    if (k === 'Fire-Light' && (u.s2Count || 0) >= 5) {
        sk2Disable = true;
    }
    
    if (k === 'Tree-Dark') {
        const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
        const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
        if (aliveAllies.length === 0 || u.linkedAllyId !== -1) {
            sk2Disable = true;
        }
    }
    
    document.getElementById('sk-2').disabled = sk2Disable;
    
    if (silenced) {
        this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
    }
    
    // ë„ë°œ í™•ì¸ (ì„¸ë‡Œ ìƒíƒœë¼ë©´ ë„ë°œ ë¬´ì‹œ)
    const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
    const isBrainwashed = this.isMindControlling && this.isMindControlling.id === u.id;

    if (provoked && !isBrainwashed) { // ğŸ§  ì„¸ë‡Œ ì•„ë‹ ë•Œë§Œ ë„ë°œ ì ìš©
        const targetId = parseInt(provoked.type.split('_')[2]);
        const enemies = u.team === 0 ? this.eTeam : this.pTeam;
        const allies = u.team === 0 ? this.pTeam : this.eTeam;
        const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
        
        if (!target || target.isDead) {
            u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
            this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
            UI.floatText(u, "ììœ !", "ft-heal");
            this.render();
        } else {
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput();
            setTimeout(() => this.execute(u, target, 0), 1000);
            return; // ê°•ì œ ê³µê²© ì‹œ í•¨ìˆ˜ ì¢…ë£Œ
        }
    } else if (provoked && isBrainwashed) {
        this.log(`<span class='log-sys'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°°ë¡œ ì¸í•´ ë„ë°œì„ ë¬´ì‹œí•©ë‹ˆë‹¤.</span>`);
    }
    
    this.selectedSkillIdx = -1;
},
    noInput: function() {
        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            b.disabled = true;
            b.classList.remove('selected');
        });
    },
    prepareSkill: function(idx) {
    this.debugLog('Skill Button Clicked', { skillIndex: idx });

    // âœ… ì´ì „ íƒ€ê²ŸíŒ… ì´ˆê¸°í™” (ì¤‘ë³µ ë°©ì§€)
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    [0, 1, 2].forEach(i => {
        const b = document.getElementById(`sk-${i}`);
        if (i === idx) b.classList.add('selected');
        else b.classList.remove('selected');
    });
    
    this.selectedSkillIdx = idx;
        
        // í˜„ì¬ í–‰ë™ ì£¼ì²´ ì°¾ê¸°
        let u;
        if (this.isMindControlling) {
            u = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }

        // [ë””ë²„ê·¸] í–‰ë™ ìœ ë‹› ì •ë³´ ì¶œë ¥
        if (u) this.debugLog('Acting Unit Identified', { name: u.name, id: u.id, isMindControlled: !!this.isMindControlling });

        const k = u.getKey();
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';

        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì¸ë±ìŠ¤ë³„ íƒ€ê²Ÿ íƒ€ì… ëª…í™•í™”
        if (idx === 0) {
            targetType = 'ENEMY'; // í‰íƒ€ëŠ” ë¬´ì¡°ê±´ ê³µê²©
        } else if (idx === 1) {
            // S1 ìŠ¤í‚¬ë“¤ì˜ íƒ€ê²Ÿ íƒ€ì… ì„¤ì •
            // [ìˆ˜ì •] Tree-Darkì˜ S1(ê°€ì‹œì°Œë¥´ê¸°)ì€ ê³µê²©ê¸°ì´ë¯€ë¡œ ENEMYì—¬ì•¼ í•¨
            if (['Tree'].includes(k)) targetType = 'SELF_BUFF';
            else if (['Fire-Light'].includes(k)) targetType = 'ALL_ALLY'; // í¡í˜ˆ ë¶€ì—¬ëŠ” ì „ì²´ ë²„í”„
            else if (['Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; // ë””ë²„í”„ ê³µê²©
            else targetType = 'ENEMY'; // ë‚˜ë¨¸ì§€ëŠ” ëŒ€ë¶€ë¶„ ê³µê²©
        } else if (idx === 2) {
            // S2ëŠ” DBì— ìˆëŠ” target ì†ì„± ì‚¬ìš©
            targetType = s.target || 'ENEMY';
        }

        // íƒ€ê²ŸíŒ… í•¨ìˆ˜ í˜¸ì¶œ
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
    // 1. í–‰ë™ ìœ ë‹› í™•ì •
    if (!actingUnit) {
        if (this.isMindControlling) {
            actingUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            actingUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
        }
    }

    // 2. ê¸°ì¡´ íƒ€ê²ŸíŒ… ì´ˆê¸°í™”
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    // 3. ìŠ¤í‚¬ íƒ€ì… ë¶„ë¥˜
    const SUPPORT_TYPES = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF', 'TARGET_BUFF', 'HEAL', 'BUFF'];
    const isSupportSkill = SUPPORT_TYPES.includes(targetType);
    const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
    const isSelfOnly = ['SELF', 'SELF_BUFF'].includes(targetType);

    // 4. íŒ€ ì •ì˜ (ì›ë˜ ì†Œì† ê¸°ì¤€)
    const originalAllies = actingUnit.team === 0 ? this.pTeam : this.eTeam;
    const originalEnemies = actingUnit.team === 0 ? this.eTeam : this.pTeam;

    let finalTargets = [];

    // 5. ì„¸ë‡Œ ì—¬ë¶€ì— ë”°ë¥¸ íƒ€ê²Ÿ ê²°ì •
    const isMindControlled = this.isMindControlling && actingUnit.id === this.isMindControlling.id;
    
    if (isSelfOnly) {
        // ìê°€ ë²„í”„ëŠ” ì–¸ì œë‚˜ ìì‹ ì—ê²Œë§Œ
        finalTargets = [actingUnit];
    } 
    else if (isMindControlled) {
        // [ì„¸ë‡Œ ìƒíƒœ] - í”¼ì•„ì‹ë³„ ì—­ì „
        if (isSupportSkill) {
            // í/ë²„í”„ -> ì êµ°(í˜„ì¬ ë‚˜ë¥¼ ì¡°ì¢…í•˜ëŠ” íŒ€)ì—ê²Œ ì‚¬ìš©
            finalTargets = originalEnemies.filter(u => !u.isDead);
        } else {
            // ê³µê²© -> ì•„êµ°(ë‚˜ì˜ ì›ë˜ ë™ë£Œ)ì„ ê³µê²©
            // [ê°œì„ ] ìí•´(Self Attack)ë„ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ì„ í¬í•¨
            finalTargets = originalAllies.filter(u => !u.isDead);
            // ìí•´ ê°€ëŠ¥í•˜ë„ë¡ ìì‹ ë„ í¬í•¨ (ì¤‘ë³µ ë°©ì§€ ì²´í¬)
            if (!finalTargets.some(t => t.id === actingUnit.id)) {
                finalTargets.push(actingUnit);
            }
        }
    } else {
        // [ì •ìƒ ìƒíƒœ]
        if (isSupportSkill) {
            finalTargets = originalAllies.filter(u => !u.isDead);
        } else {
            // ì êµ° + "ì„¸ë‡Œë‹¹í•´ì„œ ë°°ì‹ ìê°€ ëœ ì•„êµ°"ë„ ê³µê²© ê°€ëŠ¥í•´ì•¼ í•¨
            const realEnemies = originalEnemies.filter(u => !u.isDead);
            const traitors = originalAllies.filter(u => !u.isDead && (u.hasStatus('MC_WAIT') || u.hasStatus('MC_READY')));
            finalTargets = [...realEnemies, ...traitors];
        }
    }

    // 6. Tree-Dark ì˜ˆì™¸ ì²˜ë¦¬
    if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2) {
        // ì˜í˜¼ê²°ì†ì€ ìì‹  ì œì™¸ (ë‹¨, ì„¸ë‡Œ ìƒíƒœì—ì„œ í˜¼ì ë‚¨ì€ ê²½ìš°ëŠ” ìí•´ ê°€ëŠ¥)
        if (!isMindControlled || finalTargets.length > 1) {
            finalTargets = finalTargets.filter(t => t.id !== actingUnit.id);
        }
    }

    // 7. íƒ€ê²Ÿ ë Œë”ë§
    let targetClass = isSupportSkill ? 'target-ally' : 'target-enemy';
    if (isAOE && !isSupportSkill) targetClass = 'target-aoe';

    let targetCount = 0;

    finalTargets.forEach((t) => {
        const cardId = t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`;
        const el = document.getElementById(cardId);
        
        if (el) {
            el.classList.add(targetClass);
            el.onclick = () => {
                if (Game.isProcessing) return;
                Game.isProcessing = true;
                
                // ì…ë ¥ ì ê¸ˆ
                this.noInput();
                document.querySelectorAll('.unit').forEach(e => {
                    e.classList.remove('target-enemy', 'target-ally', 'target-aoe');
                });
                
                // ì‹¤í–‰
                this.execute(actingUnit, t, this.selectedSkillIdx);
            };
            targetCount++;
        }
    });

// 8. ë””ë²„ê¹… ë° ì˜ˆì™¸ ì²˜ë¦¬ (Option 2 ì ìš©)
    if (targetCount === 0) {
        console.warn('âš ï¸ No valid targets:', {
            skillIdx: this.selectedSkillIdx,
            targetType: targetType,
            actingUnit: actingUnit.name,
            isMindControlled: isMindControlled,
            finalTargets: finalTargets.map(t => t.name)
        });

        // íƒ€ê²Ÿì´ ì—†ëŠ” ê²½ìš° UI í”¼ë“œë°±
        if (isMindControlled && !isSupportSkill) {
            UI.floatText(actingUnit, "ëŒ€ìƒì—†ìŒ", "ft-miss");
            this.log(`<span class='log-sys'>âš ï¸ [${actingUnit.name}] ê³µê²©í•  ìˆ˜ ìˆëŠ” ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>`);
        } else if (!isMindControlled && finalTargets.length === 0) {
            console.error('ğŸš¨ Critical: No targets found in normal state!');
            UI.floatText(actingUnit, "íƒ€ê²Ÿì˜¤ë¥˜", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš¨ [${actingUnit.name}] íƒ€ê²ŸíŒ… ì˜¤ë¥˜ ë°œìƒ</span>`);
        }
        
        // âœ… ìŠ¤í‚¬ ì„ íƒ ì´ˆê¸°í™” ì¶”ê°€ (ë²„ê·¸ ìˆ˜ì •)
        this.selectedSkillIdx = -1;
        document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('selected'));
        return; // í•¨ìˆ˜ ì¢…ë£Œ
    }
}, // ì½¤ë§ˆ í•„ìˆ˜ (ë’¤ì— ai í•¨ìˆ˜ê°€ ìˆìŒ)


    // ========== 3997ë²ˆì§¸ ì¤„ë¶€í„° êµì²´ ==========
ai: function(u) {
        // ì˜¨ë¼ì¸, ë¡œì»¬ PVPë©´ AI ì‘ë™ ì¤‘ì§€
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;
        
        // 0. ê¸°ë³¸ ê²€ì¦
        if (!u || u.isDead) {
            this.endTurn(true);
            return;
        }

        try {
            this.log(`<span class='log-sys'>ğŸ¤– AI í–‰ë™ ì¤‘: ${u.name}</span>`);

            // 1. ì„¸ë‡Œ íŒì •
            const isBrainwashed = (this.isMindControlling && this.isMindControlling.id === u.id);
            if (isBrainwashed) {
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì„¸ë‡Œ ìƒíƒœë¡œ í–‰ë™!</span>`);
            }

            // 2. ì /ì•„êµ° ì‹ë³„ (ì„¸ë‡Œ ì‹œ ë°˜ì „)
            let enemies, allies;
            if (isBrainwashed) {
                enemies = u.team === 0 ? this.pTeam : this.eTeam; // ì›ë˜ íŒ€ì´ ì 
                allies = u.team === 0 ? this.eTeam : this.pTeam;
            } else {
                enemies = u.team === 0 ? this.eTeam : this.pTeam; // ìƒëŒ€ íŒ€ì´ ì 
                allies = u.team === 0 ? this.pTeam : this.eTeam;
            }

            // 3. ìƒì¡´ì í•„í„°ë§ (ìê¸° ìì‹  ì œì™¸ - ìí•´ ë°©ì§€)
            let aliveEnemies = enemies.filter(e => !e.isDead && e.id !== u.id);
            const aliveAllies = allies.filter(a => !a.isDead);

            // [ì˜ˆì™¸] ì„¸ë‡Œ ìƒíƒœì¸ë° ê³µê²© ëŒ€ìƒ(ì›ë˜ ì•„êµ°)ì´ ì „ë©¸í•œ ê²½ìš°ë§Œ ìí•´ í—ˆìš©
            if (aliveEnemies.length === 0 && isBrainwashed) {
                aliveEnemies = [u];
                this.log(`<span class='log-crit'>ğŸ§  [${u.name}] ê³µê²© ëŒ€ìƒ ì „ë©¸ë¡œ ìí•´ ì‹œë„</span>`);
            }

            // [ì¢…ë£Œ ì¡°ê±´] ê³µê²© ëŒ€ìƒ ì—†ìœ¼ë©´ í„´ ì¢…ë£Œ
            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            // 4. ë„ë°œ(Taunt) ì²˜ë¦¬
            if (!isBrainwashed) {
                const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
                if (provoked) {
                    const targetId = parseInt(provoked.type.split('_')[2]);
                    const taunter = aliveEnemies.find(t => t.id === targetId);
                    if (taunter) {
                        this.execute(u, taunter, 0); // í‰íƒ€ ê°•ì œ
                        return;
                    }
                }
            }

            const silenced = u.hasStatus('SILENCE');
            const k = u.getKey();
            const sk = SKILL_DB[k];

            // 5. ì ìˆ˜ ê³„ì‚° ë° í–‰ë™ ëª©ë¡ ìƒì„±
            
            // [í—¬í¼] ê³µê²© ì ìˆ˜ ê³„ì‚°
            const getAttackScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                let score = 0;
                const skillDesc = skillIdx === 0 ? "ê¸°ë³¸ê³µê²©" : (skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || ""));
                
                // ë°ë¯¸ì§€ ë°°ìœ¨ íŒŒì‹±
                let multiplier = 1.0;
                if (skillIdx > 0 && skillDesc) {
                    const match = skillDesc.match(/([\d.]+)ë°°/);
                    if (match) multiplier = parseFloat(match[1]);
                }

                // ì˜ˆìƒ ë°ë¯¸ì§€
                const aff = Game.calc(u, target);
                const baseDmg = u.getAtk() * multiplier * aff.v;

                // ì ìˆ˜ ì‚°ì •
                if (baseDmg > 0 && target.hp <= baseDmg) score += 5000; // í‚¬ê°
                else score += baseDmg;
                
                if (aff.v > 1.0) score += 200; // ìƒì„± ìš°ìœ„

                // ë„ë°œ/CC ê°€ì‚°ì 
                if (skillDesc.includes('ë„ë°œ') || skillDesc.includes('ê²°íˆ¬')) {
                    if (!target.status.some(st => st.type.startsWith('PROVOKED'))) score += 2000;
                }
                const ccKeywords = ['ê¸°ì ˆ', 'ë¹™ê²°', 'ì¹¨ë¬µ', 'ì„¸ë‡Œ', 'ì†ë°•', 'STUN', 'FREEZE', 'SILENCE'];
                if (ccKeywords.some(kw => skillDesc.includes(kw))) {
                    if (!target.hasStatus('IMMUNITY') && !target.isNormal) {
                        const hasCC = target.hasStatus('STUN') || target.hasStatus('FREEZE') || target.hasStatus('SILENCE');
                        if (hasCC) score -= 500; // ì¤‘ë³µ CC ë°©ì§€
                        else score += 300;
                    }
                }
                return score;
            };

            // [í—¬í¼] ì§€ì› ì ìˆ˜ ê³„ì‚°
            const getSupportScore = (target, skillIdx) => {
                if (!target || target.isDead) return -9999;
                let score = 0;
                const skillDesc = skillIdx === 1 ? (sk.s1d || "") : (sk.s2d || "");

                if (skillDesc.includes('í') || skillDesc.includes('HP') || sk.type === 'HEAL') {
                    const missing = target.maxHp - target.hp;
                    if (missing > 0) score += missing * 2.0;
                    else score -= 1000;
                }
                if (skillDesc.includes('ì •í™”') && target.status.length > 0) score += 300;
                if (skillDesc.includes('ì‰´ë“œ') && target.shield < 50) score += 300;
                if (target.id === u.id && (skillDesc.includes('ì„±ì¥') || sk.type === 'SELF_BUFF')) score += 400;

                return score;
            };

            // [í—¬í¼] ìŠ¤í‚¬ íƒ€ì… íŒë³„ (AI ë¡œì§ ê°œì„ )
            const isAttackSkill = (desc, type) => {
                if (!desc) return false;
                // 1. ê³µê²© ê³„ìˆ˜('ë°°') í˜¹ì€ ê³µê²©ì  í‚¤ì›Œë“œ(ë„ë°œ, ì†ë°• ë“±)ê°€ ìˆìœ¼ë©´ ê³µê²© ìŠ¤í‚¬
                if (desc.includes('ë°°') || desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return true;
                // 2. íƒ€ì…ì´ ëª…ë°±í•œ ê³µê²©/ë°©í•´ ê³„ì—´ì´ë©´ True
                if (['CC', 'DEBUFF', 'AOE', 'NUKE_PER', 'ATK'].includes(type)) return true;

                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY'];
                
                // ì§€ì› í‚¤ì›Œë“œê°€ ìˆìœ¼ë©´ ê³µê²© ì•„ë‹˜
                if (supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type)) return false;
                return true;
            };

                    const isSupportSkill = (desc, type) => {
            if (!desc) return false;

            // ğŸš¨ [í•„ìˆ˜ ìˆ˜ì •] ë°ë¯¸ì§€ê°€ ì—†ë”ë¼ë„ 'ë„ë°œ', 'ì†ë°•' ë“±ì€ ì ì—ê²Œ ì“°ëŠ” ìŠ¤í‚¬ì„!

            // [ìˆ˜ì •] íëŸ¬(HEAL) íƒ€ì…ì´ë¼ë„ ìŠ¤í‚¬ ì„¤ëª…ì— 'ë°°'(ê³µê²©ê³„ìˆ˜)ê°€ ìˆê³  'í/íšŒë³µ'ì´ ì—†ë‹¤ë©´ ê³µê²©ê¸°ì„ (ì˜ˆ: ë¬¼ëŒ€í¬)
            // ì´ë ‡ê²Œ í•´ì•¼ íëŸ¬ê°€ í‰íƒ€ë‚˜ ê³µê²©ìŠ¤í‚¬ì„ ì•„êµ°ì—ê²Œ ì˜ëŠ”(ìí•´) í˜„ìƒì„ ë§‰ì„ ìˆ˜ ìˆìŒ
            if (desc.includes('ë°°') && !desc.includes('í') && !desc.includes('íšŒë³µ')) return false;

            if (desc.includes('ë„ë°œ') || desc.includes('ì†ë°•')) return false;
            if (['CC', 'DEBUFF', 'AOE'].includes(type)) return false;


                const supportKeywords = ['í', 'ì‰´ë“œ', 'ì •í™”', 'ë²„í”„', 'íšŒí”¼', 'ì„±ì¥'];
                const supportTypes = ['HEAL', 'BUFF', 'TARGET_BUFF', 'SELF_BUFF', 'ALL_ALLY'];
                
                return supportKeywords.some(kw => desc.includes(kw)) || supportTypes.includes(type);
            };

            let actions = [];

            // A. ê³µê²© í–‰ë™
            aliveEnemies.forEach(e => {
                actions.push({ idx: 0, target: e, score: getAttackScore(e, 0), type: 'attack' });
                if (!silenced) {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isAttackSkill(desc, sk.type)) {
                             actions.push({ idx: i, target: e, score: getAttackScore(e, i), type: 'attack' });
                        }
                    });
                }
            });

            // B. ì§€ì› í–‰ë™
            if (!silenced) {
                aliveAllies.forEach(a => {
                    [1, 2].forEach(i => {
                        const desc = i===1 ? sk.s1d : sk.s2d;
                        if (isSupportSkill(desc, sk.type)) {
                            if ((sk.type === 'SELF_BUFF' || sk.type === 'SELF') && a.id !== u.id) return;
                            actions.push({ idx: i, target: a, score: getSupportScore(a, i), type: 'support' });
                        }
                    });
                });
            }

            // 6. ìµœì  í–‰ë™ ì„ íƒ
            actions.sort((a, b) => (b.score + Math.random()) - (a.score + Math.random()));
            let best = actions[0];

            // í–‰ë™ ì—†ìœ¼ë©´ ëœë¤ í‰íƒ€
            if (!best || !best.target || best.score < -500) {
                best = { 
                    idx: 0, 
                    target: aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)],
                    type: 'attack'
                };
            }

            // 7. [ìµœì¢… ì•ˆì „ì¥ì¹˜] Friendly Fire ë°©ì§€
            if (!isBrainwashed && best.target && best.target.team === u.team) {
                // ê³µê²© íƒ€ì…ì´ê±°ë‚˜, ì„¤ëª…ì— 'ë°°'ê°€ ë“¤ì–´ê°€ëŠ” ê²½ìš° ê°•ì œ ë¦¬ë‹¤ì´ë ‰íŠ¸
                const info = best.idx === 0 ? "í‰íƒ€" : (best.idx === 1 ? sk.s1d : sk.s2d);
                if (best.type === 'attack' || (info && info.includes('ë°°') && sk.type !== 'HEAL')) {
                    console.warn(`ğŸš¨ Friendly Fire Prevented! [${u.name}] redirected.`);
                    best.target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
                    best.idx = 0;
                }
            }

            this.execute(u, best.target, best.idx);

        } catch (e) {
            console.error("AI Logic Critical Error:", e);
            this.endTurn(); 
        }
    },

    die: function(u) {
        if (u.isDead) return;
        u.isDead = true;
        u.hp = 0;

        // [ìˆ˜ì •] 1. ì‚¬ë§í•œ ìœ ë‹›(u)ì´ ì‹œì „í•œ 'ì„¸ë‡Œ ëŒ€ê¸°(MC_WAIT)' ìƒíƒœ ëª¨ë‘ ì œê±°
        [...Game.pTeam, ...Game.eTeam].forEach(target => {
            const wait = target.status.find(s => s.type === 'MC_WAIT');
            if (wait && wait.sourceId === u.id) {
                target.status = target.status.filter(s => s.type !== 'MC_WAIT');
                Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì([${u.name}]) ì‚¬ë§ìœ¼ë¡œ [${target.name}]ì˜ ì„¸ë‡Œ ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.</span>`);
            }
        });

        // [ìˆ˜ì •] 2. í˜„ì¬ 'ì¡°ì¢… ì¤‘'ì¸ ìƒíƒœì—ì„œ ì‹œì „ìê°€ ì£½ì—ˆì„ ë•Œ ê°•ì œ í•´ì œ
        // this.currentMCCasterIdëŠ” ìœ„ì—ì„œ ìƒˆë¡œ ì¶”ê°€í•œ ë³€ìˆ˜ì…ë‹ˆë‹¤.
        if (this.isMindControlling && (this.currentMCCasterId === u.id || !this.currentMCCasterId)) {
             const puppet = this.isMindControlling;
             
             // ì„¸ë‡Œ ìƒíƒœ ì•„ì´ì½˜ ì œê±° (MC_READY ë“± ì”ì—¬ë¬¼)
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             
             this.isMindControlling = null;
             this.currentMCCasterId = null;
             
             Game.log(`<span class='log-sys'>ğŸ•Šï¸ ì‹œì „ì ì‚¬ë§! [${puppet.name}]ì˜ ì •ì‹  ì§€ë°°ê°€ ì¦‰ì‹œ í’€ë¦½ë‹ˆë‹¤.</span>`);
             UI.floatText(puppet, "ì§€ë°° í•´ì œ", "ft-heal");
             
             // UI ë³µêµ¬
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab"; 
        }
		
        u.status = [];
        Game.log(`${u.name} íƒˆë½`);
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => {
                if (!e.isDead) e.addStatus('POISON', 1, 0, u);
            });
        }
        const allies = u.team === 0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base === 'Tree' && a.extra === 'Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.revengeAtk += 20;
            thorn.thornStack += 0.3;
            thorn.linkedAllyId = -1;
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`);
            UI.floatText(thorn, "RAGE!", "ft-crit");
        });
    },
    endCheck: function() {
        const pd = this.pTeam.every(u => u.isDead);
        const ed = this.eTeam.every(u => u.isDead);

        if (pd || ed) {
            this.isOver = true;
            if (this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN');
            BGM.stop(); // ì „íˆ¬ ì¢…ë£Œ ì‹œ ìŒì•… ë”

            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) {
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if (this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)");
            }
            localStorage.removeItem('et_save_v6');
            return true;
        }
        return false;
    },
    log: function(m) {
        const b = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.innerHTML = m;
        b.appendChild(d);
        b.scrollTop = b.scrollHeight;
    },
    shake: function(u) {
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('shake');
            void el.offsetWidth;
            el.classList.add('shake');
        }
    },
    saveGame: function() {
        if (this.isOver) {
            alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue,
            curr: this.curr,
            turnCount: this.turnCount,
            difficulty: this.difficulty,
            mode: this.mode,
            selected: this.selected
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },
    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if (savedStage) this.challengeStage = parseInt(savedStage);
        if (!json) {
            alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`);
            return;
        }
        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty;
            this.mode = data.mode;
            this.turnCount = data.turnCount;
            this.curr = data.curr;
            this.queue = data.queue;
            this.selected = data.selected;
            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));
            
            // [ì¶”ê°€] ì„¸ë‡Œ ìƒíƒœ ë³µêµ¬
            this.isMindControlling = null;
            this.currentMCCasterId = data.mcCasterId || null;
            if (data.mcTargetId !== null && data.mcTargetId !== undefined) {
                const allUnits = [...this.pTeam, ...this.eTeam];
                const puppet = allUnits.find(u => u.id === data.mcTargetId);
                if (puppet && !puppet.isDead) {
                    this.isMindControlling = puppet;
                    this.log("<span class='log-sys'>ğŸ§  ì„¸ë‡Œ ìƒíƒœë¥¼ ë³µêµ¬í–ˆìŠµë‹ˆë‹¤.</span>");
                }
            }

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal / 2)] : this.eTeam[Math.floor((tVal - 1) / 2)];
            if (!u) {
                alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
                return;
            }
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) {
            console.error(e);
            alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
    },
    serializeUnit: function(u) {
        return {
            id: u.id,
            team: u.team,
            base: u.base,
            extra: u.extra,
            hp: u.hp,
            maxHp: u.maxHp,
            shield: u.shield,
            atk: u.atk,
            status: u.status,
            isDead: u.isDead,
            thornStack: u.thornStack,
            linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count,
            elecStacks: u.elecStacks,
            growthStack: u.growthStack,
            stats: u.stats,
            passiveTriggered: u.passiveTriggered,
            revengeAtk: u.revengeAtk,
            isSuper: u.isSuper
        };
    },
    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp;
        u.maxHp = d.maxHp;
        u.shield = d.shield;
        u.atk = d.atk;
        u.status = d.status;
        u.isDead = d.isDead;
        if (d.thornStack) u.thornStack = d.thornStack;
        if (d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if (d.s2Count) u.s2Count = d.s2Count;
        if (d.elecStacks) u.elecStacks = d.elecStacks;
        if (d.growthStack) u.growthStack = d.growthStack;
        if (d.stats) u.stats = d.stats;
        if (d.passiveTriggered) u.passiveTriggered = d.passiveTriggered;
        if (d.revengeAtk) u.revengeAtk = d.revengeAtk;
        if (d.isSuper) u.isSuper = d.isSuper;
        return u;
    },
    // ë°ë¯¸ì§€ ì˜ˆì¸¡ ê³„ì‚°ê¸°
    predictDmg: function(target) {
        if (this.selectedSkillIdx === -1 || !target) return 0;
        
        // í˜„ì¬ í„´ì„ ì¡ì€ ìœ ë‹›(ê³µê²©ì) ì°¾ê¸°
        let atkUnit;
        if (this.isMindControlling) {
            atkUnit = this.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            if (tVal === undefined || tVal === null) return 0;
            atkUnit = tVal % 2 === 0 ? this.pTeam[Math.floor(tVal/2)] : this.eTeam[Math.floor((tVal-1)/2)];
        }
        if (!atkUnit || atkUnit.isDead) return 0;

        const k = atkUnit.getKey();
        const s = SKILL_DB[k];
        if (!s) return 0;
        
        let mult = 1.0;
        
        if (this.selectedSkillIdx === 0) {
            mult = 1.0;
        } else {
            const desc = this.selectedSkillIdx === 1 ? s.s1d : s.s2d;
            if (!desc) return 0;
            
            // ë¹„ê³µê²© ìŠ¤í‚¬ íƒ€ì… í•„í„°ë§
            const nonAtkTypes = ['HEAL', 'BUFF', 'ALLY', 'ALL_ALLY', 'SELF_BUFF', 'TARGET_BUFF'];
            if (s.type && nonAtkTypes.includes(s.type)) return 0;
            if (desc.includes('í') || desc.includes('ì‰´ë“œ') || desc.includes('ì •í™”')) return 0;
            
            const match = desc.match(/([\d.]+)ë°°/);
            if (match) mult = parseFloat(match[1]);
        }

        const baseAtk = atkUnit.getAtk();
        const aff = this.calc(atkUnit, target);
        return Math.floor(baseAtk * mult * aff.v);
    },
    calc: (a, d) => {
        let v = 1.0;
        let t = '';
        if (a.isNormal) {
            if (d.isNormal || d.isEnhanced) {
                v = 1.2;
                t = '(ê°•íƒ€)';
            }
        } else {
            const w = {
                'Fire': ['Metal', 'Tree'],
                'Water': ['Fire', 'Metal'],
                'Tree': ['Water', 'Earth'],
                'Metal': ['Tree', 'Earth'],
                'Earth': ['Fire', 'Water']
            };
            const ew = {
                'Light': ['Dark'],
                'Dark': ['Light']
            };
            if (!d.isNormal) {
                if (w[a.base]?.includes(d.base) || ew[a.base]?.includes(d.base)) {
                    v = 1.2;
                    t = '(ì•½ì )';
                } else if (w[d.base]?.includes(a.base)) {
                    v = 0.8;
                    t = '(ì €í•­)';
                }
            }
        }
        if (v === 1.2 && a.extra && d.extra && ((a.extra === 'Light' && d.extra === 'Dark') || (a.extra === 'Dark' && d.extra === 'Light'))) {
            v = 1.3;
            t = '(ì¹˜ëª…íƒ€!)';
        }
        return {
            v,
            t
        };
    }
};

window.onload = function() {
    Game.init();
};
</script>
</body>
</html>
