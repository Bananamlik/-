<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v8.2 Final Fix</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            /* [Theme] Jelly Cat Palette v6.2 */
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255,255,255,0.8), inset 0 -3px 6px rgba(0,0,0,0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body { 
            margin: 0; background-color: var(--bg-main); 
            background-image: var(--paw-pattern);
            background-size: 80px 80px; 
            color: var(--text-main); 
            font-family: var(--font-main);
            overflow: hidden; user-select: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; height: 100dvh; 
        }

        .screen-shake { animation: jelly-bounce 0.5s both; }
        @keyframes jelly-bounce { 
            0% { transform: scale(1, 1); } 
            30% { transform: scale(1.15, 0.85); } 
            40% { transform: scale(0.9, 1.1); }    
            50% { transform: scale(1.05, 0.95); } 
            65% { transform: scale(0.98, 1.02); } 
            100% { transform: scale(1, 1); } 
        }
        
        /* í”¼ê²© ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes shake-chewy {
            0% { transform: scale(1, 1) translate(0,0) rotate(0deg); }
            15% { transform: scale(1.15, 0.85) translate(-4px, 1px) rotate(-4deg); }
            30% { transform: scale(0.9, 1.1) translate(4px, -1px) rotate(4deg); }
            45% { transform: scale(1.05, 0.95) translate(-3px, 1px) rotate(-3deg); }
            60% { transform: scale(0.95, 1.05) translate(3px, -1px) rotate(3deg); }
            75% { transform: scale(1.02, 0.98) translate(-1px, 0) rotate(-1deg); }
            100% { transform: scale(1, 1) translate(0,0) rotate(0deg); }
        }
        .shake { animation: shake-chewy 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both; }

        #flash-overlay { position: fixed; inset: 0; background: #fff; opacity: 0; pointer-events: none; z-index: 999; transition: opacity 0.1s; }

        #turn-banner {
            position: fixed; top: 18%; left: 0; right: 0;
            padding: 15px 0;
            text-align: center; font-size: 32px; font-weight: 900;
            color: #fff; text-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            pointer-events: none; z-index: 2000;
            opacity: 0; transform: scaleX(0);
            display: flex; justify-content: center; align-items: center; gap: 10px;
        }
        @keyframes banner-swipe {
            0% { opacity: 0; transform: translateX(-50%) scaleX(0.5); }
            20% { opacity: 1; transform: translateX(0) scaleX(1); }
            70% { opacity: 1; transform: translateX(0) scaleX(1); }
            100% { opacity: 0; transform: translateX(50%) scaleX(0.5); }
        }

        #app { width: 100%; max-width: 600px; height: 100%; position: relative; display: flex; flex-direction: column; }
        
        button { 
            font-family: var(--font-main); border-radius: 25px; border: none; 
            background: #fff; color: #777; cursor: pointer; transition: 0.1s; 
            box-shadow: var(--jelly-shadow); 
            transform: translateY(0); 
            position: relative; overflow: hidden;
        }
        button::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
            border-radius: 20px; pointer-events: none;
        }
        button:active { transform: translateY(3px) scale(0.98); box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); }
        
        .btn-restart { padding: 8px 12px; font-size: 14px; color: var(--accent); }
        .btn-restart:hover { background: #fff0f5; }

        .mute-btn {
            position: absolute; top: 15px; right: 15px;
            width: 40px; height: 40px; border-radius: 50%;
            background: #fff; border: 2px solid #eee;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            cursor: pointer; transition: 0.2s;
        }
        .mute-btn:active { transform: scale(0.9); }
        .mute-btn.muted { background: #ffebee; color: #e57373; border-color: #ffcdd2; }

        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; padding: 15px; z-index: 10; }
        #selection-screen { background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(5px); }
        #battle-screen { display: none; padding: 5px; }

       /* display: gridë¥¼ ì œê±°í•˜ê³  blockìœ¼ë¡œ ë³€ê²½ (JSì—ì„œ ì„¹ì…˜ë³„ grid ì²˜ë¦¬) */
        .hero-grid { display: block; overflow-y: auto; padding: 10px; flex: 1; width: 100%; box-sizing: border-box; }
        
        .hero-card { 
            background: #fff; border-radius: 20px; padding: 8px; 
            cursor: pointer; transition: 0.2s; 
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05), inset 0 0 0 3px #fce4ec; 
            position: relative;
        }
        .hero-card:active { transform: scale(0.95); }
        .hero-card.selected { 
            background: #e1bee7; 
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }
        .hero-card.selected::after {
            content: 'ğŸ¾'; position: absolute; top: -10px; right: -5px;
            background: var(--accent); color: #fff; width: 28px; height: 28px;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 16px; box-shadow: 0 3px 6px rgba(0,0,0,0.2); z-index: 5;
            border: 2px solid #fff;
        }

        .field-row { flex: 1; display: flex; justify-content: space-evenly; align-items: center; width: 100%; perspective: 1000px; }
        
        .unit {
            width: 30vw; max-width: 130px; 
            background: #fff; 
            border-radius: 25px; padding: 10px 5px; position: relative; transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            cursor: default; 
            box-shadow: inset 0 4px 10px rgba(255,255,255,1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0,0,0,0.1);
            text-align: center;
            display: flex; flex-direction: column; align-items: center;
            min-height: 125px; 
            justify-content: flex-end;
            border: 2px solid #f8bbd0;
        }
        .elec-badge {
            position: absolute; top: -5px; right: -5px;
            background: #ffeb3b; color: #f57f17;
            font-weight: 900; border: 2px solid #fff;
            border-radius: 50%; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 5; animation: jelly-bounce 1s infinite;
        }
        
        .unit.active-turn { 
            border-color: var(--accent); 
            transform: translateY(-12px) scale(1.05); 
            z-index: 5; 
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3); 
        }
        .unit.target-enemy:hover { border-color: #ff7043; background: #ffebee; cursor: crosshair; transform: scale(1.05) rotate(2deg); }
        .unit.target-ally:hover { border-color: #66bb6a; background: #e8f5e9; cursor: pointer; transform: scale(1.05) rotate(-2deg); }
        .unit.target-aoe { border-color: #ff7043; background: #ffebee; animation: jelly-bounce 1s infinite; cursor: pointer; }
        .unit.dead { opacity: 0.6; filter: grayscale(1); pointer-events: none; border-color: #cfd8dc; transform: scale(0.9) rotate(5deg); box-shadow: none; }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon { 
            width: 48px; height: 48px; border-radius: 50%; margin-bottom: 4px; 
            display: flex; justify-content: center; align-items: center; font-size: 28px; 
            color: #fff; position: relative; 
            box-shadow: 0 4px 0 rgba(0,0,0,0.1); 
            border: 3px solid #fff;
        }
        
        .mini-attr-box {
            position: absolute; bottom: -2px; right: -2px; 
            display: flex; gap: 1px; background: rgba(255,255,255,0.95); 
            padding: 2px; border-radius: 12px; border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .mini-icon { font-size: 12px; line-height: 1; }
        
        .status-bar { width: 85%; height: 12px; background: #eceff1; border-radius: 12px; overflow: hidden; position: relative; margin-top: 4px; border: 2px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .hp-fill { height: 100%; background: var(--hp-high); border-radius: 10px; transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .hp-fill::after { content:''; position:absolute; top:2px; left:2px; right:2px; height:3px; background:rgba(255,255,255,0.4); border-radius:10px; }
        .shield-fill { position: absolute; top:0; left:0; height: 100%; background: var(--shield); opacity: 0.8; border-radius: 10px; transition: width 0.3s; }

        .control-panel { 
            flex: 0 0 auto; max-height: 45vh; 
            background: rgba(255,255,255,0.9); border-radius: 35px 35px 0 0; 
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15); 
            display: flex; flex-direction: column; overflow: hidden; width: 100%;
            border-top: 6px solid #ff80ab;
            backdrop-filter: blur(10px);
        }
        .cp-header { padding: 12px 20px; background: #fff8e1; display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dashed #ffe082; }
        
        .timeline-container { height: 50px; background: #fff; border-bottom: 2px dashed #ffcdd2; display: flex; align-items: center; padding: 0 15px; overflow: hidden; gap: 10px; }
        .timeline-label { font-size: 13px; font-weight: bold; color: var(--accent); margin-right: 5px; }
        .tl-node { 
            width: 32px; height: 32px; border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; font-size: 18px; 
            border: 3px solid #eee; position: relative; flex-shrink: 0; transition:0.3s; 
            background: #fff; box-shadow: 0 3px 0 #ddd;
        }
        .tl-node.curr { 
            border-color: var(--accent); transform: scale(1.2); z-index: 2; 
            box-shadow: 0 0 0 3px #ffecb3, 0 5px 10px rgba(255,64,129,0.2); 
        }
        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container { flex: 1; padding: 15px; overflow-y: auto; font-size: 14px; border-bottom: 2px solid #f0f0f0; background: #fff; line-height: 1.6; display: flex; flex-direction: column; min-height: 60px; }
        .log-entry { margin-bottom: 6px; padding: 8px 12px; background: #fafafa; border-radius: 15px; word-break: keep-all; border-left: 4px solid #eee; }
        .log-ally { color: #29b6f6; font-weight:bold; } .log-enemy { color: #ff7043; font-weight:bold; } .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; font-size: 1.1em; }
        
        .btn-group { display: flex; height: 90px; flex-shrink: 0; padding: 8px; gap: 8px; background: #fff5f8; }
        .skill-btn { 
            flex: 1; border: none; background: #fff; border-radius: 20px;
            cursor: pointer; transition: 0.2s; color: var(--text-main); display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; padding: 5px;
            box-shadow: var(--jelly-shadow); transform: translateY(0);
        }
        .skill-btn::before {
            content: ''; position: absolute; top: 5px; left: 10px; right: 10px; height: 40%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0));
            border-radius: 15px; pointer-events: none;
        }
        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform:none; }
        .skill-name { font-size: 15px; font-weight: bold; margin-bottom: 3px; }
        .skill-desc { font-size: 11px; color: #90a4ae; line-height: 1.2; }

        .passive-panel {
            background: #e0f2f1; padding: 8px 15px; font-size: 13px; color: #00695c;
            display: flex; align-items: center; border-radius: 15px; margin: 5px 15px;
            border: 2px solid #b2dfdb;
        }
        .passive-icon { margin-right: 8px; font-size: 16px; }
        
        .btn-start { 
            background: var(--accent); color: white; border: none; padding: 18px; 
            border-radius: 35px; font-weight: bold; width: 100%; margin-top: 15px; 
            cursor: pointer; font-size: 22px; box-shadow: 0 8px 0 #c2185b, 0 15px 20px rgba(0,0,0,0.15); 
            transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn-start::after { content:'ğŸ¾'; font-size:24px; margin-left:10px; opacity:0.8; }
        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(6px); box-shadow: 0 2px 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform:none; }

        .btn-rnd { background:#b39ddb; color:#fff; border:none; padding:10px 20px; border-radius:25px; cursor:pointer; font-weight:bold; margin-left:5px; box-shadow: 0 5px 0 #7e57c2; }
        .btn-rnd:active { transform: translateY(5px); box-shadow:none; }

        .tag-container { 
            position: relative; top: 0; left: 0; 
            width: 100%; display: flex; justify-content: center; 
            gap: 3px; flex-wrap: wrap; margin-bottom: 5px; 
            z-index: 10; 
        }
        .tag { padding: 4px 8px; border-radius: 12px; font-size: 10px; color: #fff; font-weight: bold; box-shadow: 0 2px 0 rgba(0,0,0,0.1); margin-bottom:2px; }
        
        .tag.poison { background: #ab47bc; } .tag.stun { background: #ffd54f; color:#5d4037; }
        .tag.freeze { background: #29b6f6; } .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; } .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; } .tag.bind { background: #66bb6a; } .tag.trap { background: #d4e157; color:#5d4037; }
        .tag.atkdown { background: #5c6bc0; } .tag.growth { background: #9ccc65; color:#33691e; }
        .tag.blind { background: #bdbdbd; color:#5d4037; }
        .tag.immunity { background: #fff; color:#5d4037; border:2px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color:#fff; }
        .tag.atkup { background: #ef5350; color:#fff; }
        .tag.taunt { background: #212121; color: #ff5252; border: 2px solid #ff1744; box-shadow: 0 0 8px rgba(255, 23, 68, 0.6); font-weight: 900; }
        .tag.karma { background: #512da8; color:#fff; border: 1px solid #d1c4e9; animation: jelly-bounce 2s infinite; }
        .tag.lifesteal { background: #b71c1c; color: #fff; border: 1px solid #ff8a80; box-shadow: 0 0 5px rgba(255, 0, 0, 0.4); } /* ì§„í•œ í•ë¹› */
        .tag.atkup_s { background: #0d47a1; color: #fff; border: 1px solid #82b1ff; font-weight: 900; } /* ì§„í•œ íŒŒë‘ */

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color:#1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color:#5d4037; }
        
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color:#5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        .float-text {
            position: absolute; font-weight: 900; font-size: 28px; pointer-events: none; z-index: 100;
            text-shadow: 2px 2px 0px #fff; animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; } 
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; } 
        }
        .ft-dmg { color: #ff7043; } .ft-crit { color: #ffa726; font-size: 36px; } 
        .ft-heal { color: #26a69a; } .ft-miss { color: #b0bec5; font-size: 20px; }

        #modal-overlay { position: fixed; inset: 0; background: rgba(255, 248, 225, 0.85); backdrop-filter:blur(5px); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #fff; padding: 25px; border-radius: 35px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3); overflow-y:auto; max-height:80vh; border: 5px solid #ffcc80; position: relative;}
        
        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }

        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }

        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }
    </style>
<script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div> <button class="mute-btn" id="btn-mute" onclick="AudioSys.toggleMute()">ğŸ”Š</button> <div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v8.2 Final Fix</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        <button id="btn-online" class="btn-start" style="background:#7e57c2; margin-top:5px;" onclick="startOnlineGame()">
             ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë§¤ì¹­ ì‹œì‘)
        </button>
        <button id="btn-start" class="btn-start" onclick="Game.start()" disabled>ì „íˆ¬ ì‹œì‘ (0/3)</button>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; font-size:16px; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
// [1] ì„œë²„ í†µì‹  ë° ë‚œìˆ˜ ë™ê¸°í™” ì„¤ì • (ìë™ ê°ì§€ ëª¨ë“œ)
let socket;

if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {}, emit: () => {}, connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì›¹ ë²„ì „ì—ì„œëŠ” 'í˜¼ìí•˜ê¸°'ì™€ 'ì—°ìŠµ ëŒ€ì „'ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ (Standalone Web)");
}

let myRole = null; 
let myRoom = null;
let isOnlineMode = false;

let netRndBuffer = []; 
let netRndIdx = 0; 
let isReplaying = false; 

function getNetRandom() {
    if (isOnlineMode && isReplaying) {
        return netRndBuffer[netRndIdx++] || Math.random(); 
    }
    const val = Math.random();
    if (isOnlineMode) netRndBuffer.push(val); 
    return val;
}

// 1. ê²Œì„ ì‹œì‘ ì‹ í˜¸ ìˆ˜ì‹  (í•­ìƒ ëŒ€ê¸°)
socket.on('gameStart', (data) => {
    isOnlineMode = true; 
    myRole = data.role;
    myRoom = data.room;
    
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);

    document.getElementById('selection-screen').style.display='none';
    document.getElementById('battle-screen').style.display='flex';
    document.getElementById('logs').innerHTML = ''; 

    Game.difficulty = 'online';
    Game.mode = 'pvp'; // [FIX] 'online' -> 'pvp'ë¡œ ëª¨ë“œëª… í†µì¼
    Game.turnCount = 1;
    Game.isOver = false;
    
    // 1PëŠ” [0(ë‚˜), 1(ì )...], 2PëŠ” [1(ì ), 0(ë‚˜)...] ìˆœì„œë¡œ í ì„¤ì •
    if (myRole === 'player2') {
        Game.queue = [1,0,3,2,5,4]; 
    } else {
        Game.queue = [0,1,2,3,4,5];
    }
    
    Game.curr = 0; 
    Game.isProcessing = false;
    Game.netRndBuffer = []; Game.netRndIdx = 0; Game.isReplaying = false;

    // [ì¤‘ìš” 2] ì ˆëŒ€ ID ë¶€ì—¬ (ì´ê²ƒ ë•Œë¬¸ì— ìŠ¤íƒ¯ì´ ì–‘ìª½ì—ì„œ ë˜‘ê°™ì´ ë‚˜ì˜´!)
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];

    // 1. ë‚´ íŒ€ ìƒì„± (My Team)
    Game.pTeam = Game.selected.map((idx, i) => { 
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra); 
    });
    
    // 2. ì  íŒ€ ìƒì„± (Enemy Team)
    const enemyIndices = data.enemyDeck; 
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx]; 
        return new Unit(enIds[i], 1, original.base, original.extra);
    });

    Game.render();
    
    // 2PëŠ” ëŒ€ê¸°, 1PëŠ” í„´ ì‹œì‘
    if (myRole === 'player2') {
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.timer = setTimeout(()=>Game.turn(), 1000);
    }
});

// 2. ìƒëŒ€ë°© í–‰ë™ ìˆ˜ì‹ 
socket.on('enemyAction', (data) => {
    // [ì¤‘ìš” 3] ì ˆëŒ€ IDë¡œ ìœ ë‹› ì°¾ê¸° (ë°°ì—´ ì¸ë±ìŠ¤ X)
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) {
        target = allUnits.find(u => u.id === data.targetId);
    }

    if(attacker) {
        Game.netRndBuffer = data.rndBuffer; 
        Game.netRndIdx = 0;
        Game.isReplaying = true; 
        
        Game.execute(attacker, target, data.skillIdx, true); 
        
        Game.isReplaying = false; 
    }
});

// 3. ì˜¨ë¼ì¸ ë§¤ì¹­ ì‹œì‘ í•¨ìˆ˜ (HTML ë²„íŠ¼ê³¼ ì—°ê²°ë¨)
function startOnlineGame() {
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\në¡œì»¬ í™˜ê²½ì´ê±°ë‚˜ ì„œë²„ê°€ êº¼ì ¸ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        return;
    }
    
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    
    const btn = document.getElementById('btn-online');
    if(btn.innerText.includes('ë§¤ì¹­ ì¤‘')) return;

    btn.disabled = true;
    btn.style.backgroundColor = '#ccc';
    btn.innerText = "ğŸ” ë§¤ì¹­ ìƒëŒ€ë¥¼ ì°¾ëŠ” ì¤‘... (ëŒ€ê¸°)";
    
    socket.emit('findMatch', { deck: Game.selected });
}

const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    // 1. íƒ±ì»¤ (4ëª…)
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+í”¼í•´í¡ìˆ˜', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ì  ë„ë°œ/ì‰´ë“œ+15', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë„ë°œ + ë€ê°', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ì‰´ë“œ+30/ê³µ+18 ì„±ì¥', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤<br>ìê°€ì„±ì¥ + í', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(2í„´)', s2:'í­ì£¼', s2d:'ê³µ+20(ì˜êµ¬)/ì•„êµ°ê³µ+10', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ ìµœëŒ€ 50ê¹Œì§€ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤.' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'íƒ€ê²Ÿí+ì•„êµ°íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ ì²´ë ¥íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },

    // 2. ë”œëŸ¬ (10ëª…)
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.5ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ (ìœ í†µê¸°í•œ)', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2í„´ ê³µ+20, 3~6í„´ ê³µ+10, 7í„´ ì´í›„ 0' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ì•„êµ°ë³´í˜¸', s2:'ì£¼ì‚¬ìœ„', s2d:'ëœë¤ í”¼í•´', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°©', passive:'ğŸ² ë©´ì—­: CCê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ ë“±)ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤. (ë„íŠ¸ë”œ ì œì™¸)' },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'ì²´ë ¥ë¹„ë¡€í”¼í•´', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì²´ë ¥ë¹„ë¡€ ë¸Œë£¨ì €', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+1í„´ê¸°ì ˆ', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' },
    
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ/ì¹¨ë¬µ', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ê¸°ì ˆ / ì¹¨ë¬µ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²°', passive:null },
    
    'Metal-Light': { s1:'ì •í™”ê°€ìŠ¤', s1d:'0.3ë°°/í•´ì œ/ìŠ¤íƒë‹¤ìš´', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…(3í„´)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë²„í”„ ì œê±° + ìŠ¤íƒ íŒŒê´´', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°+ì‰´ë“œë¬´ì‹œ', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì¹˜ìœ ê°ì†Œ(ê°•)+ë„íŠ¸', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì†ë°• + ì¹˜ìœ ê°ì†Œ', passive:null },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ìŠ¤íƒê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì„±ì¥ + ë°˜ì‚¬', passive:'ğŸ¥€ ë³µìˆ˜: ì‚¬ë§ ì‹œ ì  ì „ì²´ì—ê²Œ ë§¹ë…ì„ ê±¸ê³  ì•„êµ° í•˜ë‚˜ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },

    // 3. ì§€ì› (6ëª…)
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì•„êµ°ì „ì²´ HP+125', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì‰´ë“œê´€í†µ+í', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + íšŒë³µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+10', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê³µâ†“/ì‰´ë“œ50%ì†Œë©¸', type:'DEBUFF', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ë””ë²„í¼<br>ê³µí¬ + ë°˜ì‚¬', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ ë˜ëŒë ¤ì¤ë‹ˆë‹¤.' },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ', s2:'ë¸”ë™í™€', s2d:'í„´ ìŠ¤í‚µ(75%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ•³ï¸', desc:'ìŠ¤í˜ì…œë¦¬ìŠ¤íŠ¸<br>í„´ ì‚­ì œ', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ë¸”ë™í™€ ì„±ê³µ ì‹œ ê³µê²©ë ¥ì´ 10 ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.' }
};

const ChallengeDB = [
    { name: "í™”ì—¼ì˜ ì‹œë ¨", desc: "ë¶ˆ ì†ì„± ì ë“¤ì´ ë“±ì¥í•©ë‹ˆë‹¤.", team: ['Fire', 'Fire-Dark', 'Fire-Light'] },
    { name: "ìì—°ì˜ ë¯¸ë¡œ", desc: "ë‹¨ë‹¨í•œ ë‚˜ë¬´ì™€ ìˆ²ì´ ì•ì„ ë§‰ìŠµë‹ˆë‹¤.", team: ['Tree', 'Tree-Dark', 'Tree-Light'] },
    { name: "ê°•ì² ì˜ ìš”ìƒˆ", desc: "ëš«ì„ ìˆ˜ ì—†ëŠ” ë°©ì–´ì„ ì„ ëŒíŒŒí•˜ì„¸ìš”.", team: ['Metal', 'Metal-Dark', 'Metal-Light'] },
    { name: "í˜¼ëˆì˜ ì „ì¥", desc: "ê°•ë ¥í•œ í˜¼í•© ì†ì„± ì ë“¤ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.", team: ['Light-Light', 'Dark-Dark', 'Normal'] },
    { name: "ìµœí›„ì˜ ê²°ì „", desc: "ê°œë°œìê°€ ì¤€ë¹„í•œ ìµœê°•ì˜ ì¡°í•©ì…ë‹ˆë‹¤.", team: ['Water-Light', 'Fire-Light', 'Dark-Dark'] }
];

class Unit {
    constructor(id, team, base, extra) {
        this.id = id; this.team = team;
        this.base = base; this.extra = extra;
        
        // ì²´ë ¥ ì„¤ì •
        this.maxHp = 600; 
        if(base==='Tree' && extra==='Dark') this.maxHp = 700;
        if(base==='Fire' && extra==='Light') this.maxHp = 650; // í‘¸ë¥¸ë¶ˆ ìƒí–¥
        this.hp = this.maxHp; 
        
        this.shield = (base==='Metal' && !extra) ? 100 : 0;
        this.atk = 55 + (id * 7 % 15);
        
        this.status = []; this.isDead = false;
        
        this.thornStack = 0; this.linkedAllyId = -1;
        this.s2Count = 0; this.elecStacks = 0; this.growthStack = 0;
        this.resist = 0; 
        this.stats = { dmg: 0, heal: 0, shieldGiven: 0, taken: 0 }; 
        this.passiveTriggered = false;

        this.isNormal = this.base === 'Normal' || (this.base==='Light'&&this.extra==='Dark') || (this.base==='Dark'&&this.extra==='Light');
        this.isEnhanced = (this.base===this.extra && (this.base==='Light'||this.base==='Dark'));
        
        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }

    getKey() { 
        if(this.isNormal) return 'Normal'; 
        if(this.isEnhanced) return `${this.base}-${this.extra}`; 
        // SKILL_DB í‚¤ ìƒì„± ë¡œì§ (ë§¤ìš° ì¤‘ìš”)
        const key = `${this.base}-${this.extra}`;
        return SKILL_DB[key] ? key : this.base; 
    }
    
    getAtk() { 
        let v = this.atk; 
        // [ë¶ˆ íŒ¨ì‹œë¸Œ]
        if (this.base === 'Fire' && !this.extra) {
            const round = Math.ceil(Game.turnCount / 6);
            if (round <= 2) v += 20;
            else if (round <= 6) v += 10;
        }
        const ads = this.status.filter(s=>s.type==='ATK_DOWN'); 
        if(ads.length>0) v -= (ads.length*15); 
        if(this.hasStatus('LIGHT_MIGHT')) v += 10;
        if(this.hasStatus('ATK_BUFF_SMALL')) v += 10;
        return Math.max(10, v); 
    }
    
    resetTurn() { this.passiveTriggered = false; }

    takeDamage(dmg, isFire=false, ignoreShield=false, source=null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);
        
        // [ë©”íƒˆ íŒ¨ì‹œë¸Œ]
        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30); 
            if (dmg > cap && !this.passiveTriggered) { 
                dmg = cap; this.passiveTriggered = true; 
                UI.floatText(this, "Iron Will", "ft-heal"); 
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        
        // [ì¦ê¸° íšŒí”¼]
        if (this.hasStatus('EVADE')) { 
            if(Game.netRandom() < 0.40) { 
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                if (this.base === 'Water' && this.extra === 'Light') {
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                }
                return -1; 
            }
        }

        // [ì—…ë³´ ë°˜ì‚¬]
        if (source && source.id !== this.id && !source.isDead) {
             const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
             const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
             if (karma && !isDarkVsDark) {
                 const reflectDmg = Math.floor(dmg * 0.3);
                 if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null); 
                    this.stats.dmg += actualReflect; 
                    UI.floatText(source, reflectDmg, "ft-crit");
                 }
             }
        }
        
        this.stats.taken += dmg;
        let hpDmg = 0; let shieldDmg = 0;

        if (!ignoreShield && this.shield > 0) { 
            if(this.shield >= dmg) { shieldDmg = dmg; this.shield -= dmg; hpDmg = 0; } 
            else { shieldDmg = this.shield; hpDmg = dmg - this.shield; this.shield = 0; } 
        } else { hpDmg = dmg; }

        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            hpDmg += 10; this.stats.taken += 10; UI.floatText(this, "Crack!", "ft-crit"); 
        }

        this.hp = Math.max(0, this.hp - hpDmg);

        // [ì¦ê¸° íŒ¨ì‹œë¸Œ]
        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.passiveTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.passiveTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        return hpDmg + shieldDmg; 
    }

    addStatus(type, turn, val=0, source=null) {
        if (this.isNormal && ['FREEZE','STUN','SILENCE','BLIND','BANISH','ATK_DOWN','HEAL_DOWN','BIND','KARMA_VICTIM'].includes(type)) {
            UI.floatText(this, "Immune", "ft-miss"); return;
        }
        
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type)) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    return; 
                }
            }
        }

        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY')) { UI.floatText(this, "ë©´ì—­", "ft-miss"); return; }
            if (!source || source.id !== this.id) { this.status.push({type: 'IMMUNITY', turn: turn + 1}); }
        }

        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        
        if (type === 'ATK_DOWN') { 
            const s = this.status.filter(s=>s.type==='ATK_DOWN'); 
            if(s.length < 2) { this.status.push({type, turn, val}); } 
            else { const shortest = s.sort((a,b) => a.turn - b.turn)[0]; shortest.turn = turn; }
            return; 
        }
        
        const unique = ['BURN','HEAL_DOWN','LIGHT_MIGHT','LIFESTEAL_BUFF','ATK_BUFF_SMALL'];
        if(unique.includes(type)) { const ex = this.status.find(s=>s.type===type); if(ex) { ex.turn = turn; return; } }
        
        if (type.startsWith('KARMA_VICTIM_')) { const ex = this.status.find(s => s.type === type); if(ex) { ex.turn = turn; return; } }
        if (type.startsWith('PROVOKED_BY_') && source) type = `PROVOKED_BY_${source.id}`;

        const idx = this.status.findIndex(s=>s.type===type); 
        if(idx >= 0) this.status[idx].turn = turn; 
        else this.status.push({type, turn, val});
    }
    
    hasStatus(type) { return this.status.some(s=>s.type===type); }
    cleanse() { 
        const bad = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN','KARMA_VICTIM']; 
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM')); 
    }
    dispel() { const buffs = ['EVADE','DMG_RED','ATK_BUFF','GROWTH','LIGHT_MIGHT']; const has=this.status.some(s=>buffs.includes(s.type)); this.status=this.status.filter(s=>!buffs.includes(s.type)); return has; }
    
    tickStatus() {
        let log = [];
        if(this.hasStatus('POISON')) { const d=this.takeDamage(30, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ ${d}`); }
        if(this.hasStatus('BURN')) { const d=this.takeDamage(20, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ ${d}`); }
        if(this.hasStatus('TRAP')) { const d=this.takeDamage(40, false, false, null); UI.floatText(this, d, 'ft-dmg'); log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ í”¼í•´ ${d}`); }
        return log;
    }
    decayStatus() { this.status.forEach(s => s.turn--); this.status = this.status.filter(s => s.turn > 0); }
    heal(amount) { 
        if(this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4); 
        const prev=this.hp; this.hp=Math.min(this.maxHp, this.hp+amount); 
        const diff=this.hp-prev; 
        if(diff>0) { UI.floatText(this, diff, 'ft-heal'); }
        return diff; 
    }
}

const AudioSys = {
    ctx: null,
    isMuted: false, 
    init: function() { 
        if(this.ctx) return;
        try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} 
    },
    resume: function() { if(this.ctx&&this.ctx.state==='suspended') this.ctx.resume(); },
    
    toggleMute: function() {
        this.isMuted = !this.isMuted;
        const btn = document.getElementById('btn-mute');
        if(this.isMuted) {
            btn.innerHTML = 'ğŸ”‡';
            btn.classList.add('muted');
        } else {
            btn.innerHTML = 'ğŸ”Š';
            btn.classList.remove('muted');
        }
    },

    playSoft: function(freq, type, dur, vol=0.3) { 
        if(!this.ctx || this.isMuted) return; 
        const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const t=this.ctx.currentTime;
        o.type=type; o.frequency.setValueAtTime(freq,t);
        g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.1);
    },
    
    play: function(type) {
        if(!this.ctx || this.isMuted) return;

        if(type==='HIT') { 
            const rndFreq = 600 + (Math.random() * 100 - 50); 
            this.playSoft(rndFreq,'triangle',0.1,0.4); 
        } 
        else if(type==='SKILL') { this.playSoft(500,'sine',0.15,0.3); setTimeout(()=>this.playSoft(800,'sine',0.2,0.3),100); } 
        else if(type==='HEAL') { this.playSoft(500,'sine',0.2,0.3); setTimeout(()=>this.playSoft(700,'sine',0.3,0.3),150); }
        else if(type==='DEBUFF') { this.playSoft(300,'triangle',0.2,0.35); setTimeout(()=>this.playSoft(200,'triangle',0.2,0.35), 150); } 
        else if(type==='MISS') this.playSoft(900,'square',0.05,0.2); 
        else if(type==='WIN') { setTimeout(()=>this.playSoft(523,'sine',0.2,0.5),0); setTimeout(()=>this.playSoft(659,'sine',0.2,0.5),200); setTimeout(()=>this.playSoft(784,'sine',0.4,0.5),400); }
        else if(type==='POWER_UP') { 
            this.playSoft(440,'sine',0.2,0.35); setTimeout(()=>this.playSoft(554,'sine',0.2,0.35), 100); setTimeout(()=>this.playSoft(659,'sine',0.3,0.35), 200); 
        }
        else if(type==='CRITICAL') { this.playSoft(150,'triangle',0.1,0.6); setTimeout(()=>this.playSoft(880,'sine',0.3,0.7), 50); } 
    }
};

const UI = {
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() { document.getElementById('modal-overlay').style.display = 'none'; },
    
showGuide: function() {
        let heroList = '';
        
        // [ìˆ˜ì •ë¨] ë„ê° ì •ë ¬ ìˆœì„œ ì •ì˜ (ìš”ì²­í•˜ì‹  1~20ë²ˆ ìˆœì„œ)
        const guideOrder = [
            'Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', // 1~7 (ê¸°ì´ˆ)
            'Light-Light', 'Dark-Dark', 'Normal', // 8~10 (ì‹¬í™”/ë…¸ë§)
            'Fire-Light', 'Fire-Dark', // 11~12 (ë¶ˆ ì¡°í•©)
            'Water-Light', 'Water-Dark', // 13~14 (ë¬¼ ì¡°í•©)
            'Tree-Light', 'Tree-Dark', // 15~16 (ë‚˜ë¬´ ì¡°í•©)
            'Earth-Light', 'Earth-Dark', // 17~18 (í™ ì¡°í•©)
            'Metal-Light', 'Metal-Dark' // 19~20 (ì‡  ì¡°í•©)
        ];

        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            
            // ì´ë¦„ ìƒì„± ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
            if(k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if(parts.length===2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';

            heroList += `
            <div class="guide-item">
                <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div>
                <div class="guide-info">
                    <div class="guide-name">${name}</div>
                    <div class="guide-desc">${s.desc}</div>
                    <div style="font-size:10px; color:#555; margin-top:2px;">
                        <div>S1: ${s.s1} (${s.s1d})</div>
                        <div>S2: ${s.s2} (${s.s2d})</div>
                    </div>
                </div>
            </div>`;
        });

        const content = `
            <div class="tab-header">
                <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button>
                <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button>
            </div>
            <div id="tab-0" class="tab-content active">
                <table class="chart-table">
                    <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                    <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                    <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                    <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                    <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                    <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                    <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
                    <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr>
                </table>
                <div class="dual-chart">
                    <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                    <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div>
                </div>
            </div>
            <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;">
                ${heroList}
            </div>
        `;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if(i===idx) b.classList.add('active'); else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if(i===idx) c.classList.add('active'); else c.classList.remove('active');
        });
    },

    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id); if(!unitEl) return;
        
        const el = document.createElement('div'); el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        
        const rect = unitEl.getBoundingClientRect();
        // [ìˆ˜ì •] í…ìŠ¤íŠ¸ê°€ ê²¹ì¹˜ì§€ ì•Šê²Œ ëœë¤ ì¢Œí‘œ(-20px ~ +20px) ì¶”ê°€
        const randomX = (Math.random() - 0.5) * 40; 
        const randomY = (Math.random() - 0.5) * 20;
        
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px'; 
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        
        document.body.appendChild(el); setTimeout(() => el.remove(), 800);
    },
    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    
    // [v8.1] í„´ ì•Œë¦¼ ë°°ë„ˆ í‘œì‹œ í•¨ìˆ˜ (ì†ë„ ì¡°ì ˆ ë¡œì§ ì¶”ê°€)
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        // ë°°ë„ˆ ìŠ¤íƒ€ì¼ ë° í…ìŠ¤íŠ¸ ì„¤ì •
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)";
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ (í´ë˜ìŠ¤ ì œê±° ì—†ì´ styleë¡œ ì œì–´)
        banner.style.animation = 'none';
        void banner.offsetWidth; // Trigger Reflow
        
        // [v8.1] í„´ì´ 5í„´ì„ ë„˜ì–´ê°€ë©´ ë°°ë„ˆ ì†ë„ë¥¼ 2ë°° ë¹ ë¥´ê²Œ (1.2s -> 0.6s)
        const duration = Game.turnCount > 5 ? '0.6s' : '1.2s';
        banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`;
    },

    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);

        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        
        const mvp = allUnits.sort((a,b)=>(b.stats.dmg+b.stats.heal+b.stats.shieldGiven)-(a.stats.dmg+a.stats.heal+a.stats.shieldGiven))[0];

        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            
            return `
            <div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);">
                ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''}
                <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
                    <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div>
                    <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div>
                </div>
                <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;">
                    <span style="width:30px; color:#888;">ë”œ</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span>
                </div>
                <div style="display:flex; align-items:center; font-size:11px;">
                    <span style="width:30px; color:#888;">í</span>
                    <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;">
                        <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span>
                </div>
            </div>`;
        };

        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },
    checkMode: function() {
        Game.checkMode();
    }
};

const Game = {
    pool: [], selected: [], pTeam: [], eTeam: [], queue: [], curr: 0, selectedSkillIdx: -1, timer: null, turnCount: 1, difficulty: 'normal', watchdog: null,
    isOver: false, mode: 'pve', isProcessing: false,
    challengeStage: 0,
    
    // [ì¶”ê°€] ë™ê¸°í™”ëœ ëœë¤ í•¨ìˆ˜ ì—°ê²°
    netRandom: function() { return getNetRandom(); },

    // [FIX] ì´ˆê¸°í™” ë¡œì§ (ì¤‘ë³µ ì œê±° ë° ì •ìƒí™”)
    // [ìˆ˜ì •] ì´ˆê¸°í™” ë° ì˜ì›… ë¶„ë¥˜ ë Œë”ë§
    init: function() {
        if(this.timer) clearTimeout(this.timer);
        if(this.watchdog) clearTimeout(this.watchdog);
        this.isOver = false;
        
        this.pool = []; 
        this.selected = [];
        
        // [V9.6 ì˜ì›… ì •ë ¬] ìš”ì²­í•˜ì‹  ì—­í• êµ° ìˆœì„œëŒ€ë¡œ ì •ë ¬
        const allCombos = [
            // 1. íƒ±ì»¤ (4ëª…)
            {b:'Metal', e:null},      // ì‡  (ë°©ì–´í˜•)
            {b:'Tree', e:null},       // ë‚˜ë¬´ (ì„±ì¥í˜•)
            {b:'Fire', e:'Light'},    // í‘¸ë¥¸ë¶ˆ (ê³µê²©í˜•)
            {b:'Water', e:'Light'},   // ì¦ê¸° (ì„œí¿í˜•)

            // 2. ë”œëŸ¬ (10ëª…)
            // - ë©”ì¸ ë”œëŸ¬
            {b:'Fire', e:null},       // ë¶ˆ
            {b:'Normal', e:null},     // ì£¼ì‚¬ìœ„
            {b:'Fire', e:'Dark'},     // ê²€ì€ë¶ˆ
            {b:'Metal', e:'Dark'},    // ì „ê¸°
            {b:'Earth', e:'Dark'},    // ë°”ìœ„
            // - CCí˜•
            {b:'Earth', e:null},      // í™
            {b:'Water', e:'Dark'},    // ì–¼ìŒ
            // - íŠ¹ìˆ˜
            {b:'Metal', e:'Light'},   // ë…ê°€ìŠ¤
            {b:'Earth', e:'Light'},   // ëª¨ë˜
            {b:'Tree', e:'Dark'},     // ê°€ì‹œ

            // 3. ì§€ì› (6ëª…)
            // - íëŸ¬
            {b:'Water', e:null},      // ë¬¼
            {b:'Tree', e:'Light'},    // ìˆ²
            // - ë²„í¼
            {b:'Light', e:null},      // ë¹›
            {b:'Light', e:'Light'},   // ë¹›(ê°•í™”)
            // - ë””ë²„í¼
            {b:'Dark', e:null},       // ì–´ë‘ 
            // - ìŠ¤í˜ì…œ
            {b:'Dark', e:'Dark'}      // ì–´ë‘ (ê°•í™”)
        ];

        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        
        this.renderHeroSelection();
        
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        
        const btnOnline = document.getElementById('btn-online');
        if(btnOnline) {
            btnOnline.disabled = false;
            btnOnline.innerText = "ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ (ë§¤ì¹­ ì‹œì‘)";
            btnOnline.style.backgroundColor = '#7e57c2';
        }
        
        this.checkMode(); 
    },

   // [ì‹ ê·œ] ì˜ì›… ì„ íƒ í™”ë©´ ë Œë”ë§ (ì—­í• êµ° ë¶„ë¥˜)
  renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block'; 
        grid.style.overflowY = 'auto';

        const categories = [
            { name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)", range: [0, 3], color: "#e3f2fd", border: "#90caf9" },
            { name: "âš”ï¸ ë”œëŸ¬ (Dealer)", range: [4, 13], color: "#ffebee", border: "#ef9a9a" },
            { name: "ğŸ§© ì§€ì› (Support)", range: [14, 19], color: "#f1f8e9", border: "#a5d6a7" }
        ];

        categories.forEach(cat => {
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:10px; border-radius:5px; color:#455a64; text-align:left; box-sizing:border-box;`;
            header.innerText = cat.name;
            grid.appendChild(header);

            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; padding:10px 0;";
            
            for(let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const el = document.createElement('div');
                el.className = 'hero-card';
                el.id = `card-${i}`;
                el.innerHTML = this.renderCard(u);
                el.onclick = () => { this.toggle(i, el); };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },

    renderCard: function(u) {
        let bgClass = `bg-${u.base}`;
        if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
        if(u.isNormal) bgClass = 'bg-Normal';
        const info = SKILL_DB[u.getKey()];
        const icon = info.icon || ''; 
        return `<div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div><div style="font-weight:bold; margin-bottom:2px; font-size:15px;">${u.name.split(' ')[0]}</div><div style="font-size:11px; color:#999;">${u.name}</div><div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">${info.desc}</div>`;
    },

    // [FIX] í† ê¸€ ë¡œì§ ì•ˆì „ì¥ì¹˜ ì¶”ê°€
    toggle: function(i, el) {
        // í˜¹ì‹œ elì´ ì—†ìœ¼ë©´ IDë¡œ ë‹¤ì‹œ ì°¾ê¸°
        if (!el) el = document.getElementById(`card-${i}`);
        
        if(this.selected.includes(i)) {
            // ì´ë¯¸ ì„ íƒëœ ê±°ë©´ í•´ì œ
            this.selected = this.selected.filter(x=>x!==i);
            el.classList.remove('selected');
        } else {
            // ìƒˆë¡œ ì„ íƒ
            if(this.selected.length >= 3) {
                // 3ëª… ê½‰ ì°¼ì„ ë•Œ í”ë“¤ë¦¼ íš¨ê³¼ (ì„ íƒ ë¶ˆê°€ í”¼ë“œë°±)
                el.classList.add('shake');
                setTimeout(()=>el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        
        // ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },

    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if(el) el.classList.remove('selected');
        });
        Game.selected = [];
        while(Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if(!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if(el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            
            if(this.challengeStage > maxStage) this.challengeStage = maxStage;

            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }
    },
    
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },

    start: function() {
        AudioSys.init(); AudioSys.resume();
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        // [ìˆ˜ì •] 'local'(ì—°ìŠµ ëŒ€ì „)ë„ PvP ëª¨ë“œë¡œ ì¸ì‹ (ì¹œêµ¬ì™€ í° í•˜ë‚˜ë¡œ ëŒ€ê²° ê°€ëŠ¥)
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => { const u = this.pool[idx]; u.id=i; u.team=0; return u; });
        this.eTeam = [];
        this.isOver = false;
        
        const makeEnemy = (idx, b, e) => { const u = new Unit(idx + 3, 1, b, e); return u; };

        if (this.difficulty === 'hell') { 
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            
            const stageData = ChallengeDB[this.challengeStage];
            this.eTeam = stageData.team.map((key, i) => {
                let b, e;
                if(key === 'Normal') { b='Normal'; e=null; }
                else if(key.includes('-')) { [b, e] = key.split('-'); }
                else { b=key; e=null; }
                return makeEnemy(i, b, e);
            });
        } 
        else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => {
                const u = new Unit(i + 3, 1, pu.base, pu.extra);
                u.maxHp = Math.floor(u.maxHp * 1.15); u.hp = u.maxHp; u.atk = Math.floor(u.atk * 1.15); 
                return u;
            });
        } 
        else if (this.difficulty === 'hard') {
            const decks = [
                [{b:'Metal',e:'Light'}, {b:'Earth',e:'Light'}, {b:'Normal',e:null}], 
                [{b:'Metal',e:null}, {b:'Light',e:null}, {b:'Fire',e:'Light'}], 
                [{b:'Normal',e:null}, {b:'Light',e:'Light'}, {b:'Tree',e:null}], 
                [{b:'Fire',e:'Light'}, {b:'Earth',e:'Dark'}, {b:'Normal',e:null}], 
                [{b:'Dark',e:'Dark'}, {b:'Water',e:'Dark'}, {b:'Earth',e:null}], 
                [{b:'Tree',e:null}, {b:'Water',e:null}, {b:'Water',e:'Light'}], 
                [{b:'Earth',e:'Dark'}, {b:'Light',e:'Light'}, {b:'Metal',e:'Light'}], 
                [{b:'Tree',e:'Dark'}, {b:'Tree',e:null}, {b:'Water',e:'Light'}]
            ];
            const d = decks[Math.floor(Math.random()*decks.length)];
            this.eTeam = d.map((c, i) => makeEnemy(i, c.b, c.e));
        }
        else {
            const used = new Set();
            while(this.eTeam.length<3) {
                const b = ['Fire','Water','Tree','Metal','Earth','Light','Dark'][Math.floor(Math.random()*7)];
                const e = [null,'Light','Dark'][Math.floor(Math.random()*3)];
                if(b==='Dark'&&e==='Light') continue; 
                let key = `${b}-${e}`; if(b==='Light'&&e==='Dark') key = 'Normal';
                if(!used.has(key)) { used.add(key); this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); }
            }
        }

        this.queue = [0,1,2,3,4,5]; this.curr = Math.floor(Math.random()*6);
        this.turnCount = 1;
        this.isProcessing = false; 
        
        document.getElementById('selection-screen').style.display='none';
        document.getElementById('battle-screen').style.display='flex';
        document.getElementById('logs').innerHTML = ''; 
        
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1000);
    },

    turn: function() {
        this.isProcessing = false; 
        if (this.isOver) return;

        // 1. í˜„ì¬ í„´ì˜ ì£¼ì¸ì„ ë¨¼ì € íŒŒì•…í•©ë‹ˆë‹¤.
        const tVal = this.queue[this.curr];
        const u = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        const isMyTurn = (u.team === 0);

        // 2. [ìˆ˜ì •ë¨] Watchdog ë¡œì§: AI í„´ì¼ ë•Œë§Œ 3ì´ˆ ì œí•œ (ë¡œì»¬ 2PëŠ” ì‚¬ëŒì„)
        if(this.watchdog) clearTimeout(this.watchdog);
        // ì¡°ê±´ ì¶”ê°€: difficultyê°€ 'local'ì´ ì•„ë‹ ë•Œë§Œ ì‘ë™
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            this.watchdog = setTimeout(() => { console.log("AI Stuck. Forcing next."); this.endTurn(); }, 3000);
        }

        if(this.endCheck()) return;

        if(!u.isDead) u.resetTurn();

        if(u.isDead) { this.endTurn(true); return; }
        
        UI.showTurnBanner(isMyTurn);

        if(u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) {
            UI.floatText(u, "SKIP", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`);
            setTimeout(() => this.endTurn(), 800);
            return;
        }
        
        const tickLogs = u.tickStatus();
        tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if(u.hp<=0) { this.die(u); this.endTurn(); return; }

        let turnName = u.name.split(' ')[0];
        if (this.mode === 'pvp') turnName += (u.team === 0 ? " (ë‚˜)" : " (ì )");
        document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
        this.turnCount++;
        
        // [ì…ë ¥ ì œì–´]
        if(isMyTurn || this.difficulty === 'local') { 
            // ë‚´ í„´ì´ê±°ë‚˜ ì—°ìŠµ ëª¨ë“œë©´ ì¡°ì‘ ê°€ëŠ¥
            this.input(u); 
        } else { 
            // ìƒëŒ€ë°© í„´ì´ë©´ ì¡°ì‘ ë¶ˆê°€
            this.noInput(); 
            
            if (this.mode === 'pvp') {
                document.getElementById('turn-indicator').innerText = `ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...`;
            } else {
                // PvE(AI)ì¼ ë•Œë§Œ AI ì‘ë™
                this.timer=setTimeout(()=>this.ai(u), 800); 
            }
        }
    },
    
    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for(let i=0; i<6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx]; 
            const isP = qId % 2 === 0;
            const uIdx = isP ? qId/2 : (qId-1)/2;
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if(u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }

        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if(!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });

            team.forEach((u) => {
                const cardId = tid===0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId; d.dataset.uid = u.id; row.appendChild(d);
                }

                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;

                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;
                
                let tags = u.status.map(s => {
                    let c='tag'; 
                    // 1. CSS í´ë˜ìŠ¤ ë§¤í•‘ (ì˜ì–´ ID -> CSS í´ë˜ìŠ¤ëª…)
                    const map = {
                        'POISON':'poison','FREEZE':'freeze','SILENCE':'silence','EVADE':'evade','BURN':'burn',
                        'BANISH':'banish','TRAP':'trap','BIND':'bind','GROWTH':'growth','ATK_DOWN':'atkdown',
                        'BLIND':'blind','IMMUNITY':'immunity','HEAL_DOWN':'healdown',
                        'LIGHT_MIGHT':'atkup', 
                        'LIFESTEAL_BUFF':'lifesteal', // [NEW] í¡í˜ˆ ìŠ¤íƒ€ì¼ ì—°ê²°
                        'ATK_BUFF_SMALL':'atkup_s'    // [NEW] í­ì£¼ ë²„í”„ ìŠ¤íƒ€ì¼ ì—°ê²°
                    };
                    
                    if(s.type.includes('PROVOKED')) c+=' taunt';
                    else if(s.type.startsWith('KARMA_VICTIM')) c+=' karma';
                    else if(map[s.type]) c+=` ${map[s.type]}`;
                    
                    // 2. í…ìŠ¤íŠ¸ ë§¤í•‘ (ì˜ì–´ ID -> í•œê¸€ ì¶œë ¥)
                    let txt = s.type;
                    const tMap = {
                        'POISON':'ë…','FREEZE':'ë¹™ê²°','SILENCE':'ì¹¨ë¬µ','DMG_RED':'ë°©ì–´â†‘','EVADE':'íšŒí”¼','BURN':'í™”ìƒ',
                        'TRAP':'ì†ë°•','BANISH':'ì¶”ë°©','BIND':'ê²°ì†','GROWTH':'ì„±ì¥','ATK_DOWN':'ê³µê²©â†“','BLIND':'ì‹¤ëª…',
                        'IMMUNITY':'ë©´ì—­','HEAL_DOWN':'ì¹˜ìœ â†“','LIGHT_MIGHT':'ê³µê²©â†‘',
                        'LIFESTEAL_BUFF':'ğŸ©¸í¡í˜ˆ',        // [NEW] í•œê¸€í™”
                        'ATK_BUFF_SMALL':'ğŸ”¥ê³µê²©â†‘'       // [NEW] í•œê¸€í™”
                    };
                    
                    if(s.type.includes('PROVOKED')) txt='ë„ë°œ';
                    else if(s.type.startsWith('KARMA_VICTIM')) txt='ğŸ‘ï¸ì—…ë³´';
                    else if(tMap[s.type]) txt = tMap[s.type];

                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');

                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;

                let bgClass = `bg-${u.base}`;
                if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if(u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || ''; 

                let extraBadge = '';
                if(u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;

                const innerHTML = `
                    ${extraBadge}
                    <div class="tag-container">${tags}</div>
                    <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div>
                    <div class="unit-name" style="font-size:15px; margin-bottom:3px;">${u.name.split(' ')[0]} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div>
                    <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div>
                    <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div>
                `;
                if(d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0); draw('enemy-row', this.eTeam, 1);
    },
    
    endTurn: function(isFast = false) {
        if(this.isOver) return; 
        if(this.watchdog) clearTimeout(this.watchdog);
        
        const u = this.queue[this.curr]%2===0 ? this.pTeam[this.queue[this.curr]/2] : this.eTeam[(this.queue[this.curr]-1)/2];
        if(u && !u.isDead) u.decayStatus();

        if (this.curr === 0 && Math.ceil(this.turnCount / 6) >= 20) {
            [...this.pTeam, ...this.eTeam].forEach(u => {
                if(!u.isDead) u.atk += 10;
            });
            this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
        }

        [...this.pTeam, ...this.eTeam].forEach(u=>{if(u.hp<=0) this.die(u)});
        
        this.curr = (this.curr+1)%6;
        if(this.curr===0) this.turnCount++;
        
        this.render();
        const delay = isFast ? 100 : 1500; 
        this.timer = setTimeout(()=>this.turn(), delay);
    },

    reset: function() {
        if(this.timer) clearTimeout(this.timer);
        if(this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display='none';
        document.getElementById('selection-screen').style.display='flex';
        
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));
        this.selected = [];
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        
        this.init(); 
    },

    recordStat: function(unit, type, amount) {
        if(!unit || amount <= 0) return;
        if(type === 'dmg') unit.stats.dmg += amount;
        if(type === 'shield') unit.stats.shieldGiven += amount;
        if(type === 'heal') unit.stats.heal += amount;
    },

   input: function(u) {
        const k = u.getKey(); 
        const s = SKILL_DB[k];
        
        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì •ë³´ê°€ ì—†ìœ¼ë©´ ì—ëŸ¬ ë°©ì§€
        if (!s) { console.error("Skill info missing for:", k); return; }

        const silenced = u.hasStatus('SILENCE');
        
        document.getElementById('p-icon').innerText = s.icon;
        document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';

        document.getElementById('sk-1').innerHTML = `<span class="skill-name">${s.s1}</span><br><span class="skill-desc">${s.s1d}</span>`;
        document.getElementById('sk-2').innerHTML = `<span class="skill-name">${s.s2}</span><br><span class="skill-desc">${s.s2d}</span>`;
        document.getElementById('sk-0').disabled = false;
        document.getElementById('sk-1').disabled = silenced;
        
        let s2Limit = false;
        if (k === 'Fire-Light' && u.s2Count >= 5) s2Limit = true;
        let sk2Disable = silenced || s2Limit;
        
        if (k === 'Tree-Dark') {
            const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
            const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
            if (aliveAllies.length === 0 || u.linkedAllyId !== -1) sk2Disable = true;
        }
        
        document.getElementById('sk-2').disabled = sk2Disable;
        
        if(silenced) this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
        
        const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
        if(provoked) {
            const targetId = parseInt(provoked.type.split('_')[2]);
            const enemies = u.team === 0 ? this.eTeam : this.pTeam;
            const allies = u.team === 0 ? this.pTeam : this.eTeam;
            const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
            
            if(!target || target.isDead) {
                u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
                UI.floatText(u, "ììœ !", "ft-heal");
                this.render();
            } else {
                this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
                this.noInput(); 
                setTimeout(() => this.execute(u, target, 0), 1000);
                return;
            }
        }
        this.selectedSkillIdx = -1;
    },
    
    noInput: function() { [0,1,2].forEach(i=>{ const b = document.getElementById(`sk-${i}`); b.disabled=true; b.classList.remove('selected'); }); },

    prepareSkill: function(idx) {
        [0,1,2].forEach(i => { const b = document.getElementById(`sk-${i}`); if(i===idx) b.classList.add('selected'); else b.classList.remove('selected'); });
        this.selectedSkillIdx = idx;
        
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        
        const k = u.getKey(); const skillInfo = SKILL_DB[k];
        let targetType = (idx === 0 || idx === 1) ? 'ENEMY' : skillInfo.target;
        if(k==='Tree') { if(idx===1) targetType = 'SELF'; else if(idx===2) targetType = 'ALLY'; }
        if(k==='Water-Light' && idx===2) targetType = 'ALLY';
        this.highlightTargets(targetType, u);
    },

    highlightTargets: function(targetType, actingUnit) {
        if (!actingUnit) {
            const tVal = this.queue[this.curr];
            actingUnit = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
        }

        document.querySelectorAll('.unit').forEach(el => { 
            el.classList.remove('target-enemy', 'target-ally', 'target-aoe'); 
            el.onclick = null; 
        });

        const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
        const isAllyTarget = ['ALLY','ALL_ALLY','SELF','SELF_BUFF'].includes(targetType);
        
        const myTeam = actingUnit.team === 0 ? this.pTeam : this.eTeam;
        const oppTeam = actingUnit.team === 0 ? this.eTeam : this.pTeam;
        
        const targets = isAllyTarget ? myTeam : oppTeam;
        let targetClass = isAllyTarget ? 'target-ally' : 'target-enemy';
        if (isAOE && !isAllyTarget) targetClass = 'target-aoe'; 

        targets.forEach((t) => {
            if(!t.isDead) {
                if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2 && t.id === actingUnit.id) return;

                const el = document.getElementById(t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`);
                el.classList.add(targetClass);
                el.onclick = () => {
                    if (Game.isProcessing) return; 
                    Game.isProcessing = true;

                    if(targetType === 'SELF' && t.id !== actingUnit.id) return;
                    this.noInput();
                    document.querySelectorAll('.unit').forEach(el => el.classList.remove('target-enemy', 'target-ally', 'target-aoe'));
                    this.execute(actingUnit, t, this.selectedSkillIdx);
                };
            }
        });
    },

    ai: function(u) {
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;

        try {
            const silenced = u.hasStatus('SILENCE');
            
            // [ë„ë°œ ì²˜ë¦¬]
            const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if(provoked) {
                const targetId = parseInt(provoked.type.split('_')[2]);
                const target = this.pTeam.find(p => p.id === targetId) || this.eTeam.find(e => e.id === targetId);
                
                if(!target || target.isDead) {
                    u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
                    this.render();
                } else {
                    this.execute(u, target, 0); // ë„ë°œ ì‹œ í‰íƒ€ ê°•ì œ
                    return; 
                }
            }

            const enemies = u.team === 0 ? this.eTeam : this.pTeam; 
            const aliveEnemies = enemies.filter(e => !e.isDead);

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            // [ìˆ˜ì •ëœ AI ë¡œì§] S2 ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ ë³€ê²½
            // í™•ë¥ : í‰íƒ€(40%), S1(30%), S2(30%)
            let skillIdx = 0;
            const rnd = this.netRandom();
            
            if (!silenced) {
                if (rnd > 0.7) skillIdx = 2;      // 30% í™•ë¥ ë¡œ S2
                else if (rnd > 0.4) skillIdx = 1; // 30% í™•ë¥ ë¡œ S1
            }

            // íƒ€ê²Ÿ ì„ ì • (ëœë¤)
            let target = aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)];
            
            // [ì˜ˆì™¸ ì²˜ë¦¬] ìê°€ë²„í”„ë‚˜ ì•„êµ°ë²„í”„ ìŠ¤í‚¬ì¸ ê²½ìš° íƒ€ê²Ÿì„ ìì‹ /ì•„êµ°ìœ¼ë¡œ ë³€ê²½í•´ì•¼ ì•ˆì „í•¨
            // (execute í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ ì²˜ë¦¬í•˜ì§€ë§Œ, AIê°€ ëŒ€ìƒì„ ì˜¬ë°”ë¥´ê²Œ ì¡ë„ë¡ ë³´ì •)
            const k = u.getKey();
            if (skillIdx === 2 && ['Fire-Light', 'Tree'].includes(k)) target = u; // ìê°€ ë²„í”„
            
            this.execute(u, target, skillIdx);

        } catch (e) {
            console.error(e);
            this.endTurn(); 
        }
    },

  execute: function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el=>el.onclick=null);

        if (isOnlineMode && !isRemote) {
            if (atk.team !== 0) { alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!"); return; }
            Game.netRndBuffer = [];
        }

        const k = atk.getKey(); 
        const s = SKILL_DB[k];
        
        // ---------------------------------------------------------
        // 1. ìŠ¤í‚¬ íƒ€ì… ê²°ì • (Skill Type Resolution)
        // ---------------------------------------------------------
        let skillType = s.type || 'ATK';

        if (sIdx === 0) {
            skillType = 'ATK'; 
        } else {
            // [í‘¸ë¥¸ë¶ˆ] S1(í¡í˜ˆ), S2(í­ì£¼) ëª¨ë‘ 'ìì‹  í´ë¦­'ìœ¼ë¡œ ë°œë™
            if (k === 'Fire-Light') skillType = 'SELF_BUFF';
            
            // [ë‚˜ë¬´] S1(ì„±ì¥)ì€ ìì‹ , S2(í)ëŠ” ì•„êµ° íƒ€ê²Ÿ
            if (k === 'Tree') {
                if (sIdx === 1) skillType = 'SELF_BUFF';
                if (sIdx === 2) skillType = 'TARGET_BUFF';
            }
            
            // [ê¸°íƒ€] ì•„êµ° íƒ€ê²Ÿ ë²„í”„ë¥˜
            if (['Water-Light', 'Tree-Dark'].includes(k) && sIdx === 2) skillType = 'TARGET_BUFF';
        }

        // ë¡œê·¸ ë©”ì‹œì§€ ìƒì„±
        let m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ${sIdx===0?'ê³µê²©':(sIdx===1?s.s1:s.s2)}`;
        const isGlobal = ['AOE','HEAL','BUFF','ALL_ALLY'].includes(skillType) && sIdx === 2;
        if (!isGlobal && def) m += ` â” <b class="${def.team===0?'log-ally':'log-enemy'}">[${def.name}]</b>`;

        // ì‹¤ëª… ì²´í¬ (ê³µê²©í˜• ìŠ¤í‚¬ë§Œ)
        let blindMod = 1.0;
        const isOffensive = ['ATK', 'AOE', 'DEBUFF', 'NUKE', 'NUKE_PER', 'RANDOM'].includes(skillType);
        
        if (isOffensive && atk.hasStatus('BLIND')) {
            blindMod = 0; 
            m += " (ì‹¤ëª…ìœ¼ë¡œ ê³µê²© ë¬´íš¨!)"; 
            UI.floatText(atk, "BLINDED", "ft-miss"); 
        }

        const baseAtk = atk.getAtk();
        let playedSound = false;

        // ---------------------------------------------------------
        // 2. ì‹¤í–‰ ë¡œì§ (Execution Logic)
        // ---------------------------------------------------------

        if(sIdx === 0) { // [í‰íƒ€: ê¸°ë³¸ ê³µê²©]
            AudioSys.play('HIT'); playedSound=true;
            const aff = (def && def.team !== atk.team) ? this.calc(atk, def) : {v:1, t:''};
            const dmg = Math.floor(baseAtk * 1.0 * aff.v * blindMod);
            
            let act = -1;
            if (dmg > 0) act = def.takeDamage(dmg, false, false, atk);
            else { act = -1; AudioSys.play('MISS'); }

            Game.recordStat(atk, 'dmg', Math.max(0, act));
            
            if(act===-1) { m+=" ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
            else { 
                m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg");
                if (aff.v > 1.2) { AudioSys.play('CRITICAL'); UI.screenShake(); }
                
                // [í¡í˜ˆ íš¨ê³¼ ì ìš©] (ì²­ì—¼ íŒ¨ì‹œë¸Œ or ë²„í”„)
                if ((k === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                    const healAmt = Math.min(50, Math.floor(act * (k==='Fire-Light' ? 0.5 : 0.3)));
                    const h = atk.heal(healAmt);
                    // UIì—ëŠ” ì´ë¯¸ heal() ë‚´ë¶€ì—ì„œ í‘œì‹œë¨
                }
            }
        } 
        else { // [ìŠ¤í‚¬ ì‚¬ìš©]
            // ê³µí†µ íŒ¨ì‹œë¸Œ
            if (k === 'Metal-Dark' && sIdx === 1) { atk.elecStacks = Math.min(3, atk.elecStacks + 1); m += ` (âš¡ì¶©ì „)`; }

            // [TYPE 1] ìê°€ ë²„í”„ (SELF_BUFF)
            if (skillType === 'SELF_BUFF') {
                AudioSys.play('POWER_UP'); playedSound = true;
                
                // [í‘¸ë¥¸ë¶ˆ] S1 & S2
                if (k === 'Fire-Light') {
                    if (sIdx === 1) { // S1: í¡í˜ˆë¶€ì—¬ (ìì‹  í´ë¦­ -> ì•„êµ° ì „ì²´ ì ìš©)
                        const allies = atk.team === 0 ? this.pTeam : this.eTeam;
                        allies.forEach(a => { if(!a.isDead) a.addStatus('LIFESTEAL_BUFF', 2); });
                        m += " (ì•„êµ° ì „ì²´ ğŸ©¸í¡í˜ˆë¶€ì—¬)";
                    } 
                    else if (sIdx === 2) { // S2: í­ì£¼ (ìì‹  ê³µì¦ + ì•„êµ° ê³µë²„í”„)
                        atk.s2Count = Math.min(5, atk.s2Count + 1);
                        atk.atk += 20; // ì˜êµ¬ ì¦ê°€
                        m += ` (ğŸ”¥í­ì£¼! ê³µ+20)`; 
                        UI.floatText(atk, "í­ì£¼!", "ft-crit");
                        
                        // ì•„êµ° ì „ì²´ ê³µê²©ë ¥ ë²„í”„ ë¶€ì—¬
                        const allies = atk.team === 0 ? this.pTeam : this.eTeam;
                        allies.forEach(a => { if(!a.isDead) a.addStatus('ATK_BUFF_SMALL', 1); });
                        m += " / ì•„êµ° ê³µ+10";
                    }
                }
                
                // [ë‚˜ë¬´] S1
                if (k === 'Tree') {
                    atk.atk += 18; atk.shield += 30; Game.recordStat(atk, 'shield', 30);
                    atk.growthStack = (atk.growthStack || 0) + 1;
                    atk.addStatus('GROWTH', 99); 
                    m += " (ğŸŒ¿ì„±ì¥)"; UI.floatText(atk, "ì„±ì¥", "ft-heal");
                }
            }
            
            // [TYPE 2] íƒ€ê²Ÿ ì•„êµ° ë²„í”„ (TARGET_BUFF)
            else if (skillType === 'TARGET_BUFF') {
                AudioSys.play('HEAL'); playedSound = true;
                if (def) {
                    if (k === 'Tree') { 
                        const h = def.heal(150); Game.recordStat(atk, 'heal', h); 
                        def.cleanse(); m += " (ì •í™”+ì¹˜ìœ )"; 
                    }
                    if (k === 'Water-Light') { // ì¦ê¸° S2
                        const h = def.heal(80); Game.recordStat(atk, 'heal', h); 
                        // ëŒ€ìƒ ì œì™¸ íŒ€ì› ì „ì²´ íšŒí”¼
                        const allies = atk.team === 0 ? this.pTeam : this.eTeam;
                        allies.forEach(a => { if (!a.isDead && a.id !== atk.id) a.addStatus('EVADE', 2); });
                        m += " (ì•ˆê°œ: í/íŒ€ì›íšŒí”¼)"; 
                    }
                    if (k === 'Tree-Dark') { 
                        atk.linkedAllyId = def.id; def.addStatus('BIND', 99); 
                        atk.resist += 0.3; m += " (ì˜í˜¼ê²°ì†)"; 
                    }
                }
            }

            // [TYPE 3] ê´‘ì—­ ê³µê²© / ë””ë²„í”„ (AOE)
            else if (['AOE'].includes(skillType) || (skillType === 'DEBUFF' && s.target === 'ALL_ENEMY')) {
                m += " (ê´‘ì—­ ì‹œì „)";
                let mult = 0.8;
                if (k === 'Earth') { // 1:1 ë³´ë„ˆìŠ¤
                    const pAlive = this.pTeam.filter(u => !u.isDead).length; 
                    const eAlive = this.eTeam.filter(u => !u.isDead).length; 
                    if (pAlive === 1 && eAlive === 1) mult = 1.8; 
                }
                if (k === 'Metal' || k === 'Dark') mult = 0; 

                const enemies = atk.team === 0 ? this.eTeam : this.pTeam;
                enemies.forEach(e => {
                    if (!e.isDead) {
                        const aff = this.calc(atk, e);
                        const dmg = Math.floor(baseAtk * mult * aff.v * blindMod);
                        
                        // ë°ë¯¸ì§€
                        if (mult > 0 && dmg > 0) {
                            const act = e.takeDamage(dmg, k.startsWith('Fire'), false, atk);
                            Game.recordStat(atk, 'dmg', act);
                            if (act !== -1) { this.shake(e); UI.floatText(e, act, "ft-dmg"); }
                        } else if (blindMod === 0 && mult > 0) {
                            UI.floatText(e, "MISS", "ft-miss");
                        }

                        // ìƒíƒœì´ìƒ (ì‹¤ëª…ì´ì–´ë„ ìƒíƒœì´ìƒì€ ë“¤ì–´ê°)
                        if (blindMod > 0) {
                            if (k === 'Fire' && this.netRandom() < 0.25) e.addStatus('BURN', 2, 0, atk);
                            if (k === 'Earth') { if(this.netRandom()<0.25) e.addStatus('STUN', 1, 0, atk); else if(this.netRandom()<0.20) e.addStatus('SILENCE', 1, 0, atk); }
                            if (k === 'Dark') { 
                                e.addStatus('ATK_DOWN', 2, 0, atk); 
                                if(e.shield > 0) { // ì–´ë‘  ì‰´ë“œ 50% íŒŒê´´
                                    const lost = Math.ceil(e.shield * 0.5); e.shield -= lost;
                                    UI.floatText(e, `-${lost}ğŸ›¡ï¸`, "ft-crit");
                                }
                            }
                            if (k === 'Metal-Light') e.addStatus('POISON', 3, 0, atk);
                            if (k === 'Metal') e.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                            if (k === 'Metal-Dark' && this.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                        }
                    }
                });
                if (k === 'Metal') { atk.shield += 15; m += " (ë„ë°œ/ì‰´ë“œ)"; }
            }

            // [TYPE 4] ì•„êµ° ì „ì²´ ì§€ì› (HEAL/BUFF)
            else if (['HEAL', 'BUFF', 'ALL_ALLY'].includes(skillType)) {
                AudioSys.play('HEAL'); playedSound = true;
                const allies = atk.team === 0 ? this.pTeam : this.eTeam;
                allies.forEach(a => {
                    if (!a.isDead) {
                        if (k === 'Water') { const h = a.heal(125); Game.recordStat(atk, 'heal', h); }
                        if (k === 'Light') { a.shield += 70; a.addStatus('LIGHT_MIGHT', 1); }
                        if (k === 'Light-Light') { a.shield += 50; a.cleanse(); }
                        if (k === 'Tree-Light') { a.cleanse(); const h = a.heal(70); Game.recordStat(atk, 'heal', h); }
                    }
                });
                m += " (ì•„êµ° ì§€ì›)";
            }

            // [TYPE 5] ë‹¨ì¼ ê³µê²© (ATK / DEBUFF-Single)
            else if (def) {
                const aff = (def.team !== atk.team) ? this.calc(atk, def) : {v:1, t:''};
                let mult = 1.5;
                if (k === 'Water-Light') mult = 0.9;
                if (k === 'Fire-Dark' && sIdx === 1) mult = 1.0;
                if (k === 'Earth-Dark' && sIdx === 2) mult = 2.5;

                // [ë…ê°€ìŠ¤ S1] í•´ì œ ë° ìŠ¤íƒ ë‹¤ìš´
                if (k === 'Metal-Light' && sIdx === 1) {
                    mult = 0.3; 
                    const buffsToRemove = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT'];
                    const hadBuff = def.status.some(s => buffsToRemove.includes(s.type));
                    def.status = def.status.filter(s => !buffsToRemove.includes(s.type));
                    if(hadBuff) UI.floatText(def, "ë²„í”„í•´ì œ", "ft-miss");

                    let reduced = false;
                    // í‘¸ë¥¸ë¶ˆ, ì „ê¸°, ë‚˜ë¬´ ìŠ¤íƒ ê°ì†Œ
                    if (def.getKey() === 'Fire-Light' && def.s2Count > 0) { def.s2Count--; def.atk -= 20; reduced = true; }
                    if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) { def.elecStacks--; def.atk -= 10; reduced = true; }
                    if (def.getKey() === 'Tree' && def.growthStack > 0) { def.growthStack--; def.atk -= 18; def.shield = Math.max(0, def.shield - 30); reduced = true; }
                    
                    if (reduced) { m += " (ğŸ“‰ìŠ¤íƒ ë‹¤ìš´)"; UI.floatText(def, "ìŠ¤íƒ-1", "ft-miss"); }
                    else m += " (í•´ì œ)";
                }

                // [ì£¼ì‚¬ìœ„(Normal) S1] ì²´ë ¥ ì†Œëª¨ + ì•„êµ° ì‰´ë“œ
                if (k === 'Normal' && sIdx === 1) {
                    const cost = Math.floor(atk.maxHp * 0.1);
                    if (atk.hp > cost) {
                        atk.hp -= cost; UI.floatText(atk, `-${cost}`, "ft-dmg");
                        const allies = atk.team === 0 ? this.pTeam : this.eTeam;
                        const target = allies.filter(a => !a.isDead && a.id !== atk.id).sort((a,b) => a.hp - b.hp)[0];
                        if (target) {
                            target.shield += 50; Game.recordStat(atk, 'shield', 50);
                            m += ` / [${target.name}] ë³´í˜¸`;
                        }
                    }
                }

                let dmg = Math.floor(baseAtk * mult * aff.v * blindMod);
                
                // íŠ¹ìˆ˜ ë°ë¯¸ì§€ ê³„ì‚°
                if (k === 'Fire-Dark' && sIdx === 2) dmg = Math.floor((baseAtk * 1.0 * aff.v + def.maxHp * 0.1) * blindMod); 
                if (k === 'Normal') { 
                    const rnd = this.netRandom()*1.5 + 0.5; 
                    dmg = Math.floor(baseAtk * rnd * aff.v * blindMod); 
                    m += ` (ğŸ²x${rnd.toFixed(1)})`; 
                }

                // ë°ë¯¸ì§€ ì ìš©
                let act = -1;
                if (dmg > 0) act = def.takeDamage(dmg, k.startsWith('Fire'), k.includes('Light'), atk);
                else act = -1;

                Game.recordStat(atk, 'dmg', Math.max(0, act));

                if (act !== -1) {
                    m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                    UI.floatText(def, act, "ft-crit");
                    
                    // í¡í˜ˆ ë²„í”„
                    if (atk.hasStatus('LIFESTEAL_BUFF')) { const healAmt = Math.min(50, Math.floor(act * 0.3)); atk.heal(healAmt); }

                    // ìƒíƒœì´ìƒ ë¶€ì—¬
                    if (k === 'Fire' && sIdx === 1) def.addStatus('BURN', 2, 0, atk);
                    if (k === 'Water-Light' && this.netRandom() < 0.3) { def.addStatus('BLIND', 1, 0, atk); m += " (ì‹¤ëª…!)"; }
                    if (k === 'Water-Dark' && sIdx === 2 && this.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
                    if (k === 'Dark-Dark' && sIdx === 1) def.addStatus('SILENCE', 1, 0, atk);
                    if (k === 'Dark-Dark' && sIdx === 2 && this.netRandom() < 0.75) { def.addStatus('BANISH', 1, 0, atk); atk.atk += 10; m += " (ì¶”ë°©!)"; }
                    if (k === 'Earth-Dark' && sIdx === 2) atk.addStatus('STUN', 1, 0, atk);
                } else {
                    m += " ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss");
                }
            }
        }

        if (!playedSound) AudioSys.play('SKILL');
        this.log(m);
        this.postExecute(atk, def, sIdx, isRemote);
    },

    // [ì¶”ê°€] í–‰ë™ í›„ì²˜ë¦¬ ë° ì„œë²„ ì „ì†¡
    postExecute: function(atk, def, sIdx, isRemote) {
        if (isOnlineMode && !isRemote) {
            socket.emit('action', {
                room: myRoom,
                attackerId: atk.id, attackerTeam: atk.team,
                targetId: def ? def.id : null, targetTeam: def ? def.team : null,
                skillIdx: sIdx,
                rndBuffer: netRndBuffer 
            });
        }
        this.endTurn();
    },

    die: function(u) { 
        if(u.isDead) return; 
        u.isDead=true; u.hp=0; u.status=[]; 
        Game.log(`${u.name} íƒˆë½`); 
        
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team===0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => { 
                if(!e.isDead) e.addStatus('POISON', 1, 0, u); 
            });
        }

        const allies = u.team===0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base==='Tree' && a.extra==='Dark' && !a.isDead && a.linkedAllyId === u.id);
        
        thorns.forEach(thorn => {
            thorn.thornStack += 0.3; 
            thorn.atk += 20; 
            thorn.linkedAllyId = -1; 
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µê²©ë ¥ ì¦ê°€)`); 
            UI.floatText(thorn, "RAGE!", "ft-crit"); 
        });
    },
    
    endCheck: function() {
        const pd=this.pTeam.every(u=>u.isDead), ed=this.eTeam.every(u=>u.isDead);
        if(pd||ed) { 
            this.isOver = true; 
            if(this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN'); 
            
            if (ed && this.difficulty === 'hell' && !pd) { 
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if(this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)"); 
            }
            localStorage.removeItem('et_save_v6');
            return true; 
        } 
        return false;
    },
    
    log: function(m) { const b=document.getElementById('logs'); const d=document.createElement('div'); d.className='log-entry'; d.innerHTML=m; b.appendChild(d); b.scrollTop = b.scrollHeight; },
    
    shake: function(u) { const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`; const el = document.getElementById(id); if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); } },

    saveGame: function() {
        if (this.isOver) { alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue, curr: this.curr, turnCount: this.turnCount,
            difficulty: this.difficulty, mode: this.mode, selected: this.selected 
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },

    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if(savedStage) this.challengeStage = parseInt(savedStage);
        
        if (!json) { alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`); return; }

        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty; this.mode = data.mode;
            this.turnCount = data.turnCount; this.curr = data.curr;
            this.queue = data.queue; this.selected = data.selected;

            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));

            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = ''; 
            
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];
            
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;

            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) { console.error(e); alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤."); }
    },

    serializeUnit: function(u) {
        return {
            id: u.id, team: u.team, base: u.base, extra: u.extra,
            hp: u.hp, maxHp: u.maxHp, shield: u.shield, atk: u.atk,
            status: u.status, isDead: u.isDead,
            thornStack: u.thornStack, linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count, elecStacks: u.elecStacks,
            growthStack: u.growthStack, // [ì¶”ê°€] ë‚˜ë¬´ ì„±ì¥ ìŠ¤íƒ ì €ì¥!
            stats: u.stats,
            passiveTriggered: u.passiveTriggered // [ì¶”ê°€] ì¤‘ìš”!
        };
    },

    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        // ê¸°ë³¸ ìŠ¤íƒ¯ ë®ì–´ì“°ê¸°
        u.hp = d.hp; 
        u.maxHp = d.maxHp; 
        u.shield = d.shield; 
        u.atk = d.atk;
        u.status = d.status; 
        u.isDead = d.isDead;
        
        // íŠ¹ìˆ˜ ìŠ¤íƒ¯ ë° íŒ¨ì‹œë¸Œ ìƒíƒœ ë³µêµ¬
        if(d.thornStack) u.thornStack = d.thornStack;
        if(d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if(d.s2Count) u.s2Count = d.s2Count;
        if(d.elecStacks) u.elecStacks = d.elecStacks;
        if(d.growthStack) u.growthStack = d.growthStack; // [ì¶”ê°€] ë‚˜ë¬´ ì„±ì¥ ìŠ¤íƒ ë³µêµ¬!
        if(d.stats) u.stats = d.stats;
        if(d.passiveTriggered) u.passiveTriggered = d.passiveTriggered; // [ì¶”ê°€]

        return u;
    },
    
    calc: (a,d) => { // ì—¬ê¸°ë¶€í„° ë‹¤ì‹œ ì •ìƒ
        let v = 1.0;
        let t = '';
        if(a.isNormal) {
            if(d.isNormal || d.isEnhanced) { v=1.2; t='(ê°•íƒ€)'; }
        } else {
            const w={'Fire':['Metal','Tree'],'Water':['Fire','Metal'],'Tree':['Water','Earth'],'Metal':['Tree','Earth'],'Earth':['Fire','Water']};
            const ew={'Light':['Dark'],'Dark':['Light']};
            if(!d.isNormal){ 
                if(w[a.base]?.includes(d.base)||ew[a.base]?.includes(d.base)) { v=1.2; t='(ì•½ì )'; }
            }
        }
        if(v===1.2 && a.extra && d.extra && ((a.extra==='Light'&&d.extra==='Dark')||(a.extra==='Dark'&&d.extra==='Light'))) { v=1.3; t='(ì¹˜ëª…íƒ€!)'; }
        return {v, t};
    }
};

window.onload = function() { Game.init(); };
</script>
</body>
</html>
