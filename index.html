<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v12.0 Abyss Walker</title>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #fff5f8;
            --panel-bg: #ffffff;
            --text-main: #5d4037;
            --accent: #ff80ab;
            --hp-high: #80deea;
            --hp-low: #ffcc80;
            --shield: #ce93d8;
            --font-main: 'Jua', sans-serif;
            --jelly-shadow: inset 0 3px 6px rgba(255, 255, 255, 0.8), inset 0 -3px 6px rgba(0, 0, 0, 0.05), 0 5px 15px rgba(255, 128, 171, 0.25);
            --paw-pattern: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60' viewBox='0 0 100 100'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='24' fill='%23ffcdd2' opacity='0.5'%3EğŸ¾%3C/text%3E%3C/svg%3E");
        }

        body {
            margin: 0;
            background-color: var(--bg-main);
            background-image: var(--paw-pattern);
            background-size: 80px 80px;
            color: var(--text-main);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
        }

        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: 0.3s;
        }

        /* ì• ë‹ˆë©”ì´ì…˜ ì •ì˜ */
        .screen-shake {
            animation: jelly-bounce 0.5s both;
        }

        @keyframes jelly-bounce {
            0% { transform: scale(1, 1); }
            30% { transform: scale(1.15, 0.85); }
            40% { transform: scale(0.9, 1.1); }
            50% { transform: scale(1.05, 0.95); }
            65% { transform: scale(0.98, 1.02); }
            100% { transform: scale(1, 1); }
        }

        /* ê³µí†µ UI ì»´í¬ë„ŒíŠ¸ */
        button {
            font-family: var(--font-main);
            border-radius: 25px;
            border: none;
            background: #fff;
            color: #777;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
            border-radius: 20px;
            pointer-events: none;
        }

        button:active {
            transform: translateY(3px) scale(0.98);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .btn-restart {
            padding: 8px 12px;
            font-size: 14px;
            color: var(--accent);
        }

        .btn-restart:hover {
            background: #fff0f5;
        }

        .mute-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #eee;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: 0.2s;
        }

        .mute-btn:active {
            transform: scale(0.9);
        }

        .mute-btn.muted {
            background: #ffebee;
            color: #e57373;
            border-color: #ffcdd2;
        }

        /* ë ˆì´ì•„ì›ƒ */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 10;
            overflow: hidden;
        }

        #selection-screen {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(5px);
            overflow-y: auto;
        }

        #battle-screen {
            display: none;
            padding: 5px;
            height: 100%;
            justify-content: space-between;
        }

        /* ì˜ì›… ì¹´ë“œ (ì„ íƒ í™”ë©´) */
        .hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            overflow-y: auto;
            padding: 5px;
            flex: 1;
        }

        .hero-card {
            background: #fff;
            border-radius: 20px;
            padding: 6px;
            cursor: pointer;
            transition: 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05), inset 0 0 0 3px #fce4ec;
            position: relative;
            min-height: 100px;
            justify-content: center;
        }

        .hero-card:active {
            transform: scale(0.95);
        }

        .hero-card.selected {
            background: #e1bee7;
            box-shadow: 0 0 0 3px var(--accent), 0 8px 20px rgba(255, 128, 171, 0.4);
            transform: translateY(-5px);
        }

        .hero-card.selected::after {
            content: 'ğŸ¾';
            position: absolute;
            top: -10px;
            right: -5px;
            background: var(--accent);
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            z-index: 5;
            border: 2px solid #fff;
        }

        /* ì „íˆ¬ ìœ ë‹› (Battle Unit) */
        .field-row {
            flex: 1;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            width: 100%;
            perspective: 1000px;
            padding: 5px 0;
            min-height: 0;
        }

        .unit {
            width: 30vw;
            max-width: 130px;
            background: #fff;
            border-radius: 20px;
            padding: 8px 4px;
            position: relative;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: default;
            box-shadow: inset 0 4px 10px rgba(255, 255, 255, 1), 0 8px 0 #e0e0e0, 0 15px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 110px;
            justify-content: flex-end;
            border: 2px solid #f8bbd0;
            flex-shrink: 1;
            user-select: none;
            -webkit-user-select: none;
        }

        /* ê°ì„± ìŠ¤íƒ€ì¼ (Super Hero) */
        .unit.super-hero {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px rgba(255, 215, 0, 0.5) !important;
            animation: super-pulse 1.5s infinite alternate;
            z-index: 10;
        }

        @keyframes super-pulse {
            0% { box-shadow: 0 0 10px #ffb300; border-color: #ffb300; }
            100% { box-shadow: 0 0 25px #ff6f00; border-color: #ffca28; }
        }

        .unit.active-turn {
            border-color: var(--accent);
            transform: translateY(-12px) scale(1.05);
            z-index: 5;
            box-shadow: 0 0 0 3px var(--accent), 0 15px 0 #f48fb1, 0 20px 30px rgba(255, 64, 129, 0.3);
        }

        .unit.target-enemy:hover {
            border-color: #ff7043;
            background: #ffebee;
            cursor: crosshair;
            transform: scale(1.05) rotate(2deg);
        }

        .unit.target-ally:hover {
            border-color: #66bb6a;
            background: #e8f5e9;
            cursor: pointer;
            transform: scale(1.05) rotate(-2deg);
        }

        .unit.target-aoe {
            border-color: #ff7043;
            background: #ffebee;
            animation: jelly-bounce 1s infinite;
            cursor: pointer;
        }

        .unit.dead {
            opacity: 0.6;
            filter: grayscale(1);
            pointer-events: none;
            border-color: #cfd8dc;
            transform: scale(0.9) rotate(5deg);
            box-shadow: none;
        }

        .unit.role-tank { border-radius: 20px; }
        .unit.role-nuker { border-radius: 35px 15px; }
        .unit.role-supp { border-radius: 50px; }

        .attr-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            margin-bottom: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 26px;
            color: #fff;
            position: relative;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            border: 3px solid #fff;
            flex-shrink: 0;
        }

        .mini-attr-box {
            position: absolute;
            bottom: -2px;
            right: -2px;
            display: flex;
            gap: 1px;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px;
            border-radius: 12px;
            border: 2px solid #eee;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .mini-icon { font-size: 10px; line-height: 1; }

        .elec-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ffeb3b;
            color: #f57f17;
            font-weight: 900;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
            animation: jelly-bounce 1s infinite;
        }

        .status-bar {
            width: 85%;
            height: 10px;
            background: #eceff1;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin-top: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            flex-shrink: 0;
        }

        .hp-fill {
            height: 100%;
            background: var(--hp-high);
            border-radius: 10px;
            transition: width 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .hp-fill::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            height: 3px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 10px;
        }

        .shield-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--shield);
            opacity: 0.8;
            border-radius: 10px;
            transition: width 0.3s;
        }

        .control-panel {
            flex: 0 0 auto;
            max-height: 45vh;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px 30px 0 0;
            box-shadow: 0 -10px 40px rgba(255, 128, 171, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            width: 100%;
            border-top: 5px solid #ff80ab;
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        .cp-header {
            padding: 8px 15px;
            background: #fff8e1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px dashed #ffe082;
            font-size: 14px;
        }

        .timeline-container {
            height: 40px;
            background: #fff;
            border-bottom: 2px dashed #ffcdd2;
            display: flex;
            align-items: center;
            padding: 0 10px;
            overflow: hidden;
            gap: 5px;
            flex-shrink: 0;
        }

        .timeline-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent);
            margin-right: 5px;
        }

        @keyframes active-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0.7); }
            70% { box-shadow: 0 0 0 6px rgba(255, 128, 171, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 128, 171, 0); }
        }

        .tl-node {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            border: 2px solid #eee;
            position: relative;
            flex-shrink: 0;
            transition: 0.3s;
            background: #fff;
            box-shadow: 0 2px 0 #ddd;
        }

        .tl-node.curr {
            border-color: var(--accent);
            transform: scale(1.3);
            z-index: 2;
            border-width: 3px;
            animation: active-pulse 1.5s infinite;
        }

        .tl-node.ally { border-color: #81d4fa; background: #e1f5fe; }
        .tl-node.enemy { border-color: #ffcc80; background: #fff3e0; }

        .log-container {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-size: 12px;
            border-bottom: 2px solid #f0f0f0;
            background: #fff;
            line-height: 1.5;
            display: flex;
            flex-direction: column;
            min-height: 50px;
            max-height: 120px;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            background: #fafafa;
            border-radius: 10px;
            word-break: keep-all;
            border-left: 3px solid #eee;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .log-ally { color: #29b6f6; font-weight: bold; }
        .log-enemy { color: #ff7043; font-weight: bold; }
        .log-sys { color: #90a4ae; font-style: italic; }
        .log-crit { color: #fb8c00; font-weight: bold; }

        /* [UI ê°œì„ ] ë†’ì´ ìœ ë™ì  ë³€ê²½ (ì˜ë¦¼ ë°©ì§€) */
        .btn-group {
            display: flex;
            min-height: 80px;
            height: auto;
            flex-shrink: 0;
            padding: 5px;
            gap: 5px;
            background: #fff5f8;
        }

        .skill-btn {
            flex: 1;
            border: none;
            background: #fff;
            border-radius: 15px;
            cursor: pointer;
            transition: 0.2s;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 4px;
            box-shadow: var(--jelly-shadow);
            transform: translateY(0);
        }

        .skill-btn::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 10px;
            right: 10px;
            height: 40%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0));
            border-radius: 15px;
            pointer-events: none;
        }

        .skill-btn:hover:not(:disabled) { transform: translateY(-2px); }
        .skill-btn:active:not(:disabled) { transform: translateY(2px); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.1); }
        .skill-btn.selected { background: #e3f2fd; color: #1e88e5; box-shadow: inset 0 0 0 2px #42a5f5, var(--jelly-shadow); }
        .skill-btn:disabled { background: #f5f5f5; color: #ccc; cursor: not-allowed; box-shadow: none; transform: none; }
        
        .skill-name { font-size: 14px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #90a4ae; line-height: 1.1; }

        .passive-panel {
            background: #e0f2f1;
            padding: 5px 10px;
            font-size: 11px;
            color: #00695c;
            display: flex;
            align-items: center;
            border-radius: 10px;
            margin: 4px 10px;
            border: 1px solid #b2dfdb;
            flex-shrink: 0;
        }

        .passive-icon { margin-right: 5px; font-size: 14px; }

        .btn-start {
            background: var(--accent);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 20px;
            font-weight: bold;
            width: 100%;
            cursor: pointer;
            font-size: 18px;
            box-shadow: 0 5px 0 #c2185b, 0 10px 15px rgba(0, 0, 0, 0.15);
            transition: 0.2s;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .btn-start:hover { transform: translateY(-3px); }
        .btn-start:active { transform: translateY(5px); box-shadow: 0 0 0 #c2185b; }
        .btn-start:disabled { background: #b0bec5; cursor: not-allowed; box-shadow: none; transform: none; }

        .btn-rnd {
            background: #b39ddb;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            margin-left: 5px;
            box-shadow: 0 4px 0 #7e57c2;
        }

        .btn-rnd:active { transform: translateY(4px); box-shadow: none; }

        .tag-container {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            display: flex;
            justify-content: center;
            gap: 2px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
            max-height: 36px;
            overflow: hidden;
            align-content: flex-start;
        }

        .tag {
            padding: 2px 4px;
            border-radius: 6px;
            font-size: 9px;
            line-height: 1;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            margin-bottom: 1px;
            white-space: nowrap;
            height: 14px;
            display: flex;
            align-items: center;
        }

        .tag.poison { background: #ab47bc; }
        .tag.stun { background: #ffd54f; color: #5d4037; }
        .tag.freeze { background: #29b6f6; }
        .tag.silence { background: #78909c; }
        .tag.evade { background: #42a5f5; }
        .tag.burn { background: #ff7043; }
        .tag.banish { background: #263238; }
        .tag.bind { background: #66bb6a; }
        .tag.trap { background: #d4e157; color: #5d4037; }
        .tag.atkdown { background: #5c6bc0; }
        .tag.growth { background: #9ccc65; color: #33691e; }
        .tag.blind { background: #bdbdbd; color: #5d4037; }
        .tag.immunity { background: #fff; color: #5d4037; border: 1px solid #5d4037; }
        .tag.healdown { background: #8d6e63; color: #fff; }
        .tag.atkup { background: #ef5350; color: #fff; }
        .tag.taunt {
            background: #212121;
            color: #ff5252;
            border: 1px solid #ff1744;
            box-shadow: 0 0 4px rgba(255, 23, 68, 0.6);
            font-weight: 900;
        }
        .tag.karma {
            background: #512da8;
            color: #fff;
            border: 1px solid #d1c4e9;
            animation: jelly-bounce 2s infinite;
        }
        /* ì„ ê³µë°©ì–´ ë©´ì—­ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.start-immunity { background: #00bcd4; color: #fff; border: 1px solid #80deea; box-shadow: 0 0 5px #00e5ff; }
        /* [ì‹ ê·œ] ì„¸ë‡Œ ê´€ë ¨ íƒœê·¸ ìŠ¤íƒ€ì¼ */
        .tag.mc-wait { background: #5e35b1; color: #fff; border: 1px solid #b39ddb; animation: jelly-bounce 2s infinite; }
        .tag.mc-ready { background: #d500f9; color: #fff; border: 2px solid #ea80fc; box-shadow: 0 0 10px #d500f9; font-weight:900; }

        .bg-Fire { background: linear-gradient(135deg, #ff8a80, #ef5350); }
        .bg-Water { background: linear-gradient(135deg, #80d8ff, #29b6f6); }
        .bg-Tree { background: linear-gradient(135deg, #b9f6ca, #66bb6a); color: #1b5e20; }
        .bg-Metal { background: linear-gradient(135deg, #eceff1, #90a4ae); }
        .bg-Earth { background: linear-gradient(135deg, #ffe0b2, #ffa726); }
        .bg-Light { background: linear-gradient(135deg, #ffff8d, #ffee58); color: #5d4037; }
        .bg-Dark { background: linear-gradient(135deg, #ea80fc, #ab47bc); }
        .bg-Normal { background: linear-gradient(135deg, #fafafa, #bdbdbd); color: #5d4037; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #fdd835); border: 3px solid #fdd835; color: #5d4037; box-shadow: 0 0 15px #fff9c4; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #e1bee7, #8e24aa); border: 3px solid #8e24aa; box-shadow: 0 0 15px #e1bee7; }

        /* [ë°ë¯¸ì§€ í°íŠ¸ ì„¸ë¶„í™”] */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-size: 28px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 0px #fff;
            animation: floatUp 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }

        .ft-dmg { color: #ff7043; }
        .ft-crit { color: #ffa726; font-size: 36px; text-shadow: 2px 2px 0 #d84315; }
        .ft-heal { color: #26a69a; animation: floatUpSlow 1.2s ease-out forwards; }
        .ft-miss { color: #b0bec5; font-size: 20px; }
        .ft-weak { color: #d32f2f; font-size: 32px; font-weight: 900; animation: shake-dmg 0.4s ease-in-out; }
        .ft-resist { color: #78909c; font-size: 18px; opacity: 0.8; }

        @keyframes floatUp {
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
            30% { transform: translate(-50%, -30px) scale(1.3); opacity: 1; }
            100% { transform: translate(-50%, -60px) scale(1); opacity: 0; }
        }

        @keyframes floatUpSlow {
            0% { transform: translate(-50%, 0); opacity: 0; }
            50% { transform: translate(-50%, -40px); opacity: 1; }
            100% { transform: translate(-50%, -80px); opacity: 0; }
        }

        @keyframes shake-dmg {
            0%, 100% { transform: translate(-50%, -20px); }
            25% { transform: translate(-55%, -20px); }
            75% { transform: translate(-45%, -20px); }
        }

        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 248, 225, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 35px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 15px 50px rgba(255, 128, 171, 0.3);
            overflow-y: auto;
            max-height: 80vh;
            border: 5px solid #ffcc80;
            position: relative;
        }

        /* [ì»·ì‹ ] ìŠ¤íƒ€ì¼ */
        #cut-in-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .cut-in-img {
            font-size: 120px;
            animation: cut-in-zoom 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        .cut-in-text {
            font-size: 40px;
            color: #fff;
            font-weight: 900;
            margin-top: 20px;
            animation: slide-up 0.5s ease-out forwards;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes cut-in-zoom {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes slide-up {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        /* [íˆ´íŒ] ìŠ¤íƒ€ì¼ */
        #tooltip-view {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 150;
            max-width: 200px;
            pointer-events: none;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            line-height: 1.4;
            text-align: left;
        }

        .tooltip-title {
            font-weight: bold;
            color: var(--accent);
            margin-bottom: 5px;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 3px;
        }

        .tab-header { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .tab-btn { flex: 1; padding: 10px; border-radius: 15px; border: none; background: #f5f5f5; color: #888; font-weight: bold; cursor: pointer; }
        .tab-btn.active { background: var(--accent); color: #fff; box-shadow: 0 4px 10px rgba(255, 128, 171, 0.4); }
        .tab-content { display: none; text-align: left; }
        .tab-content.active { display: block; }
        .guide-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid #f0f0f0; }
        .guide-icon { width: 40px; height: 40px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 20px; border: 2px solid #eee; flex-shrink: 0;}
        .guide-info { flex: 1; font-size: 13px; }
        .guide-name { font-weight: bold; color: var(--text-main); margin-bottom: 2px; }
        .guide-desc { color: #888; font-size: 11px; }
        .chart-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-bottom: 15px; font-size: 14px; border: 3px solid #ffcc80; border-radius: 20px; overflow: hidden; }
        .chart-table th, .chart-table td { border-bottom: 1px solid #ffcc80; padding: 8px; text-align: center; }
        .chart-table th { background: #fff3e0; color: #ff9800; }
        .diff-select { margin: 0; padding: 10px; width: 100%; border-radius: 20px; border: 3px solid #b2dfdb; font-size: 14px; font-family: var(--font-main); color: #555; background: #fff; outline:none; }
        .atk-text { font-size: 12px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 10px; }

        @media (max-height: 700px) {
            .unit { min-height: 90px; width: 28vw; max-width: 110px; padding: 4px; }
            .attr-icon { width: 36px; height: 36px; font-size: 20px; }
            .unit-name { font-size: 12px !important; margin-bottom: 2px !important; }
            .status-bar { height: 8px; margin-top: 2px; }
            .control-panel { max-height: 45vh; }
            .btn-group { min-height: 72px; height: auto; }
            .skill-name { font-size: 12px; }
            .skill-desc { font-size: 10px; display: block; line-height: 1.2; }
            .cp-header { padding: 5px 10px; font-size: 12px; }
            .timeline-container { height: 35px; }
            .tl-node { width: 24px; height: 24px; font-size: 14px; }
            .log-container { min-height: 40px; max-height: 80px; padding: 5px; }
            .log-entry { font-size: 11px; padding: 2px 6px; margin-bottom: 2px; }
            .tag { font-size: 8px; padding: 1px 3px; height: 12px; }
            .tag-container { max-height: 26px; }
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>

<div id="flash-overlay"></div>
<div id="turn-banner"></div>
<!-- [ì»·ì‹ ] ì˜¤ë²„ë ˆì´ -->
<div id="cut-in-overlay">
    <div class="cut-in-img" id="cut-in-emoji">ğŸ¦</div>
    <div class="cut-in-text" id="cut-in-msg">FINISH!</div>
</div>
<!-- [íˆ´íŒ] ë·° -->
<div id="tooltip-view"></div>

<button class="mute-btn" id="btn-mute" onclick="AudioSys.toggleMute()">ğŸ”Š</button>

<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:15px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:25px; font-weight:bold; margin-top:15px; font-size:18px; box-shadow: 0 6px 0 #c2185b;">ë‹«ê¸° ğŸ¾</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h1 style="margin:0 0 5px 0; color:var(--accent); font-size: 32px; text-shadow: 3px 3px 0 #fff;">ğŸ¾ Elemental Tactics</h1>
            <p style="margin:0 0 5px 0; font-size:15px; color:#8d6e63;">v12.0 Abyss Walker</p>
            <p style="margin:0 0 15px 0; font-size:12px; color:#e57373; font-weight:bold;">â€» ë™ì¼ ì˜ì›…ì€ ì¤‘ë³µí•´ì„œ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
            <div style="display:flex; justify-content:center; gap:10px;">
                <button class="btn-restart" onclick="UI.showGuide()">ğŸ“– ê°€ì´ë“œë¶</button>
                <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚ ì´ì–´í•˜ê¸°</button>
            </div>
        </div>

        <div id="challenge-status" style="display:none; margin:0 10px 10px 10px; padding:10px; background:#fff3e0; border-radius:15px; border:2px dashed #ffb74d; text-align:center;">
            <div style="font-weight:bold; color:#f57c00; font-size:18px;">
                ğŸ† ì±Œë¦°ì§€ ìŠ¤í…Œì´ì§€ 
                <select id="stage-select" onchange="Game.selectStage()" style="font-size:16px; font-weight:bold; color:#f57c00; border:none; background:transparent; outline:none; border-bottom:2px solid #f57c00;">
                </select>
            </div>
            <div style="font-size:12px; color:#8d6e63; margin-top:5px;" id="stage-desc">ì¤€ë¹„ì¤‘...</div>
        </div>

        <div class="hero-grid" id="hero-grid"></div>
        
        <div style="background:#fff; padding:15px; border-radius:30px; margin-top:15px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); border: 4px solid #ffe0b2;">
            <div id="preview-info" style="font-size:14px; color:#888; margin-bottom: 10px;">ì˜ì›…ì„ í´ë¦­í•˜ë©´ ì •ë³´ê°€ ë‚˜ì™€ìš”!</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;" onchange="Game.checkMode()">
                      <option value="easy" selected>ğŸ£ ì‰¬ì›€ (AI)</option>
                      <option value="normal">ğŸ¤– ë³´í†µ (AI)</option>
                      <option value="hard">ğŸ”¥ ì–´ë ¤ì›€ (AI)</option>
                      <option value="hell">ğŸ† ì±Œë¦°ì§€ (ë„ì¥ê¹¨ê¸°)</option>
                      <option value="mirror">ğŸª ê±°ìš¸ ì „ìŸ (AI)</option>
                      <option value="local">âš”ï¸ ì—°ìŠµ ëŒ€ì „ (ì˜¤í”„ë¼ì¸ 2ì¸)</option> 
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        
        <div style="display:flex; gap:10px; margin-top:10px;">
            <button id="btn-online" class="btn-start" style="flex:1; background:#7e57c2; font-size:16px;" onclick="UI.openOnlineModal()">
                ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
            </button>
            <button id="btn-start" class="btn-start" style="flex:1; font-size:16px;" onclick="Game.start()" disabled>
                âš”ï¸ ì „íˆ¬ ì‹œì‘
            </button>
        </div>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; color:var(--accent);">Ready... ğŸ±</span>
                <div style="display:flex; gap:5px;">
                    <button class="btn-restart" onclick="Game.saveGame()">ğŸ’¾</button>
                    <button class="btn-restart" onclick="Game.loadGame()">ğŸ“‚</button>
                    <button class="btn-restart" onclick="UI.showGuide()">ğŸ“–</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ </button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:8px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>

<script>
let socket;
if (typeof io !== 'undefined') {
    socket = io();
    console.log("ğŸŒ ì˜¨ë¼ì¸ ëª¨ë“œ í™œì„±í™” (Server Connected)");
} else {
    socket = {
        on: () => {},
        emit: () => {},
        connected: false,
        connect: () => { alert("âš ï¸ ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
    };
    console.log("ğŸ“´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ");
}

let myRole = null;
let myRoom = null;
let isOnlineMode = false;
let netRndBuffer = [];
let netRndIdx = 0;
let isReplaying = false;

// [ì¶”ê°€] ê¸€ë¡œë²Œ ì—ëŸ¬ í•¸ë“¤ëŸ¬ (ê²Œì„ ë©ˆì¶¤ ë°©ì§€)
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('âš ï¸ Global Error:', {
        message: msg,
        line: lineNo,
        column: columnNo,
        error: error
    });
    
    // ê²Œì„ì´ ì´ë¯¸ ëë‚¬ê±°ë‚˜, Game ê°ì²´ê°€ ì—†ìœ¼ë©´ ë¬´ì‹œ
    if (typeof Game === 'undefined' || Game.isOver) return false;

    // ê²Œì„ ì¤‘ë‹¨ ë°©ì§€ (ìë™ ë³µêµ¬ ì‹œë„)
    if (Game.timer) clearTimeout(Game.timer);
    if (Game.watchdog) clearTimeout(Game.watchdog);
    
    // UIì— ì•Œë¦¼ í‘œì‹œ (Game.logê°€ ìˆë‹¤ë©´)
    if (Game.log) {
        Game.log("<span class='log-sys' style='color:red;'>âš ï¸ ì˜¤ë¥˜ ë°œìƒ! ìë™ ë³µêµ¬(í„´ ë„˜ê¸°ê¸°) ì‹œë„ ì¤‘...</span>");
    }

    // 1ì´ˆ ë’¤ ê°•ì œë¡œ í„´ì„ ë„˜ê²¨ì„œ ê²Œì„ì„ ì‚´ë¦¼
    setTimeout(() => {
        try {
            if (Game.endTurn) Game.endTurn();
        } catch(e) {
            console.error('Recovery failed:', e);
            alert("ì‹¬ê°í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.");
        }
    }, 1000);
    
    return true; // ì—ëŸ¬ê°€ ë¸Œë¼ìš°ì € ì½˜ì†”ì— ë¹¨ê°›ê²Œ ë„ë°°ë˜ëŠ” ê²ƒì„ ë°©ì§€
};

function getNetRandom() {
    if (isOnlineMode && isReplaying) return netRndBuffer[netRndIdx++] || Math.random();
    const val = Math.random();
    if (isOnlineMode) netRndBuffer.push(val);
    return val;
}

socket.on('gameStart', (data) => {
    isOnlineMode = true;
    myRole = data.role;
    myRoom = data.room;
    UI.closeModal();
    let roleText = myRole === 'player1' ? "ğŸ”µ ì„ ê³µ (1P)" : "ğŸ”´ í›„ê³µ (2P)";
    alert("ë§¤ì¹­ ì„±ê³µ! " + roleText);
    document.getElementById('selection-screen').style.display = 'none';
    document.getElementById('battle-screen').style.display = 'flex';
    document.getElementById('logs').innerHTML = '';
    Game.difficulty = 'online';
    Game.mode = 'pvp';
    Game.turnCount = 1;
    Game.isOver = false;

    if (myRole === 'player2') Game.queue = [1, 0, 3, 2, 5, 4];
    else Game.queue = [0, 1, 2, 3, 4, 5];
    Game.curr = 0;
    Game.isProcessing = false;
    Game.netRndBuffer = [];
    Game.netRndIdx = 0;
    Game.isReplaying = false;
    const myIds = myRole === 'player1' ? [0, 1, 2] : [3, 4, 5];
    const enIds = myRole === 'player1' ? [3, 4, 5] : [0, 1, 2];
    Game.pTeam = Game.selected.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(myIds[i], 0, original.base, original.extra);
    });
    const enemyIndices = data.enemyDeck;
    Game.eTeam = enemyIndices.map((idx, i) => {
        const original = Game.pool[idx];
        return new Unit(enIds[i], 1, original.base, original.extra);
    });
    Game.render();

    // [ì„ /í›„ê³µ ë³´ì •] ì˜¨ë¼ì¸ ëª¨ë“œ: í›„ê³µì—ê²Œ ë°©ì–´ë§‰ ë¶€ì—¬
    if (myRole === 'player2') {
        Game.pTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.log("<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ ë³´ë„ˆìŠ¤: ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ìƒíƒœ!</span>");
        Game.noInput();
        document.getElementById('turn-indicator').innerText = "ìƒëŒ€ë°©(1P)ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...";
    } else {
        Game.eTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        Game.timer = setTimeout(() => Game.turn(), 1000);
    }
});

socket.on('enemyAction', (data) => {
    const allUnits = [...Game.pTeam, ...Game.eTeam];
    const attacker = allUnits.find(u => u.id === data.attackerId);
    let target = null;
    if (data.targetId !== null) target = allUnits.find(u => u.id === data.targetId);
    if (attacker) {
        netRndBuffer = data.rndBuffer;
        netRndIdx = 0;
        isReplaying = true;
        Game.execute(attacker, target, data.skillIdx, true);
        isReplaying = false;
    }
});

socket.on('enemyDisconnect', () => {
    alert("ìƒëŒ€ë°© ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ìŠ¹ë¦¬ ì²˜ë¦¬ë©ë‹ˆë‹¤! ğŸ‰");
    UI.showResult("ìƒëŒ€ë°© ê¸°ê¶Œ (Disconnect)");
    isOnlineMode = false;
});

socket.on('waiting', (msg) => {
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.innerText = "â³ " + msg;
        btn.disabled = true;
    }
});

socket.on('errorMsg', (msg) => {
    alert(msg);
    const btn = document.getElementById('modal-submit-btn');
    if (btn) {
        btn.disabled = false;
        btn.innerText = "ì…ì¥í•˜ê¸° ğŸš€";
    }
});

function startOnlineGame(code) {
    AudioSys.init();
    if (!socket || !socket.connected) {
        alert("ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
        return;
    }
    if (Game.selected.length !== 3) {
        alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
        return;
    }
    socket.emit('findMatch', {
        deck: Game.selected,
        roomCode: code
    });
}

// ================= [ë°ì´í„° ì •ì˜] =================
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+30%ì‰´ë“œ', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ë„ë°œ(2í„´)/ì‰´ë“œ+15/ë°ë¯¸ì§€X', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', desc:'ë°©ì–´í˜• íƒ±ì»¤<br>ë°›ëŠ” í”¼í•´ MaxHP 30% ì œí•œ', passive:'ğŸ›¡ï¸ ê°•ì²  ë§·ì§‘: ì‰´ë“œ ë³´ìœ  ì‹œ, í•œ ë²ˆì— ë°›ëŠ” í”¼í•´ê°€ ìµœëŒ€ ì²´ë ¥ì˜ 30%ë¥¼ ë„˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ê³µ+18/ì‰´ë“œ+30(ì˜êµ¬ì¤‘ì²©)', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'ALLY', role:'tank', icon:'ğŸŒ³', desc:'ì„±ì¥í˜• íƒ±ì»¤<br>ìê°€ì„±ì¥ + í', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Fire-Light': { s1:'í¡í˜ˆë¶€ì—¬', s1d:'ì•„êµ°ì „ì²´ í¡í˜ˆ(2í„´)', s2:'í­ì£¼', s2d:'ìì‹ ê³µ+20(ì˜êµ¬)/ì „ì²´ê³µ+10', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ”·', desc:'ê³µê²©í˜• íƒ±ì»¤<br>í¡í˜ˆ + í­ì£¼', passive:'ğŸ©¸ í¡í˜ˆ: ë§¤ í„´ ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 25%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤. (ìµœëŒ€ 50)' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'0.9ë°°+ì‹¤ëª…(30%)', s2:'ì•ˆê°œ', s2d:'ìƒì€ì²´ë ¥15%í+íšŒí”¼', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'â˜ï¸', desc:'ì„œí¿í˜• íƒ±ì»¤<br>íšŒí”¼ + ì–´ê·¸ë¡œ', passive:'â˜ï¸ ê¸°í™”: ì²´ë ¥ 20% ì´í•˜ ì‹œ 1íšŒ ìë™ íšŒë³µ ë° íšŒí”¼ ìƒíƒœê°€ ë©ë‹ˆë‹¤.' },
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.6ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', desc:'ë©”ì¸ ë”œëŸ¬<br>ì´ˆë°˜ ê°•ë ¥ (ìœ í†µê¸°í•œ)', passive:'ğŸ”¥ ë¶ˆì˜ ê¸°ì„¸: 1~2í„´ ê³µ+20, 3~6í„´ ê³µ+10, 7í„´ ì´í›„ 0' },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ë‚´HP-30/ì‰´ë“œ60', s2:'ì£¼ì‚¬ìœ„', s2d:'0.8~2.3ë°° ëœë¤/ë…¸ì½”ìŠ¤íŠ¸', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ëœë¤ í•œë°©', passive:'ğŸ² ë©´ì—­: í–‰ë™ ì œì–´ê¸°(ê¸°ì ˆ,ë¹™ê²°,ì¹¨ë¬µ,ì„¸ë‡Œ)ì— ê±¸ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.' },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'1.0ë°°+ì MaxHP 10%ì¶”ê°€íƒ€', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', desc:'ë©”ì¸ ë”œëŸ¬<br>ì²´ë ¥ë¹„ë¡€ ë¸Œë£¨ì €', passive:'ğŸ”¥ ì†Œê°: ì ì˜ ì²´ë ¥ì´ ë§ì„ìˆ˜ë¡ ë” í° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³µê²©ë ¥10â†‘', s2:'ë°©ì „', s2d:'ê´‘ì—­ 0.8ë°°+ê¸°ì ˆ(15%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', desc:'ë©”ì¸ ë”œëŸ¬<br>ì„±ì¥í˜• ê´‘ì—­', passive:'âš¡ ê³¼ë¶€í•˜: S1 ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ 10 ì¦ê°€í•©ë‹ˆë‹¤ (ìµœëŒ€ 3íšŒ).' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+ìê°€ê¸°ì ˆ(2í„´)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', desc:'ë©”ì¸ ë”œëŸ¬<br>ê°•ë ¥í•œ í•œë°©', passive:'ğŸ—¿ ë°˜ë™: ì‚°ì‚¬íƒœ í›„ ê¸°ì ˆ ìƒíƒœì—ì„œëŠ” ë°›ëŠ” í”¼í•´ê°€ 10 ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ/ì¹¨ë¬µ', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°° (1:1ê°•í™”)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸœï¸', desc:'CCí˜• ë”œëŸ¬<br>ê¸°ì ˆ / ì¹¨ë¬µ', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'1.0ë°°+ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', desc:'CCí˜• ë”œëŸ¬<br>ë¹™ê²°', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.3ë°°/í•´ì œ/ìŠ¤íƒíŒŒê´´', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…(3í„´)', type:'DEBUFF', target:'ALL_ENEMY', role:'nuker', icon:'â˜£ï¸', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë²„í”„ ì œê±° + ìŠ¤íƒ íŒŒê´´', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°(ì‰´ë“œë¬´ì‹œ)', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì†ë°•+ì¹˜ìœ ê°ì†Œ(60%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'ğŸ¦‚', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ì†ë°• + ì¹˜ìœ ê°ì†Œ', passive:null },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ë°˜ì‚¬ê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì•„êµ°ê²°ì†/ì €í•­â†‘', type:'TARGET_BUFF', target:'ALLY', role:'nuker', icon:'ğŸ¥€', desc:'íŠ¹ìˆ˜ ë”œëŸ¬<br>ë³µìˆ˜ + ê²°ì†', passive:'ğŸ¥€ ë³µìˆ˜: ê²°ì†ëœ ì•„êµ° ì‚¬ë§ ì‹œ ê³µê²©ë ¥+20, S1ê³„ìˆ˜+0.3 ì˜êµ¬ ì¦ê°€.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì „ì²´120+(20%í™•ë¥ 50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', desc:'ë©”ì¸ íëŸ¬<br>ê´‘ì—­ íšŒë³µ', passive:null },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì•„êµ°ëœë¤í20', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', desc:'ë©”ì¸ íëŸ¬<br>ê³µê²© + íšŒë³µ', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+70/ê³µ+15', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', desc:'ë©”ì¸ ë²„í¼<br>ê´‘ì—­ ì‰´ë“œ', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', desc:'ë©”ì¸ ë²„í¼<br>ì •í™” + ì‰´ë“œ', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°+ì—…ë³´(ë°˜ì‚¬)', s2:'ê³µí¬', s2d:'ê´‘ì—­ 0.3ë°°/ê³µ35%â†“/ì‰´ë“œ30%íŒŒê´´', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', desc:'ê´‘ì—­ ë””ë²„í¼<br>ê³µí¬ + ì‰´ë“œíŒŒê´´', passive:'ğŸ‘ï¸ ì—…ë³´: ë‹¤í¬ë³¼ í”¼ê²©ìê°€ ìƒíƒœì´ìƒì„ ê±¸ë©´ 50% í™•ë¥ ë¡œ ë°˜ì‚¬.' },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ(1í„´)', s2:'ì •ì‹ ì§€ë°°', s2d:'HP15%ì†Œëª¨/ì  1íšŒ ì¡°ì¢…(ìŠ¤í„´X)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ§ ', desc:'ì‹¬ì—°ì˜ ì§€ë°°ì<br>ì  ì œì–´ê¶Œ íƒˆì·¨', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ì„¸ë‡Œ ì„±ê³µ ì‹œ ë‹¤ìŒ í„´ ì ì„ 1íšŒ ì¡°ì¢…í•©ë‹ˆë‹¤. í–‰ë™ í›„ ì¦‰ì‹œ í’€ë ¤ë‚©ë‹ˆë‹¤.' }
};

const ChallengeDB = [
    { name: "ë‰´ë¹„ ì ˆë‹¨ê¸°", desc: "ë‹¨ë‹¨í•œ ì‡ (Metal)ì™€ íëŸ¬ ì¡°í•©. ë”œì´ ë¶€ì¡±í•˜ë©´ ëš«ë‹¤ê°€ ì§€ì¹©ë‹ˆë‹¤.", team: ['Metal', 'Water', 'Fire'] },
    { name: "ë¹™ê²° ì§€ì˜¥", desc: "ì–¼ë¦¬ê³ (Water-Dark) ê¸°ì ˆ(Earth)ì‹œí‚¤ëŠ” ë¬´í•œ CC ì¡°í•©.", team: ['Water-Dark', 'Earth', 'Water'] },
    { name: "íšŒí”¼ & ìœ ì§€ë ¥", desc: "ì•ˆê°œ(Water-Light)ì™€ ìˆ²(Tree)ì˜ ë¬´í•œ ìœ ì§€ë ¥ ì¢€ë¹„ ë±.", team: ['Water-Light', 'Tree', 'Light-Light'] },
    { name: "CC ë©´ì—­ & ê¹¡ë”œ", desc: "CCë¥¼ ë¬´ì‹œí•˜ëŠ” ë…¸ë§(Normal)ê³¼ ê°•ë ¥í•œ í•œë°©.", team: ['Normal', 'Earth-Dark', 'Fire-Light'] },
    { name: "í„´ ì‚­ì œ (í˜ì˜¤)", desc: "ì–´ë‘  ê°•í™”(Dark-Dark)ì˜ í„´ ìŠ¤í‚µ ì–µê¹Œ ì¡°í•©. ê¸°ë„í•˜ì„¸ìš”.", team: ['Dark-Dark', 'Earth', 'Metal-Dark'] },
    { name: "ì ˆëŒ€ ë°©ì–´", desc: "ì‰´ë“œ, ì •í™”, íë¡œ ë¬´ì¥í•˜ì—¬ ì£½ì§€ ì•ŠëŠ” í†µê³¡ì˜ ë²½.", team: ['Light-Light', 'Tree-Light', 'Metal'] },
    { name: "ë””ë²„í”„ êµ°ë‹¨", desc: "í™”ìƒ, ë…, ê³µí¬, ë°˜ì‚¬ë¡œ ë§ë ¤ ì£½ì…ë‹ˆë‹¤.", team: ['Fire-Dark', 'Metal-Light', 'Dark'] },
    { name: "ì§€ì§„ ì„¤ê³„ì", desc: "ë°”ìœ„(Earth-Dark)ì˜ ê¸°ì ˆì„ ì •í™”í•˜ê³  ê³µë²„í”„ë¥¼ ì£¼ëŠ” ì—°ê³„ í”Œë ˆì´.", team: ['Earth-Dark', 'Light-Light', 'Light'] },
    { name: "ìµœì¢… ë³´ìŠ¤ (Ver.1)", desc: "ê°œë°œì ê³µì¸ 0í‹°ì–´. ì •í™”+CC+í„´ìŠ¤í‚µì˜ ì™„ë²½í•œ ì¡°í™”.", team: ['Dark-Dark', 'Light-Light', 'Water-Dark'] },
    { name: "ë°¸ëŸ°ìŠ¤ íŒŒê´´ì", desc: "í˜„ì¡´ ìµœê°•ì˜ ì‚¬ê¸°ìºë§Œ ëª¨ì•˜ìŠµë‹ˆë‹¤. ì´ê¸°ë©´ ê³ ìˆ˜ ì¸ì •.", team: ['Dark-Dark', 'Light-Light', 'Metal'] }
];

const Common = {
    logAction: function(game, type, source, target, value, extra='') {
        let msg = '';
        if (target) {
            msg = `<span class="${source.team===0?'log-ally':'log-enemy'}">[${source.name.split(' ')[0]}]</span>`;
            if (type === 'dmg') msg += ` âš”ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b class="log-crit">-${value}</b> ${extra}`;
            else if (type === 'heal') msg += ` âœšâ” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#2ecc71">+${value}</b> ${extra}`;
            else if (type === 'shield') msg += ` ğŸ›¡ï¸â” <span class="${target.team===0?'log-ally':'log-enemy'}">[${target.name.split(' ')[0]}]</span> : <b style="color:#ab47bc">+${value}</b> ${extra}`;
            else if (type === 'miss') msg += ` âš”ï¸â” [${target.name.split(' ')[0]}] : <span style="color:#aaa">ë¹—ë‚˜ê°!</span>`;
        } else { msg = `[${source.name.split(' ')[0]}] ${extra}`; }
        game.log(msg);
    },
    basicAttack: function(atk, def, game) {
        AudioSys.play('HIT');
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); UI.floatText(atk, "BLINDED", "ft-miss"); return; }
        const baseAtk = atk.getAtk();
        const aff = (def && def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * 1.0 * aff.v * blindMod);
        const act = def.takeDamage(dmg, false, false, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) {
            Common.logAction(game, 'dmg', atk, def, act, aff.t);
            const isCrit = (act >= 200) || (atk.isNormal && def.isNormal && act > baseAtk);
            let type = isCrit ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type);
            if (isCrit || aff.v > 1.0) { AudioSys.play('CRITICAL'); UI.screenShake(); } else game.shake(def);
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.20));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else {
            Common.logAction(game, 'miss', atk, def, 0); UI.floatText(def, "MISS", "ft-miss");
        }
    },
    applyDamage: function(atk, def, mult, game, ignoreShield=false, isFire=false) {
        const blindMod = atk.hasStatus('BLIND') ? 0 : 1;
        if(blindMod === 0) { UI.floatText(atk, "BLINDED", "ft-miss"); Common.logAction(game, 'miss', atk, def, 0, "(ì‹¤ëª…)"); return -1; }
        const baseAtk = atk.getAtk();
        const aff = (def.team !== atk.team) ? game.calc(atk, def) : {v:1, t:''};
        const dmg = Math.floor(baseAtk * mult * aff.v);
        const act = def.takeDamage(dmg, isFire, ignoreShield, atk);
        game.recordStat(atk, 'dmg', Math.max(0, act));
        if(act !== -1) { 
            let type = act>=200 ? "ft-crit" : "ft-dmg";
            if (aff.v > 1.0) type = "ft-weak";
            else if (aff.v < 1.0) type = "ft-resist";
            UI.floatText(def, act, type); 
            game.shake(def); 
            if ((atk.getKey() === 'Fire-Light') || atk.hasStatus('LIFESTEAL_BUFF')) {
                const healAmt = Math.min(50, Math.floor(act * 0.20));
                if(healAmt > 0) { atk.heal(healAmt); Common.logAction(game, 'heal', atk, atk, healAmt, "(í¡í˜ˆ)"); }
            }
        } else { 
            UI.floatText(def, "MISS", "ft-miss"); 
        }
        return act;
    },
    // [ìˆ˜ì •] ì„¸ë‡Œ ìƒíƒœì¼ ë•Œ í”¼ì•„ì‹ë³„ ë°˜ì „ ë¡œì§ (ê´‘ì—­ê¸° ë²„ê·¸ ìˆ˜ì •)
    forEachAlly: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (Game.isMindControlling && unit.id === Game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì ì´ ë‚´ ì•„êµ°
        }
        const team = effectiveTeam === 0 ? game.pTeam : game.eTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    },
    forEachEnemy: function(unit, game, callback) { 
        let effectiveTeam = unit.team;
        if (Game.isMindControlling && unit.id === Game.isMindControlling.id) {
            effectiveTeam = unit.team === 0 ? 1 : 0; // ì„¸ë‡Œë¨: ì›ë˜ ì•„êµ°ì´ ì 
        }
        const team = effectiveTeam === 0 ? game.eTeam : game.pTeam; 
        team.forEach(u => { if(!u.isDead) callback(u); }); 
    }
};

const SKILL_LOGIC = {
    'Fire': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™”ì—¼ë°©ì‚¬! ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.6, game, false, true);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) def.addStatus('BURN', 2, 0, atk);
            } else {
                game.log(`<b>[${atk.name}]</b> ë©”í…Œì˜¤! â˜„ï¸`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game, false, true);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.25) e.addStatus('BURN', 2, 0, atk);
                });
            }
        }
    },
    'Water': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë¬¼ëŒ€í¬! ğŸ’§`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ë¹„ ğŸŒ§ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    let amt = 120;
                    if (game.netRandom() < 0.2) {
                        amt += 50;
                        UI.floatText(a, "Lucky!", "ft-crit");
                    }
                    const h = a.heal(amt);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "");
                });
                return false;
            }
        }
    },
    'Tree': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê´‘í•©ì„± ğŸŒ¿`);
                AudioSys.play('POWER_UP');
                atk.atk += 18;
                atk.shield += 30;
                atk.growthStack = (atk.growthStack || 0) + 1;
                atk.addStatus('GROWTH', 99);
                game.recordStat(atk, 'shield', 30);
                UI.floatText(atk, "ì„±ì¥", "ft-heal");
                Common.logAction(game, 'shield', atk, atk, 30, "(ì„±ì¥)");
                return false;
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì¹˜ìœ ì˜ ì ğŸŒ¿`);
                AudioSys.play('HEAL');
                const h = def.heal(150);
                def.cleanse();
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(ì •í™”)");
                return false;
            }
        }
    },
    'Metal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°•ì² ë² ê¸° âš”ï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const absorb = Math.floor(act * 0.3);
                    atk.shield += absorb;
                    game.recordStat(atk, 'shield', absorb);
                    UI.floatText(atk, `+${absorb}ğŸ›¡ï¸`, "ft-heal");
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ê²°íˆ¬ì‹ ì²­ ğŸ’¢`);
                Common.forEachEnemy(atk, game, (e) => e.status = e.status.filter(s => !s.type.startsWith('PROVOKED')));
                def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk);
                atk.shield += 15;
                game.log(" (ë„ë°œ!)");
            }
        }
    },
    'Earth': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì•”ì„íˆ¬ì²™ ğŸª¨`);
                const act = Common.applyDamage(atk, def, 1.3, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1) {
                    if (game.netRandom() < 0.25) def.addStatus('STUN', 1, 0, atk);
                    else if (game.netRandom() < 0.20) def.addStatus('SILENCE', 1, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì§€ì§„ ğŸŒ‹`);
                let mult = 0.8;
                const pAlive = game.pTeam.filter(u => !u.isDead).length;
                const eAlive = game.eTeam.filter(u => !u.isDead).length;
                if (pAlive === 1 && eAlive === 1) mult = 1.8;
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, mult, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                });
            }
        }
    },
    'Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í™€ë¦¬ë³¼ âœ¨`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ìˆ˜í˜¸ì˜ ë¹› ğŸ›¡ï¸`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 70;
                    const existing = a.status.find(s => s.type === 'LIGHT_MIGHT');
                    const nextVal = existing ? (existing.val || 1) + 1 : 1;
                    const bonus = nextVal > 1 ? 20 : 15;
                    a.addStatus('LIGHT_MIGHT', 2, nextVal);
                    game.recordStat(atk, 'shield', 70);
                    Common.logAction(game, 'shield', atk, a, 70, `(ê³µ+${bonus})`);
                });
                return false;
            }
        }
    },
    'Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‹¤í¬ë³¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    def.addStatus(`KARMA_VICTIM_${atk.id}`, 2, 0, atk);
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ê³µí¬ ğŸ˜±`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.3, game);
                    if (act !== -1) {
                        Common.logAction(game, 'dmg', atk, e, act, "");
                        const hasFear = e.status.some(s => s.type === 'ATK_DOWN');
                        e.status = e.status.filter(s => s.type !== 'ATK_DOWN');
                        e.addStatus('ATK_DOWN', 2, hasFear ? 35 : 20, atk);
                        if (e.shield > 0) {
                            const brk = Math.floor(e.shield * 0.3);
                            e.shield -= brk;
                            UI.floatText(e, `-${brk}ğŸ›¡ï¸`, "ft-crit");
                        }
                    }
                });
            }
        }
    },
    'Normal': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                if (atk.hp > 30) {
                    atk.hp -= 30;
                    UI.floatText(atk, `-30`, "ft-dmg");
                    game.log(`<b>[${atk.name}]</b> ê· í˜•íƒ€ âš–ï¸`);
                    const act = Common.applyDamage(atk, def, 1.5, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const target = allies.filter(a => !a.isDead).sort((a, b) => a.hp - b.hp)[0];
                    if (target) {
                        target.shield += 60;
                        game.recordStat(atk, 'shield', 60);
                        Common.logAction(game, 'shield', atk, target, 60, "");
                    }
                } else {
                    UI.floatText(atk, "HPë¶€ì¡±", "ft-miss");
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì£¼ì‚¬ìœ„ ğŸ²`);
                const rnd = 0.8 + game.netRandom() * 1.5;
                const act = Common.applyDamage(atk, def, rnd, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, `(x${rnd.toFixed(1)})`);
            }
        }
    },
    'Fire-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì²­ì—¼ (í¡í˜ˆë¶€ì—¬)`);
                AudioSys.play('POWER_UP');
                Common.forEachAlly(atk, game, (a) => a.addStatus('LIFESTEAL_BUFF', 2));
                return false;
            } else {
                game.log(`<b>[${atk.name}]</b> í­ì£¼! ğŸ”¥`);
                AudioSys.play('HEAL');
                if ((atk.s2Count || 0) < 5) {
                    atk.s2Count = (atk.s2Count || 0) + 1;
                    atk.atk += 20;
                    UI.floatText(atk, "í­ì£¼!(ê³µ+20)", "ft-crit");
                } else {
                    UI.floatText(atk, "MAX!", "ft-crit");
                }
                Common.forEachAlly(atk, game, (a) => a.addStatus('ATK_BUFF_SMALL', 1));
                return false;
            }
        }
    },
    'Water-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìŠ¤íŒ€ì ¯ â˜ï¸`);
                const act = Common.applyDamage(atk, def, 0.9, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (game.netRandom() < 0.3) {
                        def.addStatus('BLIND', 1, 0, atk);
                        game.log(" (ì‹¤ëª…!)");
                    }
                }
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì•ˆê°œ ğŸŒ«ï¸`);
                AudioSys.play('HEAL');
                const healAmt = Math.floor((def.maxHp - def.hp) * 0.15);
                const h = def.heal(healAmt);
                game.recordStat(atk, 'heal', h);
                Common.logAction(game, 'heal', atk, def, h, "(íšŒí”¼ë¶€ì—¬)");
                Common.forEachAlly(atk, game, (a) => {
                    if (a.id !== atk.id) a.addStatus('EVADE', 2);
                });
                return false;
            }
        }
    },
    'Tree-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ìˆ²ì˜ë¶„ë…¸ ğŸŒ³`);
                const act = Common.applyDamage(atk, def, 1.2, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    const allies = atk.team === 0 ? game.pTeam : game.eTeam;
                    const alive = allies.filter(a => !a.isDead);
                    if (alive.length > 0) {
                        const t = alive[Math.floor(game.netRandom() * alive.length)];
                        const h = t.heal(20);
                        game.recordStat(atk, 'heal', h);
                        Common.logAction(game, 'heal', atk, t, h, "(ëœë¤í)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì¶•ë³µ âœ¨`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.cleanse();
                    const h = a.heal(70);
                    game.recordStat(atk, 'heal', h);
                    Common.logAction(game, 'heal', atk, a, h, "(ì •í™”)");
                });
                return false;
            }
        }
    },
    'Metal-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ìŠ¤íƒ„ â˜£ï¸`);
                const buffs = ['EVADE', 'ATK_BUFF_SMALL', 'LIGHT_MIGHT'];
                const hadBuff = def.status.some(s => buffs.includes(s.type));
                def.status = def.status.filter(s => !buffs.includes(s.type));
                if (hadBuff) UI.floatText(def, "í•´ì œ", "ft-miss");
                let reduced = false;
                if (def.getKey() === 'Fire-Light' && def.s2Count > 0) {
                    def.s2Count--;
                    def.atk -= 20;
                    reduced = true;
                }
                if (def.getKey() === 'Metal-Dark' && def.elecStacks > 0) {
                    def.elecStacks--;
                    def.atk -= 10;
                    reduced = true;
                }
                if (def.getKey() === 'Tree' && def.growthStack > 0) {
                    def.growthStack--;
                    def.atk -= 18;
                    def.shield = Math.max(0, def.shield - 30);
                    reduced = true;
                }
                if (reduced) {
                    game.log(" (ğŸ“‰ìŠ¤íƒ ë‹¤ìš´)");
                    UI.floatText(def, "ìŠ¤íƒ-1", "ft-miss");
                }
                const act = Common.applyDamage(atk, def, 0.3, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ë§¹ë…ì‚´í¬ â˜ ï¸`);
                Common.forEachEnemy(atk, game, (e) => e.addStatus('POISON', 3, 0, atk));
            }
        }
    },
    'Earth-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜í­í’ ğŸœï¸`);
                const act = Common.applyDamage(atk, def, 1.3, game, true);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "(ì‰´ë“œë¬´ì‹œ)");
            } else {
                game.log(`<b>[${atk.name}]</b> ëª¨ë˜ì§€ì˜¥ â³`);
                def.addStatus('TRAP', 2, 0, atk);
                def.addStatus('HEAL_DOWN', 2, 0, atk);
            }
        }
    },
    'Water-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê³ ë“œë¦„ â„ï¸`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì ˆëŒ€ì˜ë„ ğŸ¥¶`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (act !== -1 && game.netRandom() < 0.35) def.addStatus('FREEZE', 1, 0, atk);
            }
        }
    },
    'Fire-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> í‘ì—¼ ğŸŒ‘`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    Common.forEachEnemy(atk, game, (e) => e.addStatus('BURN', 2, 0, atk));
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ì†Œê° ğŸ”¥`);
                const act = Common.applyDamage(atk, def, 1.0, game);
                if (act !== -1) {
                    const extra = Math.floor(def.maxHp * 0.1);
                    def.takeDamage(extra, false, false, atk);
                    game.recordStat(atk, 'dmg', extra);
                    UI.floatText(def, `+${extra}`, "ft-crit");
                    Common.logAction(game, 'dmg', atk, def, act + extra, "(ì²´ë ¥ë¹„ë¡€)");
                } else {
                    Common.logAction(game, 'miss', atk, def, 0);
                }
            }
        }
    },
    'Tree-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ê°€ì‹œì°Œë¥´ê¸° ğŸŒµ`);
                const act = Common.applyDamage(atk, def, 1.5 + (atk.thornStack || 0), game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                if (!def) return;
                game.log(`<b>[${atk.name}]</b> ì˜í˜¼ê²°ì† ğŸ”—`);
                AudioSys.play('HEAL');
                if (def.team === atk.team) {
                    atk.linkedAllyId = def.id;
                    def.addStatus('BIND', 99);
                }
                return false;
            }
        }
    },
    'Metal-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì „ê¸°ì¶©ê²© âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) {
                    Common.logAction(game, 'dmg', atk, def, act, "");
                    if (atk.elecStacks < 3) {
                        atk.elecStacks++;
                        atk.atk += 10;
                        UI.floatText(atk, `âš¡${atk.elecStacks}`, "ft-crit");
                        game.log(" (âš¡ê³¼ë¶€í•˜)");
                    }
                }
            } else {
                game.log(`<b>[${atk.name}]</b> ë°©ì „ ğŸ”Œ`);
                Common.forEachEnemy(atk, game, (e) => {
                    const act = Common.applyDamage(atk, e, 0.8, game);
                    if (act !== -1) Common.logAction(game, 'dmg', atk, e, act, "");
                    if (act !== -1 && game.netRandom() < 0.15) e.addStatus('STUN', 1, 0, atk);
                });
            }
        }
    },
    'Earth-Dark': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ë‚™ì„ ğŸ§—`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì‚°ì‚¬íƒœ ğŸŒ‹`);
                const act = Common.applyDamage(atk, def, 2.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
                if (atk.hasStatus('IMMUNITY')) {
                    atk.status = atk.status.filter(s => s.type !== 'IMMUNITY');
                    UI.floatText(atk, "ë©´ì—­ì‚­ì œ", "ft-miss");
                }
                const ex = atk.status.find(s => s.type === 'STUN');
                if (ex) ex.turn = 2;
                else atk.status.push({
                    type: 'STUN',
                    turn: 2,
                    val: 0
                });
                UI.floatText(atk, "ğŸ’¤íœ´ì‹", "ft-miss");
                game.log("(ë°˜ë™:íœ´ì‹)");
            }
        }
    },
    'Light-Light': {
        useSkill: function(atk, def, sIdx, game) {
            if (sIdx === 0) Common.basicAttack(atk, def, game);
            else if (sIdx === 1) {
                game.log(`<b>[${atk.name}]</b> ì‹ ì˜ì‹¬íŒ âš¡`);
                const act = Common.applyDamage(atk, def, 1.5, game);
                if (act !== -1) Common.logAction(game, 'dmg', atk, def, act, "");
            } else {
                game.log(`<b>[${atk.name}]</b> ì„±ì—­ ğŸ°`);
                AudioSys.play('HEAL');
                Common.forEachAlly(atk, game, (a) => {
                    a.shield += 50;
                    a.cleanse();
                    game.recordStat(atk, 'shield', 50);
                    Common.logAction(game, 'shield', atk, a, 50, "(ì •í™”)");
                });
                return false;
            }
        }
    },
'Dark-Dark': {
    useSkill: function(atk, def, sIdx, game) {
        if (sIdx === 0) Common.basicAttack(atk, def, game);
        else if (sIdx === 1) {
            game.log(`<b>[${atk.name}]</b> ì‹¬ì—°ì¼ê²© ğŸ—¡ï¸`);
            const act = Common.applyDamage(atk, def, 0.9, game);
            if (act !== -1) {
                Common.logAction(game, 'dmg', atk, def, act, "");
                def.addStatus('SILENCE', 1, 0, atk);
            }
} else {
            // [ìˆ˜ì •] ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ (ë¡œì§ ê°•í™” v2)
            game.log(`<b>[${atk.name}]</b> ë§ˆì¸ë“œ ì»¨íŠ¸ë¡¤ ğŸ§ `);

            // [ì œì•½ 1] ì´ë¯¸ ëˆ„êµ°ê°€ë¥¼ ì¡°ì¢… ì¤‘ì´ë©´ ë¶ˆê°€
            if (Game.isMindControlling) {
                game.log("<span class='log-sys'>ğŸš« ì´ë¯¸ ì¡°ì¢… ì¤‘ì¸ ëŒ€ìƒì´ ìˆìŠµë‹ˆë‹¤!</span>");
                UI.floatText(atk, "ì‚¬ìš©ë¶ˆê°€", "ft-miss");
                return;
            }
            
            // [ì œì•½ 2] ë©´ì—­ ì²´í¬ (ë™ì¡± or ìƒíƒœì´ìƒ ë©´ì—­)
            // Normal(ê¸°ì´ˆ)ì€ íŒ¨ì‹œë¸Œë¡œ ë©´ì—­, Dark-Dark(ë™ì¡±) ë©´ì—­, ì´ë¯¸ ë©´ì—­ ìƒíƒœì¸ ì 
            if (def.getKey() === 'Dark-Dark' || def.hasStatus('IMMUNITY') || (def.isNormal && !def.extra)) {
                game.log("<span class='log-sys'>ğŸš« ì •ì‹  ì§€ë°°ê°€ í†µí•˜ì§€ ì•ŠëŠ” ëŒ€ìƒì…ë‹ˆë‹¤.</span>");
                UI.floatText(def, "ë©´ì—­", "ft-miss");
                return;
            }

            // 1. ì½”ìŠ¤íŠ¸ ì§€ë¶ˆ
            const cost = Math.floor(atk.hp * 0.15);
            atk.hp = Math.max(1, atk.hp - cost);
            UI.floatText(atk, `HPì†Œëª¨(-${cost})`, "ft-miss");
            
            // 2. í™•ë¥  ê³„ì‚°
            const missingPct = 1.0 - (def.hp / def.maxHp);
            const chance = 0.20 + (missingPct * 0.25);

            if (game.netRandom() < chance) {
                // ì„±ê³µ: ì„¸ë‡Œ ëŒ€ê¸°(MC_WAIT) ë¶€ì—¬
                // MC_WAITëŠ” 'ì •í™”' ìŠ¤í‚¬ë¡œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì „ëµì  ìš”ì†Œ)
                def.addStatus('MC_WAIT', 3, 0, atk, false); 
                game.log(` ğŸŒ€ <b>[${def.name}]</b> ì •ì‹  ì§€ë°° ì‹œì‘! (ë‹¤ìŒ í„´ ë°œë™)`);
                UI.floatText(def, "ì„¸ë‡Œ ëŒ€ê¸°", "ft-crit");
                AudioSys.play('DEBUFF');
            } else {
                // ì‹¤íŒ¨
                game.log(" (ì •ì‹  ì§€ë°° ì‹¤íŒ¨)");
                UI.floatText(def, "ì €í•­", "ft-miss");
            }
        }
    }
}
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id;
        this.team = team;
        this.base = base;
        this.extra = extra;
        this.maxHp = 600;
        if (base === 'Tree' && extra === 'Dark') this.maxHp = 700;
        if (base === 'Fire' && extra === 'Light') this.maxHp = 650;
        this.hp = this.maxHp;
        this.evadeTriggered = false;
        this.revengeAtk = 0;
        this.shield = (base === 'Metal' && !extra) ? 100 : 0;

        if (this.team === 1 && typeof Game !== 'undefined' && Game.difficulty === 'hell') {
            this.atk = 70;
        } else {
            this.atk = 55 + (id * 7 % 15);
        }

        this.status = [];
        this.isDead = false;
        this.thornStack = 0;
        this.linkedAllyId = -1;
        this.s2Count = 0;
        this.elecStacks = 0;
        this.growthStack = 0;
        this.resist = 0;
        this.stats = {
            dmg: 0,
            heal: 0,
            shieldGiven: 0,
            taken: 0,
            kills: 0
        };
        this.isSuper = false;
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
        this.isNormal = this.base === 'Normal' || (this.base === 'Light' && this.extra === 'Dark') || (this.base === 'Dark' && this.extra === 'Light');
        this.isEnhanced = (this.base === this.extra && (this.base === 'Light' || this.base === 'Dark'));

        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() {
        if (this.isNormal) return 'Normal';
        if (this.isEnhanced) return `${this.base}-${this.extra}`;
        return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base;
    }

    checkAwakening() {
        if (this.isSuper) return;
        const key = this.getKey();
        const role = SKILL_DB[key].role;
        let awakened = false;
        if (role === 'nuker') {
            if (this.stats.kills >= 2 || this.stats.dmg >= 1500) awakened = true;
        } else if (role === 'tank') {
            if (this.stats.taken >= 1000) awakened = true;
        } else if (role === 'supp') {
            if ((this.stats.heal + this.stats.shieldGiven) >= 1000) awakened = true;
        }
        if (awakened) {
            this.isSuper = true;
            UI.floatText(this, "âš¡AWAKENING!!âš¡", "ft-crit");
            AudioSys.play('AWAKEN');
            Game.render();
        }
    }

    getAtk() {
        let v = this.atk;
        if (this.base === 'Fire' && !this.extra) {
            const turn = Game.turnCount;
            if (turn <= 12) v += 20;
            else if (turn <= 36) v += 10;
        }
        if (this.revengeAtk > 0) v += this.revengeAtk;
        const lightMight = this.status.find(s => s.type === 'LIGHT_MIGHT');
        if (lightMight) {
            if ((lightMight.val || 1) <= 1) v += 15;
            else v += 20;
        }
        if (this.hasStatus('ATK_BUFF_SMALL')) v += 10;
        v = Math.max(10, v);
        const ads = this.status.filter(s => s.type === 'ATK_DOWN');
        if (ads.length > 0) {
            ads.forEach(s => {
                if (s.val > 0) v -= Math.floor(v * (s.val / 100));
                else v -= 15;
            });
        }
        return Math.max(0, v);
    }

    resetTurn() {
        this.passiveTriggered = false;
        this.metalPassiveUsed = false;
    }

    takeDamage(dmg, isFire = false, ignoreShield = false, source = null) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);

        if (this.base === 'Metal' && !this.extra && this.shield > 0) {
            const cap = Math.floor(this.maxHp * 0.30);
            if (dmg > cap) {
                dmg = cap;
                UI.floatText(this, "Iron Will", "ft-heal");
            }
        }

        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) {
            if (Game.netRandom() < 0.40) {
                UI.floatText(this, "íšŒí”¼!", "ft-miss");
                this.status = this.status.filter(s => s.type !== 'EVADE');
                return -1;
            }
        }
        if (source && source.id !== this.id && !source.isDead) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            const isDarkVsDark = (this.base === 'Dark' && source.base === 'Dark');
            if (karma && !isDarkVsDark) {
                const reflectDmg = Math.floor(dmg * 0.3);
                if (reflectDmg > 0) {
                    const actualReflect = source.takeDamage(reflectDmg, false, true, null);
                    this.stats.dmg += actualReflect;
                    UI.floatText(source, reflectDmg, "ft-crit");
                }
            }
        }

        this.stats.taken += dmg;
        let hpDmg = 0;
        let shieldDmg = 0;
        if (!ignoreShield && this.shield > 0) {
            if (this.shield >= dmg) {
                shieldDmg = dmg;
                this.shield -= dmg;
                hpDmg = 0;
            } else {
                shieldDmg = this.shield;
                hpDmg = dmg - this.shield;
                this.shield = 0;
            }
        } else {
            hpDmg = dmg;
        }
        if (hpDmg > 0 && this.base === 'Earth' && this.extra === 'Dark' && this.hasStatus('STUN')) {
            hpDmg += 10;
            this.stats.taken += 10;
            UI.floatText(this, "Crack!", "ft-crit");
        }
        this.hp = Math.max(0, this.hp - hpDmg);

        if (this.hp <= 0 && source) {
            source.stats.kills = (source.stats.kills || 0) + 1;
            if (source.isSuper && !source.isDead) {
                const allies = source.team === 0 ? Game.pTeam : Game.eTeam;
                const aliveAllies = allies.filter(a => !a.isDead);
                if (aliveAllies.length === 1 && aliveAllies[0].id === source.id) {
                    UI.showCutIn(source);
                }
            }
            if (source.checkAwakening) source.checkAwakening();
        }

        if (this.base === 'Water' && this.extra === 'Light' && this.hp > 0 && this.hp <= this.maxHp * 0.2 && !this.evadeTriggered) {
            const healAmt = Math.floor(this.maxHp * 0.1);
            this.hp += healAmt;
            this.addStatus('EVADE', 2);
            this.evadeTriggered = true;
            UI.floatText(this, `ê¸°í™”! (+${healAmt})`, "ft-heal");
        }

        this.checkAwakening();
        return hpDmg + shieldDmg;
    }

    addStatus(type, turn, val = 0, source = null, force = false) {
        const CC_LIST = ['STUN', 'FREEZE', 'BANISH', 'SILENCE', 'SLEEP'];
        
        if (this.hasStatus('START_IMMUNITY') && !force) {
            if (CC_LIST.includes(type)) { 
                UI.floatText(this, "ğŸ›¡ï¸CCë°©ì–´", "ft-miss");
                return;
            }
        }

        if (source && source.id !== this.id && !force) {
            const karma = source.status.find(s => s.type === `KARMA_VICTIM_${this.id}`);
            if (karma) {
                if (Game.netRandom() < 0.5) {
                    UI.floatText(this, "ë°˜ì‚¬!", "ft-crit");
                    source.addStatus(type, turn, val, null);
                    return;
                }
            }
        }
        const NORMAL_IMMUNE = ['FREEZE', 'STUN', 'BANISH', 'SILENCE'];
        if (this.isNormal && !force) {
            if (NORMAL_IMMUNE.includes(type) || type.startsWith('PROVOKED')) {
                UI.floatText(this, "Immune", "ft-miss");
                return;
            }
        }
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type) && !force) {
            if (source && source.id !== this.id) {
                if (Game.netRandom() < 0.40) {
                    UI.floatText(this, "íšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return;
                }
            }
        }
        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY') && !force) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            if (!source || source.id !== this.id || force) {
                this.status.push({
                    type: 'IMMUNITY',
                    turn: turn + 1
                });
            }
        }
        if (this.resist > 0 && Game.netRandom() < this.resist && ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN'].includes(type)) return;
        
        if (type === 'ATK_DOWN') {
            const s = this.status.filter(s => s.type === 'ATK_DOWN');
            if (s.length < 2) {
                this.status.push({
                    type,
                    turn,
                    val,
                    sourceId: source ? source.id : -1
                });
            } else {
                const shortest = s.sort((a, b) => a.turn - b.turn)[0];
                shortest.turn = turn;
                if(source) shortest.sourceId = source.id;
            }
            return;
        }

        const idx = this.status.findIndex(s => s.type === type);
    if (idx >= 0) {
        this.status[idx].turn = turn;
        if (val !== 0) this.status[idx].val = val;
        if (source) this.status[idx].sourceId = source.id; // âœ… ê°±ì‹  ì‹œì—ë„ sourceId ì €ì¥
    } else {
        this.status.push({
            type,
            turn,
            val,
            sourceId: source ? source.id : -1 // âœ… ì‹ ê·œ ìƒì„± ì‹œ sourceId ì €ì¥
        });
    }
}
    hasStatus(type) {
        return this.status.some(s => s.type === type);
    }
    cleanse() {
        const bad = ['POISON', 'BURN', 'FREEZE', 'STUN', 'SILENCE', 'BLIND', 'TRAP', 'BANISH', 'ATK_DOWN', 'KARMA_VICTIM', 'MC_WAIT'];
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED') && !s.type.startsWith('KARMA_VICTIM'));
    }
    dispel() {
        const buffs = ['EVADE', 'DMG_RED', 'ATK_BUFF', 'GROWTH', 'LIGHT_MIGHT'];
        const has = this.status.some(s => buffs.includes(s.type));
        this.status = this.status.filter(s => !buffs.includes(s.type));
        return has;
    }

    tickStatus() {
        let log = [];
        if (this.hasStatus('POISON')) {
            const d = this.takeDamage(35, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ -${d}`);
        }
        if (this.hasStatus('BURN')) {
            const d = this.takeDamage(20, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ -${d}`);
        }
        if (this.hasStatus('TRAP')) {
            const d = this.takeDamage(40, false, false, null);
            UI.floatText(this, d, 'ft-dmg');
            log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ -${d}`);
        }
        return log;
    }
    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    heal(amount) {
        if (this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.4);
        const prev = this.hp;
        this.hp = Math.min(this.maxHp, this.hp + amount);
        const diff = this.hp - prev;
        if (diff > 0) {
            UI.floatText(this, diff, 'ft-heal');
        }
        this.checkAwakening();
        return diff;
    }
}

// ... (ì´í•˜ Game ê°ì²´ ë° ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” ì˜¤ë¥˜ê°€ ì—†ì–´ ê·¸ëŒ€ë¡œ ìœ ì§€ë˜ë‚˜, Unit í´ë˜ìŠ¤ì™€ SKILL_DB ìˆ˜ì •ì´ ì ìš©ëœ ì „ì²´ íŒŒì¼ì…ë‹ˆë‹¤)
const AudioSys = {
    ctx: null,
    isMuted: false,
    init: function() {
        if (this.ctx) return;
        try {
            this.ctx = new(window.AudioContext || window.webkitAudioContext)();
        } catch (e) {}
    },
    resume: function() {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },
    toggleMute: function() {
        this.isMuted = !this.isMuted;
        const btn = document.getElementById('btn-mute');
        if (this.isMuted) {
            btn.innerHTML = 'ğŸ”‡';
            btn.classList.add('muted');
        } else {
            btn.innerHTML = 'ğŸ”Š';
            btn.classList.remove('muted');
        }
    },
    playSoft: function(freq, type, dur, vol = 0.3) {
        if (!this.ctx || this.isMuted) return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const t = this.ctx.currentTime;
        o.type = type;
        o.frequency.setValueAtTime(freq, t);
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t + 0.05);
        g.gain.exponentialRampToValueAtTime(0.001, t + dur);
        o.connect(g);
        g.connect(this.ctx.destination);
        o.start(t);
        o.stop(t + dur + 0.1);
    },
    play: function(type) {
        if (!this.ctx || this.isMuted) return;
        if (type === 'HIT') {
            const rndFreq = 600 + (Math.random() * 100 - 50);
            this.playSoft(rndFreq, 'triangle', 0.1, 0.4);
        } else if (type === 'SKILL') {
            this.playSoft(500, 'sine', 0.15, 0.3);
            setTimeout(() => this.playSoft(800, 'sine', 0.2, 0.3), 100);
        } else if (type === 'HEAL') {
            this.playSoft(500, 'sine', 0.2, 0.3);
            setTimeout(() => this.playSoft(700, 'sine', 0.3, 0.3), 150);
        } else if (type === 'DEBUFF') {
            this.playSoft(300, 'triangle', 0.2, 0.35);
            setTimeout(() => this.playSoft(200, 'triangle', 0.2, 0.35), 150);
        } else if (type === 'MISS') this.playSoft(900, 'square', 0.05, 0.2);
        else if (type === 'WIN') {
            setTimeout(() => this.playSoft(523, 'sine', 0.2, 0.5), 0);
            setTimeout(() => this.playSoft(659, 'sine', 0.2, 0.5), 200);
            setTimeout(() => this.playSoft(784, 'sine', 0.4, 0.5), 400);
        } else if (type === 'POWER_UP') {
            this.playSoft(440, 'sine', 0.2, 0.35);
            setTimeout(() => this.playSoft(554, 'sine', 0.2, 0.35), 100);
            setTimeout(() => this.playSoft(659, 'sine', 0.3, 0.35), 200);
        } else if (type === 'CRITICAL') {
            this.playSoft(150, 'triangle', 0.1, 0.6);
            setTimeout(() => this.playSoft(880, 'sine', 0.3, 0.7), 50);
        } else if (type === 'AWAKEN') {
            this.playSoft(300, 'square', 0.1, 0.3);
            setTimeout(() => this.playSoft(600, 'square', 0.1, 0.3), 100);
            setTimeout(() => this.playSoft(900, 'square', 0.3, 0.4), 200);
        } else if (type === 'CUTIN') {
            this.playSoft(100, 'sawtooth', 0.5, 0.5);
            setTimeout(() => this.playSoft(50, 'sawtooth', 0.8, 0.5), 100);
        }
    }
};

const UI = {
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#ff80ab; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() {
        document.getElementById('modal-overlay').style.display = 'none';
    },

    // [UI ê°œì„ ] ì˜¨ë¼ì¸ ì½”ë“œ ì…ë ¥ ëª¨ë‹¬
    openOnlineModal: function() {
        if (!socket || !socket.connected) {
            alert("âš ï¸ ì„œë²„ì™€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n(ì˜¤í”„ë¼ì¸ ëª¨ë“œì—ì„œëŠ” AIì™€ ëŒ€ê²°í•˜ì„¸ìš”)");
            return;
        }
        if (Game.selected.length !== 3) {
            alert("ë¨¼ì € ì˜ì›… 3ëª…ì„ ì„ íƒí•´ì£¼ì„¸ìš”!");
            return;
        }

        const content = `
            <div style="text-align:center;">
                <p style="color:#555; margin-bottom:15px;">ì¹œêµ¬ì™€ ê³µìœ í•  ë°© ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”.<br>(ì˜ˆ: 1234, ìš°ë¦¬ì§‘, apple)</p>
                <input type="text" id="modal-room-code" placeholder="ë°© ì½”ë“œ ì…ë ¥" 
                    style="font-size:20px; padding:15px; width:80%; text-align:center; border-radius:15px; border:2px solid #ddd; outline:none; font-weight:bold; color:#7e57c2;">
                <button id="modal-submit-btn" onclick="Game.submitOnline()" 
                    style="width:100%; margin-top:20px; padding:15px; background:#7e57c2; color:white; border:none; border-radius:15px; font-weight:bold; cursor:pointer; font-size:18px;">
                    ì…ì¥í•˜ê¸° ğŸš€
                </button>
            </div>
        `;
        this.showModal("ğŸŒ ì˜¨ë¼ì¸ ë§¤ì¹­", content);
        setTimeout(() => document.getElementById('modal-room-code').focus(), 100);
    },

    showGuide: function() {
        let heroList = '';
        const guideOrder = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark', 'Light-Light', 'Dark-Dark', 'Normal', 'Fire-Light', 'Fire-Dark', 'Water-Light', 'Water-Dark', 'Tree-Light', 'Tree-Dark', 'Earth-Light', 'Earth-Dark', 'Metal-Light', 'Metal-Dark'];
        guideOrder.forEach(k => {
            const s = SKILL_DB[k];
            let name = '';
            if (k === 'Normal') name = NAME_MAP['Normal'];
            else {
                const parts = k.split('-');
                if (parts.length === 2) name = NAME_MAP[k] || k;
                else name = `${ATTR[k].n}(ê¸°ì´ˆ)`;
            }
            const base = k.split('-')[0] === 'Normal' ? 'Normal' : k.split('-')[0];
            let icon = s.icon;
            let bg = `bg-${base}`;
            if (k.includes('-') && k.split('-')[0] === k.split('-')[1]) bg = `bg-${base}-Enhanced`;
            if (k === 'Normal') bg = 'bg-Normal';
            heroList += `<div class="guide-item"> <div class="guide-icon ${bg}" style="color:#fff;">${icon}</div> <div class="guide-info"> <div class="guide-name">${name}</div> <div class="guide-desc">${s.desc}</div> <div style="font-size:10px; color:#555; margin-top:2px;"> <div>S1: ${s.s1} (${s.s1d})</div> <div>S2: ${s.s2} (${s.s2d})</div> </div> </div> </div>`;
        });
        const content = `<div class="tab-header"> <button class="tab-btn active" onclick="UI.switchTab(0)">ğŸ“Š ìƒì„±í‘œ</button> <button class="tab-btn" onclick="UI.switchTab(1)">ğŸ“– ë„ê°</button> </div> <div id="tab-0" class="tab-content active"> <table class="chart-table"> <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr> <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr> <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr> <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr> <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr> <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr> <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr> <tr><td>ğŸ² ë…¸ë§</td><td>ë…¸ë§(ìì‹ ), ê°•í™”ëœ ë¹›/ì–´ë‘ </td></tr> </table> <div class="dual-chart"> <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div> <div class="dual-row" style='font-size:12px; color:#666;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ</div> </div> </div> <div id="tab-1" class="tab-content" style="max-height: 50vh; overflow-y:auto;"> ${heroList} </div>`;
        this.showModal("ğŸ“˜ ê°€ì´ë“œë¶", content);
    },
    switchTab: function(idx) {
        document.querySelectorAll('.tab-btn').forEach((b, i) => {
            if (i === idx) b.classList.add('active');
            else b.classList.remove('active');
        });
        document.querySelectorAll('.tab-content').forEach((c, i) => {
            if (i === idx) c.classList.add('active');
            else c.classList.remove('active');
        });
    },

    // [ë°ë¯¸ì§€ í°íŠ¸] ì„¸ë¶„í™” ì ìš©
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id);
        if (!unitEl) return;
        const el = document.createElement('div');
        el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        const randomX = (Math.random() - 0.5) * 40;
        const randomY = (Math.random() - 0.5) * 20;
        el.style.left = (rect.left + rect.width / 2 + window.scrollX + randomX) + 'px';
        el.style.top = (rect.top + window.scrollY + randomY) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    },

    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showTurnBanner: function(isPlayerTurn) {
        const banner = document.getElementById('turn-banner');
        if (isPlayerTurn) {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(33, 150, 243, 0.8), transparent)';
            banner.innerHTML = "âš”ï¸ ì•„êµ° í„´ (Player Turn)";
        } else {
            banner.style.background = 'linear-gradient(90deg, transparent, rgba(255, 87, 34, 0.8), transparent)';
            banner.innerHTML = "ğŸ‘¹ ì êµ° í„´ (Enemy Turn)";
        }
        banner.style.animation = 'none';
        void banner.offsetWidth;
        const duration = Game.turnCount > 5 ? '0.6s' : '1.2s';
        banner.style.animation = `banner-swipe ${duration} cubic-bezier(0.22, 1, 0.36, 1) forwards`;
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);
        let html = `<h2 style="color:${winnerTeamStr.includes('ì•„êµ°')?'#80deea':'#ffcc80'}">${winnerTeamStr} ìŠ¹ë¦¬! ğŸ‰</h2>`;
        html += `<div style="max-height:50vh; overflow-y:auto; text-align:left;">`;
        const mvp = allUnits.sort((a, b) => (b.stats.dmg + b.stats.heal + b.stats.shieldGiven) - (a.stats.dmg + a.stats.heal + a.stats.shieldGiven))[0];
        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            return `<div style="margin-bottom:12px; padding:10px; background:${u.team===0?'#e0f7fa':'#fff3e0'}; border-radius:15px; border:2px solid #fff; position:relative; box-shadow:0 2px 5px rgba(0,0,0,0.05);"> ${isMVP ? '<span style="position:absolute; top:-5px; right:-5px; font-size:24px;">ğŸ‘‘</span>' : ''} <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;"> <div class="attr-icon" style="width:28px; height:28px; font-size:16px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div> <div style="font-weight:bold; font-size:14px; color:#555;">${u.name.split(' ')[0]}</div> </div> <div style="display:flex; align-items:center; font-size:11px; margin-bottom:4px;"> <span style="width:30px; color:#888;">ë”œ</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${dmgPct}%; background:#ff8a80; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#ff8a80;">${u.stats.dmg}</span> </div> <div style="display:flex; align-items:center; font-size:11px;"> <span style="width:30px; color:#888;">í</span> <div style="flex:1; background:#fff; height:10px; border-radius:5px; overflow:hidden;"> <div style="width:${healPct}%; background:#4db6ac; height:100%;"></div> </div> <span style="width:35px; text-align:right; font-weight:bold; color:#4db6ac;">${u.stats.heal + u.stats.shieldGiven}</span> </div> </div>`;
        };
        html += `<h4 style="margin:5px 0; color:#80deea;">ğŸ’™ íŒ€ 1 (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:15px 0 5px; color:#ffcc80;">ğŸ§¡ íŒ€ 2 (Enemy/2P)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    },

    // [íˆ´íŒ] ì •ë³´ í‘œì‹œ
    showTooltip: function(u, el) {
        const info = SKILL_DB[u.getKey()];
        const statusText = u.status.map(s => `â€¢ ${s.type} (${s.turn}í„´)`).join('<br>') || 'ì—†ìŒ';
        const html = `
            <div class="tooltip-title">${u.name} (HP: ${u.hp})</div>
            <div style="margin-bottom:5px;">${info.desc}</div>
            <div style="color:#aaa; border-top:1px solid #555; padding-top:3px; margin-top:3px;">
                <b>ìƒíƒœì´ìƒ:</b><br>${statusText}
            </div>
        `;
        const tooltip = document.getElementById('tooltip-view');
        tooltip.innerHTML = html;
        tooltip.style.display = 'block';

        const rect = el.getBoundingClientRect();
        let top = rect.top - 100;
        let left = rect.left + rect.width / 2 - 100;
        if (top < 10) top = rect.bottom + 10;
        if (left < 10) left = 10;

        tooltip.style.top = top + 'px';
        tooltip.style.left = left + 'px';
    },
    hideTooltip: function() {
        document.getElementById('tooltip-view').style.display = 'none';
    },

    // [ì»·ì‹ ] ì—°ì¶œ
    showCutIn: function(unit) {
        const ov = document.getElementById('cut-in-overlay');
        const em = document.getElementById('cut-in-emoji');
        const msg = document.getElementById('cut-in-msg');

        const key = unit.getKey();
        em.innerText = SKILL_DB[key].icon || ATTR[unit.base].i;
        msg.innerText = "HEROIC FINISH!";

        ov.style.display = 'flex';
        AudioSys.play('CUTIN');

        // 1.2ì´ˆ í›„ ì¢…ë£Œ
        setTimeout(() => {
            ov.style.display = 'none';
        }, 1200);
    }
};

const Game = {
    // [ì¶”ê°€] ë””ë²„ê·¸ ëª¨ë“œ ì„¤ì •
    DEBUG_MODE: true, // ê°œë°œ ì¤‘ì—” true, ë°°í¬ ì‹œ falseë¡œ ë³€ê²½

    debugLog: function(msg, data) {
        if (this.DEBUG_MODE) {
            // ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê°ì²´ë¡œ, ì—†ìœ¼ë©´ ë©”ì‹œì§€ë§Œ ì¶œë ¥
            if (data) console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;', data);
            else console.log(`%c[DEBUG] ${msg}`, 'color: #bada55; font-weight: bold;');
        }
    },
    pool: [],
    selected: [],
    pTeam: [],
    eTeam: [],
    queue: [],
    curr: 0,
    selectedSkillIdx: -1,
    timer: null,
    turnCount: 1,
    difficulty: 'normal',
    watchdog: null,
    isOver: false,
    mode: 'pve',
    isProcessing: false,
    challengeStage: 0,
    isMindControlling: null, // [ì‹ ê·œ] ì„¸ë‡Œ ì¡°ì¢… ìƒíƒœ í”Œë˜ê·¸

    netRandom: function() {
        return getNetRandom();
    },

    init: function() {
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        this.isOver = false;
        this.isMindControlling = null; // ì´ˆê¸°í™”
        this.pool = [];
        this.selected = [];
        const allCombos = [{
            b: 'Metal',
            e: null
        }, {
            b: 'Tree',
            e: null
        }, {
            b: 'Fire',
            e: 'Light'
        }, {
            b: 'Water',
            e: 'Light'
        }, {
            b: 'Fire',
            e: null
        }, {
            b: 'Normal',
            e: null
        }, {
            b: 'Fire',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: 'Dark'
        }, {
            b: 'Earth',
            e: null
        }, {
            b: 'Water',
            e: 'Dark'
        }, {
            b: 'Metal',
            e: 'Light'
        }, {
            b: 'Earth',
            e: 'Light'
        }, {
            b: 'Tree',
            e: 'Dark'
        }, {
            b: 'Water',
            e: null
        }, {
            b: 'Tree',
            e: 'Light'
        }, {
            b: 'Light',
            e: null
        }, {
            b: 'Light',
            e: 'Light'
        }, {
            b: 'Dark',
            e: null
        }, {
            b: 'Dark',
            e: 'Dark'
        }];
        allCombos.forEach((c, i) => {
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
        });
        this.renderHeroSelection();
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;

        // [UI ê°œì„ ] ì˜¨ë¼ì¸ ë²„íŠ¼ì€ í•­ìƒ í™œì„±í™”, í´ë¦­ ì‹œ ëª¨ë‹¬ ì²˜ë¦¬
        const btnOnline = document.getElementById('btn-online');
        if (btnOnline) {
            btnOnline.style.backgroundColor = '#7e57c2';
        }

        this.checkMode();
    },

    // [UI ê°œì„ ] ëª¨ë‹¬ì—ì„œ ì½”ë“œ ì…ë ¥ í›„ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    submitOnline: function() {
        const codeInput = document.getElementById('modal-room-code');
        const code = codeInput.value.trim();
        if (!code) {
            alert("ë°© ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!");
            codeInput.focus();
            return;
        }

        const btn = document.getElementById('modal-submit-btn');
        if (btn.innerText.includes('ëŒ€ê¸° ì¤‘')) return;
        btn.disabled = true;
        btn.innerText = "ğŸ“¡ ì„œë²„ í†µì‹  ì¤‘...";

        startOnlineGame(code);
    },

    renderHeroSelection: function() {
        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        grid.style.display = 'block';
        grid.style.overflowY = 'auto';
        const categories = [{
            name: "ğŸ›¡ï¸ íƒ±ì»¤ (Tank)",
            range: [0, 3],
            color: "#e3f2fd",
            border: "#90caf9"
        }, {
            name: "âš”ï¸ ë”œëŸ¬ (Dealer)",
            range: [4, 13],
            color: "#ffebee",
            border: "#ef9a9a"
        }, {
            name: "ğŸ§© ì§€ì› (Support)",
            range: [14, 19],
            color: "#f1f8e9",
            border: "#a5d6a7"
        }];
        categories.forEach(cat => {
            const header = document.createElement('div');
            header.style.cssText = `width:100%; padding:8px; background:${cat.color}; border-left:5px solid ${cat.border}; font-weight:bold; margin-top:10px; border-radius:5px; color:#455a64; text-align:left; box-sizing:border-box;`;
            header.innerText = cat.name;
            grid.appendChild(header);
            const container = document.createElement('div');
            container.style.cssText = "display:grid; grid-template-columns:repeat(4, 1fr); gap:8px; padding:10px 0;";
            for (let i = cat.range[0]; i <= cat.range[1]; i++) {
                const u = this.pool[i];
                const el = document.createElement('div');
                el.className = 'hero-card';
                el.id = `card-${i}`;
                el.innerHTML = this.renderCard(u);
                el.onclick = () => {
                    this.toggle(i, el);
                };
                container.appendChild(el);
            }
            grid.appendChild(container);
        });
    },
    renderCard: function(u) {
    if (!u) return '';

    // 1. ë°°ê²½ í´ë˜ìŠ¤ ê²°ì •
    let bgClass = 'bg-' + u.base;
    if (u.isEnhanced) {
        bgClass = 'bg-' + u.base + '-Enhanced';
    } else if (u.isNormal) {
        bgClass = 'bg-Normal';
    }

    // 2. ë°ì´í„° ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°
    const key = u.getKey();
    const info = SKILL_DB[key];
    
    if (!info) {
        console.error('SKILL_DB missing for key:', key);
        return '<div class="attr-icon bg-Normal">?</div><div style="font-weight:bold;">ERROR</div>';
    }

    // 3. ì•„ì´ì½˜ ë° í…ìŠ¤íŠ¸ ì¤€ë¹„
    const mainIcon = info.icon || (ATTR[u.base] ? ATTR[u.base].i : '?');
    const baseIcon = ATTR[u.base] ? ATTR[u.base].i : '?';
    const extraIconHtml = (u.extra && ATTR[u.extra]) 
                        ? '<div class="mini-icon">' + ATTR[u.extra].i + '</div>' 
                        : '';
    const displayName = u.name ? u.name.split(' ')[0] : 'Unknown';
    const fullName = u.name || 'Unknown';
    const description = info.desc || 'ì •ë³´ ì—†ìŒ';

    // 4. HTML ì¡°ë¦½ (ë°±í‹± ì¤‘ì²© ì—†ì´)
    const html = '<div class="attr-icon ' + bgClass + '">' +
                    mainIcon +
                    '<div class="mini-attr-box">' +
                        '<div class="mini-icon">' + baseIcon + '</div>' +
                        extraIconHtml +
                    '</div>' +
                '</div>' +
                '<div style="font-weight:bold; margin-bottom:2px; font-size:15px;">' + 
                    displayName + 
                '</div>' +
                '<div style="font-size:11px; color:#999;">' + fullName + '</div>' +
                '<div style="margin-top:8px; font-size:11px; background:#f5f5f5; padding:4px 8px; border-radius:10px; border:1px solid #eee;">' +
                    description +
                '</div>';
    
    return html;
},
    toggle: function(i, el) {
        if (!el) el = document.getElementById(`card-${i}`);
        if (this.selected.includes(i)) {
            this.selected = this.selected.filter(x => x !== i);
            el.classList.remove('selected');
        } else {
            if (this.selected.length >= 3) {
                el.classList.add('shake');
                setTimeout(() => el.classList.remove('shake'), 500);
                return;
            }
            this.selected.push(i);
            el.classList.add('selected');
        }
        const count = this.selected.length;
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (${count}/3)`;
        btn.disabled = count !== 3;
    },
    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if (el) el.classList.remove('selected');
        });
        Game.selected = [];
        while (Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 20);
            if (!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if (el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `âš”ï¸ ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },
    checkMode: function() {
        const diff = document.getElementById('diff-select').value;
        const statusEl = document.getElementById('challenge-status');
        if (diff === 'hell') {
            statusEl.style.display = 'block';
            const savedStage = localStorage.getItem('et_challenge_stage');
            let maxStage = savedStage ? parseInt(savedStage) : 0;
            if (maxStage >= ChallengeDB.length) maxStage = ChallengeDB.length - 1;
            if (this.challengeStage > maxStage) this.challengeStage = maxStage;
            const select = document.getElementById('stage-select');
            select.innerHTML = '';
            ChallengeDB.forEach((st, i) => {
                if (i <= maxStage) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i+1}. ${st.name}`;
                    if (i === this.challengeStage) opt.selected = true;
                    select.appendChild(opt);
                }
            });
            this.updateStageInfo();
        } else {
            statusEl.style.display = 'none';
        }
    },
    selectStage: function() {
        const select = document.getElementById('stage-select');
        this.challengeStage = parseInt(select.value);
        this.updateStageInfo();
    },
    updateStageInfo: function() {
        const stage = ChallengeDB[this.challengeStage];
        if (stage) {
            document.getElementById('stage-desc').innerText = `[${stage.name}] ${stage.desc}`;
        }
    },

    start: function() {
        AudioSys.init();
        AudioSys.resume();
        const diffVal = document.getElementById('diff-select').value;
        this.difficulty = diffVal;
        this.mode = (diffVal === 'pvp' || diffVal === 'local') ? 'pvp' : 'pve';

        this.pTeam = this.selected.map((idx, i) => {
            const u = this.pool[idx];
            u.id = i;
            u.team = 0;
            return u;
        });
        this.eTeam = [];
        this.isOver = false;
        const makeEnemy = (idx, b, e) => {
            const u = new Unit(idx + 3, 1, b, e);
            return u;
        };

        if (this.difficulty === 'hell') {
            if (this.challengeStage >= ChallengeDB.length) this.challengeStage = ChallengeDB.length - 1;
            const stageData = ChallengeDB[this.challengeStage];

            // [AI ê°•í™”] ì±Œë¦°ì§€ ëª¨ë“œ ë± ìˆœì„œ ëœë¤ ì„ê¸° (ë°°ì¹˜ ì¹´ìš´í„° ë°©ì§€)
            const shuffledTeam = [...stageData.team].sort(() => Math.random() - 0.5);

            this.eTeam = shuffledTeam.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
        } else if (this.difficulty === 'mirror') {
            this.eTeam = this.pTeam.map((pu, i) => {
                const u = new Unit(i + 3, 1, pu.base, pu.extra);
                u.maxHp = Math.floor(u.maxHp * 1.15);
                u.hp = u.maxHp;
                u.atk = Math.floor(u.atk * 1.15);
                return u;
            });
        } else if (this.difficulty === 'easy') {
            const basics = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'];
            while (this.eTeam.length < 3) {
                const b = basics[Math.floor(Math.random() * basics.length)];
                if (!this.eTeam.some(u => u.base === b)) {
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, null));
                }
            }
        } else if (this.difficulty === 'hard') {
            let bestIdx = Math.floor(Math.random() * ChallengeDB.length);
            let maxScore = -999;
            ChallengeDB.forEach((stage, idx) => {
                let score = 0;
                stage.team.forEach(key => {
                    let b, e, isN = false,
                        isEnh = false;
                    if (key === 'Normal') {
                        b = 'Normal';
                        isN = true;
                    } else {
                        const parts = key.split('-');
                        b = parts[0];
                        e = parts[1] || null;
                        if (b === e) isEnh = true;
                    }
                    const dumE = {
                        base: b,
                        extra: e,
                        isNormal: isN,
                        isEnhanced: isEnh
                    };
                    this.pTeam.forEach(p => {
                        const atkRel = this.calc(dumE, p);
                        if (atkRel.v > 1.0) score += 3;
                        const defRel = this.calc(p, dumE);
                        if (defRel.v < 1.0) score += 2;
                    });
                });
                score += Math.random();
                if (score > maxScore) {
                    maxScore = score;
                    bestIdx = idx;
                }
            });
            const targetDeck = ChallengeDB[bestIdx].team;
            this.eTeam = targetDeck.map((key, i) => {
                let b, e;
                if (key === 'Normal') {
                    b = 'Normal';
                    e = null;
                } else if (key.includes('-')) {
                    [b, e] = key.split('-');
                } else {
                    b = key;
                    e = null;
                }
                return makeEnemy(i, b, e);
            });
            this.log(`<span class='log-sys'>ğŸ”¥ ì–´ë ¤ì›€(Counter): ì ì´ ë‹¹ì‹ ì˜ ì•½ì ì„ ê°„íŒŒí–ˆìŠµë‹ˆë‹¤! (${ChallengeDB[bestIdx].name})</span>`);
        } else {
            const used = new Set();
            while (this.eTeam.length < 3) {
                const b = ['Fire', 'Water', 'Tree', 'Metal', 'Earth', 'Light', 'Dark'][Math.floor(Math.random() * 7)];
                const e = [null, 'Light', 'Dark'][Math.floor(Math.random() * 3)];
                if (b === 'Dark' && e === 'Light') continue;
                let key = `${b}-${e}`;
                if (b === 'Light' && e === 'Dark') key = 'Normal';
                if (!used.has(key)) {
                    used.add(key);
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, e));
                }
            }
        }

        this.queue = [0, 1, 2, 3, 4, 5];
        this.curr = Math.floor(Math.random() * 6);
        this.turnCount = 1;
        this.isProcessing = false;
        document.getElementById('selection-screen').style.display = 'none';
        document.getElementById('battle-screen').style.display = 'flex';
        document.getElementById('logs').innerHTML = '';
        let diffText = this.difficulty === 'mirror' ? 'ğŸª ê±°ìš¸ ì „ìŸ' : (this.difficulty === 'hell' ? `ğŸ† ì±Œë¦°ì§€ ${this.challengeStage+1}` : this.difficulty);
        this.log(`<span class='log-sys'>âœ¨ ì „íˆ¬ ì‹œì‘! [${diffText}] (3vs3)</span>`);

        // [ì„ /í›„ê³µ ë³´ì •] í›„ê³µ íŒ€ì—ê²Œ ë©´ì—­ ë¶€ì—¬
        // queue[curr]ì´ ì„ ê³µì˜ ì²« í„´ ì¸ë±ìŠ¤.
        // ë§Œì•½ queue[curr]ì´ 0,2,4 ì¤‘ í•˜ë‚˜ë©´ PíŒ€ì´ ì„ ê³µ -> EíŒ€(1)ì—ê²Œ ë©´ì—­
        // ë§Œì•½ queue[curr]ì´ 1,3,5 ì¤‘ í•˜ë‚˜ë©´ EíŒ€ì´ ì„ ê³µ -> PíŒ€(0)ì—ê²Œ ë©´ì—­
        const firstTurnUnitId = (this.queue[this.curr] % 2 === 0 ? this.queue[this.curr] / 2 : (this.queue[this.curr] - 1) / 2 + 3);
        const firstTurnTeam = this.queue[this.curr] % 2; // 0 (PíŒ€) or 1 (EíŒ€)
        const secondTeam = firstTurnTeam === 0 ? this.eTeam : this.pTeam;

        secondTeam.forEach(u => u.addStatus('START_IMMUNITY', 99, 0, null, true));
        this.log(`<span class='log-sys'>ğŸ›¡ï¸ í›„ê³µ íŒ€(${firstTurnTeam===0?'ì êµ°':'ì•„êµ°'})ì—ê²Œ ì²« í–‰ë™ ì „ê¹Œì§€ ë©´ì—­ ë¶€ì—¬!</span>`);

        this.render();
        this.timer = setTimeout(() => this.turn(), 1000);
    },

    turn: function() {
        this.isProcessing = false;
        if (this.isOver) return;
        const round = Math.ceil(this.turnCount / 6);
        const tVal = this.queue[this.curr];
        const u = tVal % 2 === 0 ? this.pTeam[tVal / 2] : this.eTeam[(tVal - 1) / 2];
        const isMyTurn = (u.team === 0);

        if (this.watchdog) clearTimeout(this.watchdog);
        if (!isMyTurn && !isOnlineMode && this.difficulty !== 'local') {
            this.watchdog = setTimeout(() => {
                console.log("AI Stuck. Forcing next.");
                this.endTurn();
            }, 3000);
        }
        if (this.endCheck()) return;

        if (!u.isDead) {
            u.resetTurn();
            // [ì„ /í›„ê³µ ë³´ì •] í–‰ë™ ì‹œì‘ ì‹œ ë©´ì—­ í•´ì œ (íŒ€ ì „ì²´)
            if (u.hasStatus('START_IMMUNITY')) {
                const myTeam = u.team === 0 ? this.pTeam : this.eTeam;
                myTeam.forEach(member => {
                    member.status = member.status.filter(s => s.type !== 'START_IMMUNITY');
                });
                this.log(`<span class='log-sys'>ğŸ”“ [${u.team===0?'ì•„êµ°':'ì êµ°'}] í›„ê³µ ë³´í˜¸ë§‰ í•´ì œ!</span>`);
                this.render(); // ìƒíƒœ ê°±ì‹ ì„ ìœ„í•´ ë Œë”ë§
            }
        }

        if (u.isDead) {
            this.endTurn(true);
            return;
        }

        // [ì‹ ê·œ] ì„¸ë‡Œ ëŒ€ê¸° (MC_WAIT) -> í„´ ìŠ¤í‚µ & ì¡°ì¢…ê¶Œ ì´ì–‘
const mcWaitStatus = u.status.find(s => s.type === 'MC_WAIT');
if (mcWaitStatus) {
    Game.log(`<span class='log-crit'>ğŸ§  [${u.name}] ì •ì‹  ì§€ë°°ë¡œ ì¸í•´ í–‰ë™ ë¶ˆê°€!</span>`);
    UI.floatText(u, "ì •ì‹ ì§€ë°°", "ft-crit");
    
    let caster = null;
    if (mcWaitStatus.sourceId !== undefined && mcWaitStatus.sourceId !== -1) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        caster = allUnits.find(unit => unit.id === mcWaitStatus.sourceId);
    }
    
    if (!caster) {
        const enemyTeam = u.team === 0 ? Game.eTeam : Game.pTeam;
        caster = enemyTeam.find(e => e.getKey() === 'Dark-Dark' && !e.isDead);
    }

    u.status = u.status.filter(s => s.type !== 'MC_WAIT');
    
    if (caster && !caster.isDead) {
        u.addStatus('MC_READY', 99, 0, caster);
    } else {
        Game.log("<span class='log-sys'>(ì‹œì „ìê°€ ì‚¬ë§í•˜ì—¬ ì„¸ë‡Œê°€ í’€ë ¸ìŠµë‹ˆë‹¤)</span>");
    }
    
    setTimeout(() => this.endTurn(), 1000);
    return;
}

        // [ì‹ ê·œ] ì„¸ë‡Œ ì¡°ì¢… (MC_READY) ì‹¤í–‰
if (u.getKey() === 'Dark-Dark' && !u.isDead) {
    const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
    const puppet = enemies.find(e => e.hasStatus('MC_READY'));
    
    if (puppet) {
        Game.log(`<span class='log-crit'>ğŸ® [${u.name}] ${puppet.name}ì˜ ì •ì‹ ì„ ì¡°ì¢…í•©ë‹ˆë‹¤!</span>`);
        Game.isMindControlling = puppet;
        
        document.getElementById('turn-indicator').innerText = `ğŸ§  ì¡°ì¢… ì¤‘ : ${puppet.name}`;
        UI.showTurnBanner(u.team === 0);
        
        document.querySelector('.control-panel').style.borderTop = "5px solid #d500f9";

        if (isMyTurn || this.difficulty === 'local') {
            this.input(puppet);
            setTimeout(() => {
                const cardId = u.team === 0 ? `e-card-${puppet.id}` : `p-card-${puppet.id}`;
                const el = document.getElementById(cardId);
                if(el) UI.showTooltip(puppet, el);
            }, 100);
            Game.log("<span class='log-sys'>ğŸ’¡ ì êµ°(ì›ë˜ ì•„êµ°)ì„ ê³µê²©í•˜ì„¸ìš”!</span>");
        } else {
            this.timer = setTimeout(() => this.ai(puppet), 1000);
        }
        return;
    }
}

        UI.showTurnBanner(isMyTurn);
        if (u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) {
            UI.floatText(u, "SKIP", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`);
            setTimeout(() => this.endTurn(), 800);
            return;
        }
        const tickLogs = u.tickStatus();
        tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if (u.hp <= 0) {
            this.die(u);
            this.endTurn();
            return;
        }

        let turnName = u.name.split(' ')[0];
        if (this.mode === 'pvp') turnName += (u.team === 0 ? " (ë‚˜)" : " (ì )");
        document.getElementById('turn-indicator').innerText = `Round ${round} : ${turnName}`;
        this.turnCount++;
        if (isMyTurn || this.difficulty === 'local') {
            this.input(u);
        } else {
            this.noInput();
            if (this.mode === 'pvp') document.getElementById('turn-indicator').innerText = `ìƒëŒ€ë°©ì˜ í–‰ë™ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...`;
            else this.timer = setTimeout(() => this.ai(u), 800);
        }
    },

    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for (let i = 0; i < 6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx];
            const isP = qId % 2 === 0;
            const uIdx = isP ? qId / 2 : (qId - 1) / 2;
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if (u.isDead) n.style.opacity = 0.3;
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }
        const draw = (rowId, team, tid) => {
            const row = document.getElementById(rowId);
            const currentIds = team.map(u => u.id);
            Array.from(row.children).forEach(c => {
                if (!currentIds.includes(parseInt(c.dataset.uid))) c.remove();
            });
            team.forEach((u) => {
                const cardId = tid === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                let d = document.getElementById(cardId);
                if (!d) {
                    d = document.createElement('div');
                    d.id = cardId;
                    d.dataset.uid = u.id;
                    row.appendChild(d);
                }
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                // [ê°ì„±] super-hero í´ë˜ìŠ¤ ì¶”ê°€
                d.className = `unit role-${role} ${u.isSuper ? 'super-hero' : ''} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;

                // [íˆ´íŒ] ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                d.onmousedown = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return; // íƒ€ê²ŸíŒ… ì¤‘ì—” íˆ´íŒ X
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.onmouseup = () => {
                    clearTimeout(d.pressTimer);
                    UI.hideTooltip();
                };
                d.onmouseleave = () => {
                    clearTimeout(d.pressTimer);
                    UI.hideTooltip();
                };
                d.ontouchstart = (e) => {
                    if (d.classList.contains('target-enemy') || d.classList.contains('target-ally')) return;
                    d.pressTimer = setTimeout(() => UI.showTooltip(u, d), 500);
                };
                d.ontouchend = () => {
                    clearTimeout(d.pressTimer);
                    UI.hideTooltip();
                };

                let tags = u.status.map(s => {
                    let c = 'tag';
                    const map = {
                        'POISON': 'poison',
                        'FREEZE': 'freeze',
                        'SILENCE': 'silence',
                        'EVADE': 'evade',
                        'BURN': 'burn',
                        'BANISH': 'banish',
                        'TRAP': 'trap',
                        'BIND': 'bind',
                        'GROWTH': 'growth',
                        'ATK_DOWN': 'atkdown',
                        'BLIND': 'blind',
                        'IMMUNITY': 'immunity',
                        'HEAL_DOWN': 'healdown',
                        'LIGHT_MIGHT': 'atkup',
                        'LIFESTEAL_BUFF': 'lifesteal',
                        'ATK_BUFF_SMALL': 'atkup_s',
                        'START_IMMUNITY': 'start-immunity',
                        'MC_WAIT': 'mc-wait', // [ì‹ ê·œ]
                        'MC_READY': 'mc-ready'    // [ì‹ ê·œ]

                    };
                    if (s.type.includes('PROVOKED')) c += ' taunt';
                    else if (s.type.startsWith('KARMA_VICTIM')) c += ' karma';
                    else if (map[s.type]) c += ` ${map[s.type]}`;
                    let txt = s.type;
                    const tMap = {
                        'POISON': 'ë…',
                        'FREEZE': 'ë¹™ê²°',
                        'SILENCE': 'ì¹¨ë¬µ',
                        'DMG_RED': 'ë°©ì–´â†‘',
                        'EVADE': 'íšŒí”¼',
                        'BURN': 'í™”ìƒ',
                        'TRAP': 'ì†ë°•',
                        'BANISH': 'ì¶”ë°©',
                        'BIND': 'ê²°ì†',
                        'GROWTH': 'ì„±ì¥',
                        'ATK_DOWN': 'ê³µê²©â†“',
                        'BLIND': 'ì‹¤ëª…',
                        'IMMUNITY': 'ë©´ì—­',
                        'HEAL_DOWN': 'ì¹˜ìœ â†“',
                        'LIGHT_MIGHT': 'ê³µê²©â†‘',
                        'LIFESTEAL_BUFF': 'ğŸ©¸í¡í˜ˆ',
                        'ATK_BUFF_SMALL': 'ğŸ”¥ê³µê²©â†‘',
                        'START_IMMUNITY': 'ğŸ›¡ï¸ì„ ê³µë°©ì–´',
                        'MC_WAIT': 'ğŸŒ€ì„¸ë‡Œì¤‘...', // [ì‹ ê·œ]
                        'MC_READY': 'ğŸ§ ì¡°ì¢…ê°€ëŠ¥'   // [ì‹ ê·œ]
                    };
                    if (s.type.includes('PROVOKED')) txt = 'ë„ë°œ';
                    else if (s.type.startsWith('KARMA_VICTIM')) txt = 'ğŸ‘ï¸ì—…ë³´';
                    else if (tMap[s.type]) txt = tMap[s.type];
                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');
                if (u.linkedAllyId !== -1) tags += `<span class="tag bind" style="background:#27ae60; border:1px solid #fff;">ğŸ”—Link</span>`;
                let bgClass = `bg-${u.base}`;
                if (u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if (u.isNormal) bgClass = 'bg-Normal';
                const icon = SKILL_DB[u.getKey()].icon || '';
                let extraBadge = '';
                if (u.elecStacks > 0) extraBadge = `<div class="elec-badge">âš¡${u.elecStacks}</div>`;

                let displayName = u.name.split(' ')[0];
                if (u.isSuper) {
                    if (role === 'nuker') displayName = `ğŸ‘¹íŒŒê´´ì‹  ${displayName}`;
                    else if (role === 'tank') displayName = `ğŸ›¡ï¸ìˆ˜í˜¸ì‹  ${displayName}`;
                    else if (role === 'supp') displayName = `ğŸ˜‡êµ¬ì›ì ${displayName}`;
                }

                const innerHTML = ` ${extraBadge} <div class="tag-container">${tags}</div> <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div> <div class="unit-name" style="font-size:15px; margin-bottom:3px; ${u.isSuper ? 'color:#fbc02d; text-shadow:0 0 5px rgba(255,235,59,0.5);' : ''}">${displayName} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div> <div class="status-bar" style="height:14px;"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div> <div style="font-size:12px; margin-top:3px; color:#777; font-weight:bold;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div> `;
                if (d.innerHTML !== innerHTML) d.innerHTML = innerHTML;
            });
        };
        draw('player-row', this.pTeam, 0);
        draw('enemy-row', this.eTeam, 1);
    },

endTurn: function(isFast = false) {
        if (this.isOver) return;
        if (this.watchdog) clearTimeout(this.watchdog);
        
        // í˜„ì¬ í„´ ì£¼ì¸ ìœ ë‹› ì°¾ê¸°
        const u = this.queue[this.curr] % 2 === 0 ? this.pTeam[this.queue[this.curr] / 2] : this.eTeam[(this.queue[this.curr] - 1) / 2];

        // [ë°¸ëŸ°ìŠ¤ ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ (ìŠ¤í„´ ì‚­ì œ, ë¬´ì¡°ê±´ í•´ì œ)
        if (Game.isMindControlling) {
             const puppet = Game.isMindControlling;
             
             Game.log(`<span class='log-sys'>ğŸ§  [${puppet.name}] ì •ì‹  ì§€ë°°ê°€ í’€ë ¸ìŠµë‹ˆë‹¤. (í–‰ë™ ê°€ëŠ¥)</span>`);
             UI.floatText(puppet, "ì§€ë°° í•´ì œ", "ft-heal");
             
             // 1. ì„¸ë‡Œ ìƒíƒœ ì•„ì´ì½˜(MC_READY) ì œê±°
             puppet.status = puppet.status.filter(s => s.type !== 'MC_READY');
             
             // [ì‚­ì œë¨] ìŠ¤í„´ ë¶€ì—¬ ë¡œì§ ì‚­ì œ (ìœ ì € ìš”ì²­: ì„¸ë‡Œ í›„ ì¦‰ì‹œ í–‰ë™ ê°€ëŠ¥)
             // puppet.addStatus('STUN', 1, 0, null, true); <--- ì‚­ì œë¨
             
             // 2. ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” (í•„ìˆ˜: ìì•„ ë¶„ì—´ ë°©ì§€)
             Game.isMindControlling = null;
             
             // 3. UI í…Œë‘ë¦¬ ë³µêµ¬
             const cp = document.querySelector('.control-panel');
             if(cp) cp.style.borderTop = "5px solid #ff80ab";
        }

        if (u && !u.isDead) u.decayStatus();
        
        [...this.pTeam, ...this.eTeam].forEach(u => {
            if (u.hp <= 0) this.die(u)
        });
        
        this.curr = (this.curr + 1) % 6;
        
        // ë°ìŠ¤ë§¤ì¹˜ ë¡œì§
        if (this.curr === 0) {
            const round = Math.ceil(this.turnCount / 6);
            if (round > 20) {
                [...this.pTeam, ...this.eTeam].forEach(u => {
                    if (!u.isDead) u.atk += 10;
                });
                this.log("<span class='log-crit'>ğŸ’€ ë°ìŠ¤ë§¤ì¹˜! ëª¨ë“  ì˜ì›… ê³µê²©ë ¥ +10</span>");
            }
        }
        
        this.render();
        const delay = isFast ? 100 : 1500;
        this.timer = setTimeout(() => this.turn(), delay);
    }, // ì´ ë’¤ì— ì½”ë“œê°€ ì—†ì–´ì•¼ í•©ë‹ˆë‹¤! ë°”ë¡œ execute í•¨ìˆ˜ê°€ ë‚˜ì™€ì•¼ í•©ë‹ˆë‹¤.

    execute: function(atk, def, sIdx, isRemote = false) {
        document.querySelectorAll('.unit').forEach(el => el.onclick = null);
        
        // [ìˆ˜ì •] ì„¸ë‡Œ ì¤‘ì¼ ë•ŒëŠ” ë‚´ ìœ ë‹› ì²´í¬(atk.team !== 0)ë¥¼ ìš°íšŒí•´ì•¼ í•¨
        if (isOnlineMode && !isRemote) {
            const isMindControlAction = Game.isMindControlling && atk.id === Game.isMindControlling.id;
            if (atk.team !== 0 && !isMindControlAction) { // ì˜ˆì™¸ ì²˜ë¦¬ ì¶”ê°€
                alert("ë‚´ ìœ ë‹›ì´ ì•„ë‹™ë‹ˆë‹¤!");
                return;
            }
            netRndBuffer = [];
        }

        const key = atk.getKey();
        const logic = SKILL_LOGIC[key];

        if (!logic) {
            console.error(`Logic missing for ${key}`);
            return;
        }
        const playedSound = logic.useSkill(atk, def, sIdx, this);
        if (!playedSound) AudioSys.play('SKILL');

        // [ê°ì„± ì²´í¬] ìŠ¤í‚¬ ì‚¬ìš© í›„ í†µê³„ ê°±ì‹  ì‹œ ê°ì„± í™•ì¸
        atk.checkAwakening();

        if (isOnlineMode && !isRemote) {
            socket.emit('action', {
                room: myRoom,
                attackerId: atk.id,
                attackerTeam: atk.team,
                targetId: def ? def.id : null,
                targetTeam: def ? def.team : null,
                skillIdx: sIdx,
                rndBuffer: netRndBuffer
            });
        }
       // [ìˆ˜ì •] ì„¸ë‡Œ í•´ì œ ë¡œì§ì€ endTurn()ìœ¼ë¡œ ì´ë™ë¨ (ê¸°ì ˆ ì‹œ í•´ì œ ì•ˆ ë˜ëŠ” ë²„ê·¸ ìˆ˜ì •)
        this.endTurn();
    },

    reset: function() {
        if (this.timer) clearTimeout(this.timer);
        if (this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display = 'none';
        document.getElementById('selection-screen').style.display = 'flex';
        document.querySelectorAll('.hero-card.selected').forEach(el => el.classList.remove('selected'));
        this.selected = [];
        document.getElementById('btn-start').innerText = "âš”ï¸ ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
        this.init();
    },
    // [ê°ì„± ì²´í¬] ìŠ¤íƒ¯ ê¸°ë¡ ì‹œ ê°ì„± í™•ì¸
    recordStat: function(unit, type, amount) {
        if (!unit || amount <= 0) return;
        if (type === 'dmg') unit.stats.dmg += amount;
        if (type === 'shield') unit.stats.shieldGiven += amount;
        if (type === 'heal') unit.stats.heal += amount;
        unit.checkAwakening();
    },
    input: function(u) {
    // ì„¸ë‡Œ ìƒíƒœ UI í‘œì‹œ
    const cp = document.querySelector('.control-panel');
    if (cp) {
        cp.style.borderTop = Game.isMindControlling ? "5px solid #d500f9" : "5px solid #ff80ab";
    }
    
    const k = u.getKey();
    const s = SKILL_DB[k];
    
    // ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ ë°©ì–´ ì½”ë“œ
    if (!s) {
        console.error("âŒ SKILL_DB missing for key:", k, "Unit:", u.name);
        document.getElementById('p-icon').innerText = 'â“';
        document.getElementById('p-desc').innerText = 'ERROR: ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ';
        document.getElementById('sk-0').innerHTML = '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br><span class="skill-desc">1.0ë°°</span>';
        document.getElementById('sk-1').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        document.getElementById('sk-2').innerHTML = '<span class="skill-name">ERROR</span><br><span class="skill-desc">ìŠ¤í‚¬ ì •ë³´ ì—†ìŒ</span>';
        [0, 1, 2].forEach(i => document.getElementById(`sk-${i}`).disabled = true);
        this.log(`<span class='log-sys'>âš ï¸ [${u.name}] ìŠ¤í‚¬ ì •ë³´ ì˜¤ë¥˜ ë°œìƒ</span>`);
        return;
    }
    
    const silenced = u.hasStatus('SILENCE');
    
    // íŒ¨ì‹œë¸Œ ì •ë³´
    document.getElementById('p-icon').innerText = s.icon || 'â“';
    document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
    
    // ìŠ¤í‚¬ ë²„íŠ¼ ì •ë³´
    document.getElementById('sk-0').innerHTML = 
        '<span class="skill-name">ê¸°ë³¸ê³µê²©</span><br>' +
        '<span class="skill-desc">1.0ë°° í”¼í•´</span>';
    
    document.getElementById('sk-1').innerHTML = 
        '<span class="skill-name">' + (s.s1 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s1d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    document.getElementById('sk-2').innerHTML = 
        '<span class="skill-name">' + (s.s2 || 'ERROR') + '</span><br>' +
        '<span class="skill-desc">' + (s.s2d || 'ì •ë³´ ì—†ìŒ') + '</span>';
    
    // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ
    document.getElementById('sk-0').disabled = false;
    document.getElementById('sk-1').disabled = silenced;
    
    // S2 ë¹„í™œì„±í™” ì¡°ê±´
    let sk2Disable = silenced;
    
    if (k === 'Fire-Light' && (u.s2Count || 0) >= 5) {
        sk2Disable = true;
    }
    
    if (k === 'Tree-Dark') {
        const myTeam = u.team === 0 ? Game.pTeam : Game.eTeam;
        const aliveAllies = myTeam.filter(a => !a.isDead && a.id !== u.id);
        if (aliveAllies.length === 0 || u.linkedAllyId !== -1) {
            sk2Disable = true;
        }
    }
    
    document.getElementById('sk-2').disabled = sk2Disable;
    
    if (silenced) {
        this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
    }
    
    // ë„ë°œ í™•ì¸
    const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
    if (provoked) {
        const targetId = parseInt(provoked.type.split('_')[2]);
        const enemies = u.team === 0 ? this.eTeam : this.pTeam;
        const allies = u.team === 0 ? this.pTeam : this.eTeam;
        const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
        
        if (!target || target.isDead) {
            u.status = u.status.filter(s => !s.type.startsWith('PROVOKED'));
            this.log(`<span class='log-sys'>ğŸ•Šï¸ [${u.name}] ë„ë°œ ì‹œì „ì ì‚¬ë§! ììœ !</span>`);
            UI.floatText(u, "ììœ !", "ft-heal");
            this.render();
        } else {
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput();
            setTimeout(() => this.execute(u, target, 0), 1000);
            return;
        }
    }
    
    this.selectedSkillIdx = -1;
},
    noInput: function() {
        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            b.disabled = true;
            b.classList.remove('selected');
        });
    },
    prepareSkill: function(idx) {
        // [ë””ë²„ê·¸] ìŠ¤í‚¬ ì„ íƒ ë¡œê·¸ ì¶œë ¥
        this.debugLog('Skill Button Clicked', { skillIndex: idx });

        [0, 1, 2].forEach(i => {
            const b = document.getElementById(`sk-${i}`);
            if (i === idx) b.classList.add('selected');
            else b.classList.remove('selected');
        });
        
        this.selectedSkillIdx = idx;
        
        // í˜„ì¬ í–‰ë™ ì£¼ì²´ ì°¾ê¸°
        let u;
        if (Game.isMindControlling) {
            u = Game.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            u = tVal % 2 === 0 ? this.pTeam[tVal / 2] : this.eTeam[(tVal - 1) / 2];
        }

        // [ë””ë²„ê·¸] í–‰ë™ ìœ ë‹› ì •ë³´ ì¶œë ¥
        this.debugLog('Acting Unit Identified', { name: u.name, id: u.id, isMindControlled: !!Game.isMindControlling });

        const k = u.getKey();
        const s = SKILL_DB[k];
        let targetType = 'ENEMY';

        // [ì•ˆì „ì¥ì¹˜] ìŠ¤í‚¬ ì¸ë±ìŠ¤ë³„ íƒ€ê²Ÿ íƒ€ì… ëª…í™•í™”
        if (idx === 0) {
            targetType = 'ENEMY'; // í‰íƒ€ëŠ” ë¬´ì¡°ê±´ ê³µê²©
        } else if (idx === 1) {
            // S1 ìŠ¤í‚¬ë“¤ì˜ íƒ€ê²Ÿ íƒ€ì… í•˜ë“œì½”ë”© (ë²„ê·¸ ë°©ì§€)
            if (['Tree', 'Fire-Light'].includes(k)) targetType = 'SELF_BUFF'; // ìê°€ë²„í”„ë¥˜
            else if (['Tree-Dark'].includes(k)) targetType = 'ANY_ALLY'; // ì•„êµ° íƒ€ê²Ÿ
            else if (['Water-Light', 'Metal-Light'].includes(k)) targetType = 'ENEMY'; // ë””ë²„í”„ë¥˜
            else targetType = 'ENEMY'; // ë‚˜ë¨¸ì§€ëŠ” ëŒ€ë¶€ë¶„ ê³µê²©ê¸°
        } else if (idx === 2) {
            // S2ëŠ” DBì— ìˆëŠ” target ì†ì„± ì‚¬ìš©
            targetType = s.target || 'ENEMY';
        }

        // íƒ€ê²ŸíŒ… í•¨ìˆ˜ í˜¸ì¶œ
        this.highlightTargets(targetType, u);
    },
    highlightTargets: function(targetType, actingUnit) {
    // 1. í–‰ë™ ìœ ë‹› í™•ì •
    if (!actingUnit) {
        if (Game.isMindControlling) {
            actingUnit = Game.isMindControlling;
        } else {
            const tVal = this.queue[this.curr];
            actingUnit = tVal % 2 === 0 ? this.pTeam[tVal / 2] : this.eTeam[(tVal - 1) / 2];
        }
    }

    // 2. ê¸°ì¡´ íƒ€ê²ŸíŒ… ì´ˆê¸°í™”
    document.querySelectorAll('.unit').forEach(el => {
        el.classList.remove('target-enemy', 'target-ally', 'target-aoe');
        el.onclick = null;
    });

    // 3. ìŠ¤í‚¬ íƒ€ì… ë¶„ë¥˜
    const SUPPORT_TYPES = ['ALLY', 'ALL_ALLY', 'SELF', 'SELF_BUFF', 'TARGET_BUFF', 'HEAL', 'BUFF'];
    const isSupportSkill = SUPPORT_TYPES.includes(targetType);
    const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
    const isSelfOnly = ['SELF', 'SELF_BUFF'].includes(targetType);

    // 4. íŒ€ ì •ì˜ (ì›ë˜ ì†Œì† ê¸°ì¤€)
    const originalAllies = actingUnit.team === 0 ? this.pTeam : this.eTeam;
    const originalEnemies = actingUnit.team === 0 ? this.eTeam : this.pTeam;

    let finalTargets = [];

    // 5. ì„¸ë‡Œ ì—¬ë¶€ì— ë”°ë¥¸ íƒ€ê²Ÿ ê²°ì •
    const isMindControlled = Game.isMindControlling && actingUnit.id === Game.isMindControlling.id;

    if (isSelfOnly) {
        // ìê°€ ë²„í”„ëŠ” í•­ìƒ ìì‹ 
        finalTargets = [actingUnit];
    } else if (isMindControlled) {
        // ì„¸ë‡Œ ìƒíƒœ: íƒ€ê²Ÿ ë°˜ì „
        if (isSupportSkill) {
            // ì§€ì› ìŠ¤í‚¬ -> ì (í”Œë ˆì´ì–´)ì„ ë•ê¸°
            finalTargets = originalEnemies.filter(u => !u.isDead);
        } else {
            // ê³µê²© ìŠ¤í‚¬ -> ì•„êµ°(ì›ë˜ ë™ë£Œ) ê³µê²©
            finalTargets = originalAllies.filter(u => !u.isDead && u.id !== actingUnit.id);
        }
    } else {
        // ì •ìƒ ìƒíƒœ
        if (isSupportSkill) {
            finalTargets = originalAllies.filter(u => !u.isDead);
        } else {
            // [ìˆ˜ì •] ì êµ° + "ì„¸ë‡Œë‹¹í•œ ì•„êµ°"ë„ ê³µê²© ê°€ëŠ¥í•´ì•¼ í•¨
            const realEnemies = originalEnemies.filter(u => !u.isDead);
            const traitors = originalAllies.filter(u => !u.isDead && (u.hasStatus('MC_WAIT') || u.hasStatus('MC_READY')));
            finalTargets = [...realEnemies, ...traitors];
        }
    }

    // 6. Tree-Dark ì˜ˆì™¸ ì²˜ë¦¬
    if (actingUnit.getKey() === 'Tree-Dark' && this.selectedSkillIdx === 2) {
        // ì˜í˜¼ê²°ì†ì€ ìì‹  ì œì™¸
        finalTargets = finalTargets.filter(t => t.id !== actingUnit.id);
    }

    // 7. íƒ€ê²Ÿ ë Œë”ë§
    let targetClass = isSupportSkill ? 'target-ally' : 'target-enemy';
    if (isAOE && !isSupportSkill) targetClass = 'target-aoe';

    let targetCount = 0;

    finalTargets.forEach((t) => {
        const cardId = t.team === 0 ? `p-card-${t.id}` : `e-card-${t.id}`;
        const el = document.getElementById(cardId);
        
        if (el) {
            el.classList.add(targetClass);
            el.onclick = () => {
                if (Game.isProcessing) return;
                Game.isProcessing = true;
                
                // ì…ë ¥ ì ê¸ˆ
                this.noInput();
                document.querySelectorAll('.unit').forEach(e => {
                    e.classList.remove('target-enemy', 'target-ally', 'target-aoe');
                });
                
                // ì‹¤í–‰
                this.execute(actingUnit, t, this.selectedSkillIdx);
            };
            targetCount++;
        }
    });

// 8. ë””ë²„ê¹… ë° ì˜ˆì™¸ ì²˜ë¦¬ (Option 2 ì ìš©)
    if (targetCount === 0) {
        console.warn('âš ï¸ No valid targets:', {
            skillIdx: this.selectedSkillIdx,
            targetType: targetType,
            actingUnit: actingUnit.name,
            isMindControlled: isMindControlled, // ìƒë‹¨ ë³€ìˆ˜ í™œìš©
            finalTargets: finalTargets.map(t => t.name)
        });

        // íƒ€ê²Ÿì´ ì—†ëŠ” ê²½ìš° UI í”¼ë“œë°±
        if (isMindControlled && !isSupportSkill) {
            // [ìƒí™© 1] ì„¸ë‡Œ ìƒíƒœë¼ì„œ íŒ€í‚¬í•  ì•„êµ°(ì›ë˜ ë™ë£Œ)ì´ ë‹¤ ì£½ì–´ì„œ ì—†ëŠ” ê²½ìš°
            UI.floatText(actingUnit, "ëŒ€ìƒì—†ìŒ", "ft-miss");
            this.log(`<span class='log-sys'>âš ï¸ [${actingUnit.name}] ê³µê²©í•  ìˆ˜ ìˆëŠ” ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>`);
        } else if (!isMindControlled && finalTargets.length === 0) {
            // [ìƒí™© 2] ì •ìƒ ìƒíƒœì¸ë° íƒ€ê²Ÿì´ ì—†ìŒ (ì¹˜ëª…ì  ë²„ê·¸ ê°€ëŠ¥ì„±)
            console.error('ğŸš¨ Critical: No targets found in normal state!');
            UI.floatText(actingUnit, "íƒ€ê²Ÿì˜¤ë¥˜", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš¨ [${actingUnit.name}] íƒ€ê²ŸíŒ… ì˜¤ë¥˜ ë°œìƒ</span>`);
        }
    }
}, // ì½¤ë§ˆ í•„ìˆ˜ (ë’¤ì— ai í•¨ìˆ˜ê°€ ìˆìŒ)


    ai: function(u) {
        if (isOnlineMode || this.difficulty === 'local' || this.difficulty === 'pvp') return;

        try {
            // [ìˆ˜ì •] ì„¸ë‡Œ ì¤‘ì´ë¼ë©´ í”¼ì•„ì‹ë³„ ë°˜ì „ (íŒ€í‚¬ ìœ ë„)
            let enemies, allies;
            if (Game.isMindControlling && u.id === Game.isMindControlling.id) {
                // ì„¸ë‡Œëœ AI ì…ì¥ì—ì„œ 'ì 'ì€ 'ìì‹ ì˜ ì›ë˜ ì•„êµ°'ì´ì–´ì•¼ í•¨
                enemies = u.team === 0 ? this.pTeam : this.eTeam; // ë‚˜ì˜ íŒ€ì„ ì ìœ¼ë¡œ ì¸ì‹
                allies = u.team === 0 ? this.eTeam : this.pTeam;  // ìƒëŒ€ íŒ€ì„ ì•„êµ°ìœ¼ë¡œ ì¸ì‹
            } else {
                enemies = u.team === 0 ? this.eTeam : this.pTeam;
                allies = u.team === 0 ? this.pTeam : this.eTeam;
            }
            
            const aliveEnemies = enemies.filter(e => !e.isDead);
            const aliveAllies = allies.filter(a => !a.isDead); // Added for ally checks

            if (aliveEnemies.length === 0) {
                this.endTurn();
                return;
            }

            const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if (provoked) {
                const targetId = parseInt(provoked.type.split('_')[2]);
                const target = enemies.find(e => e.id === targetId) || allies.find(p => p.id === targetId);
                if (target && !target.isDead) {
                    this.execute(u, target, 0);
                    return;
                }
            }

            const silenced = u.hasStatus('SILENCE');
            const k = u.getKey();
            const s = SKILL_DB[k];
            let actions = [];

            const getEnemyScore = (target) => {
                if (!target) return -999;
                let score = 0;
                const baseDmg = Math.floor(u.getAtk() * Game.calc(u, target).v);
                if (target.hp <= baseDmg) score += 1000;
                const tInfo = SKILL_DB[target.getKey()];
                if (tInfo.role === 'supp' || target.getKey().includes('Water')) score += 50;
                if (tInfo.role === 'nuker' && target.hp < target.maxHp * 0.5) score += 40;
                if (Game.calc(u, target).v > 1.0) score += 30;
                score += (1 - target.hp / target.maxHp) * 30;
                return score;
            };

            const getAllyScore = (ally) => {
                let score = 0;
                const hpRatio = ally.hp / ally.maxHp;
                if (hpRatio < 0.3) score += 200;
                else if (hpRatio < 0.6) score += 80;
                else if (hpRatio >= 0.9) score -= 50;
                if (ally.hasStatus('STUN') || ally.hasStatus('FREEZE') || ally.hasStatus('SLEEP')) score += 300;
                if (ally.hasStatus('SILENCE') || ally.hasStatus('POISON') || ally.hasStatus('BURN')) score += 50;
                return score;
            };

            aliveEnemies.forEach(e => {
                actions.push({
                    idx: 0,
                    target: e,
                    score: getEnemyScore(e)
                });
                if (!silenced) {
                    [1, 2].forEach(sIdx => {
                        const skillDesc = sIdx === 1 ? s.s1d : s.s2d;
                        const skillType = sIdx === 2 ? s.type : 'DMG';
                        if (skillType !== 'HEAL' && skillType !== 'BUFF' && skillType !== 'TARGET_BUFF' && s.role !== 'supp') {
                            let skScore = getEnemyScore(e) + 10;
                            const match = skillDesc.match(/([\d.]+)ë°°/);
                            if (match && parseFloat(match[1]) > 1.0) skScore += (parseFloat(match[1]) - 1.0) * 50;
                            const isCC = skillDesc.includes('ê¸°ì ˆ') || skillDesc.includes('ë¹™ê²°') || skillDesc.includes('ì¹¨ë¬µ');
                            if (isCC) {
                                if (e.hasStatus('STUN') || e.hasStatus('FREEZE')) skScore -= 100;
                                else if (e.hp > e.maxHp * 0.5) skScore += 60;
                            }
                            actions.push({
                                idx: sIdx,
                                target: e,
                                score: skScore
                            });
                        }
                    });
                }
            });

            if (!silenced) {
                [1, 2].forEach(sIdx => {
                    const skillDesc = sIdx === 1 ? s.s1d : s.s2d;
                    const isAttack = skillDesc.includes('ë°°') || skillDesc.includes('í”¼í•´');
                    const isSupportSkill = !isAttack && (s.type === 'HEAL' || s.type === 'BUFF' || s.type === 'TARGET_BUFF' || skillDesc.includes('í') || skillDesc.includes('ì •í™”') || skillDesc.includes('ì‰´ë“œ') || skillDesc.includes('í•´ì œ') || skillDesc.includes('ì„±ì¥') || skillDesc.includes('í¡í˜ˆ') || skillDesc.includes('íšŒí”¼'));
                    const isCleanse = skillDesc.includes('ì •í™”') || skillDesc.includes('í•´ì œ');

                    if (isSupportSkill) {
                        aliveAllies.forEach(a => {
                            if ((s.target === 'SELF' || s.target === 'SELF_BUFF') && a.id !== u.id) return;
                            let supScore = getAllyScore(a);
                            if (isCleanse && a.status.length === 0) supScore -= 30;
                            if ((skillDesc.includes('í') || s.type === 'HEAL') && a.hp >= a.maxHp * 0.9) supScore -= 100;
                            if (a.team === u.team) {
                                actions.push({
                                    idx: sIdx,
                                    target: a,
                                    score: supScore
                                });
                            }
                        });
                    }
                });
            }

            actions.sort((a, b) => b.score - a.score);
            let best = actions[0];
            if (!best || !best.target) {
                best = {
                    idx: 0,
                    target: aliveEnemies[Math.floor(this.netRandom() * aliveEnemies.length)]
                };
            }

            if (k === 'Tree' && best.idx === 1) best.target = u;
            if (k === 'Fire-Light' && best.idx === 1) best.target = u;

            this.execute(u, best.target, best.idx);
        } catch (e) {
            console.error("Super Smart AI Error:", e);
            this.endTurn();
        }
    },

    die: function(u) {
        if (u.isDead) return;
        u.isDead = true;
        u.hp = 0;
        u.status = [];
        Game.log(`${u.name} íƒˆë½`);
        if (u.base === 'Tree' && u.extra === 'Dark') {
            Game.log(`ğŸ¥€ [${u.name}] ìµœí›„ì˜ ì €ì£¼! (ê´‘ì—­ ë…)`);
            const enemies = u.team === 0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => {
                if (!e.isDead) e.addStatus('POISON', 1, 0, u);
            });
        }
        const allies = u.team === 0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base === 'Tree' && a.extra === 'Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.revengeAtk += 20;
            thorn.thornStack += 0.3;
            thorn.linkedAllyId = -1;
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê³µ+20 / ê³„ìˆ˜+0.3)`);
            UI.floatText(thorn, "RAGE!", "ft-crit");
        });
    },
    endCheck: function() {
        const pd = this.pTeam.every(u => u.isDead);
        const ed = this.eTeam.every(u => u.isDead);

        if (pd || ed) {
            this.isOver = true;
            if (this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN');

            if (pd && ed) {
                UI.showResult("ë¬´ìŠ¹ë¶€ (Draw)");
            } else if (ed && this.difficulty === 'hell' && !pd) {
                this.challengeStage++;
                let msg = `ğŸ† ìŠ¤í…Œì´ì§€ ${this.challengeStage} í´ë¦¬ì–´!`;
                if (this.challengeStage >= ChallengeDB.length) msg = "ğŸ‰ ëª¨ë“  ì±Œë¦°ì§€ë¥¼ ì •ë³µí–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!";
                localStorage.setItem('et_challenge_stage', this.challengeStage);
                UI.showResult(msg);
            } else {
                UI.showResult(pd ? "ğŸ§¡ ì êµ° (Team 2)" : "ğŸ’™ ì•„êµ° (Team 1)");
            }
            localStorage.removeItem('et_save_v6');
            return true;
        }
        return false;
    },
    log: function(m) {
        const b = document.getElementById('logs');
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.innerHTML = m;
        b.appendChild(d);
        b.scrollTop = b.scrollHeight;
    },
    shake: function(u) {
        const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`;
        const el = document.getElementById(id);
        if (el) {
            el.classList.remove('shake');
            void el.offsetWidth;
            el.classList.add('shake');
        }
    },
    saveGame: function() {
        if (this.isOver) {
            alert("ê²Œì„ì´ ëë‚œ ìƒíƒœëŠ” ì €ì¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }
        const saveData = {
            pTeam: this.pTeam.map(u => this.serializeUnit(u)),
            eTeam: this.eTeam.map(u => this.serializeUnit(u)),
            queue: this.queue,
            curr: this.curr,
            turnCount: this.turnCount,
            difficulty: this.difficulty,
            mode: this.mode,
            selected: this.selected
        };
        localStorage.setItem('et_save_v6', JSON.stringify(saveData));
        UI.floatText(this.pTeam[0], "ê²Œì„ ì €ì¥ë¨!", "ft-heal");
        this.log("<span class='log-sys'>ğŸ’¾ ê²Œì„ ì§„í–‰ ìƒí™©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</span>");
    },
    loadGame: function() {
        const json = localStorage.getItem('et_save_v6');
        const savedStage = localStorage.getItem('et_challenge_stage');
        if (savedStage) this.challengeStage = parseInt(savedStage);
        if (!json) {
            alert(`ì €ì¥ëœ ì „íˆ¬ê°€ ì—†ìŠµë‹ˆë‹¤.\n(í˜„ì¬ ì±Œë¦°ì§€ ë‹¨ê³„: ${this.challengeStage+1})`);
            return;
        }
        try {
            const data = JSON.parse(json);
            this.difficulty = data.difficulty;
            this.mode = data.mode;
            this.turnCount = data.turnCount;
            this.curr = data.curr;
            this.queue = data.queue;
            this.selected = data.selected;
            this.pTeam = data.pTeam.map(d => this.deserializeUnit(d));
            this.eTeam = data.eTeam.map(d => this.deserializeUnit(d));
            document.getElementById('selection-screen').style.display = 'none';
            document.getElementById('battle-screen').style.display = 'flex';
            document.getElementById('logs').innerHTML = '';
            this.log("<span class='log-sys'>ğŸ“‚ ì €ì¥ëœ ê²Œì„ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.</span>");
            this.render();
            if (this.timer) clearTimeout(this.timer);
            const tVal = this.queue[this.curr];
            const u = tVal % 2 === 0 ? this.pTeam[tVal / 2] : this.eTeam[(tVal - 1) / 2];
            let turnName = u.name.split(' ')[0];
            if (this.mode === 'pvp') turnName += (u.team === 0 ? " (1P)" : " (2P)");
            document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${turnName}`;
            if (u.team === 1 && this.mode !== 'pvp') {
                this.noInput();
                this.timer = setTimeout(() => this.ai(u), 1000);
            } else {
                this.input(u);
            }
        } catch (e) {
            console.error(e);
            alert("ì„¸ì´ë¸Œ íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.");
        }
    },
    serializeUnit: function(u) {
        return {
            id: u.id,
            team: u.team,
            base: u.base,
            extra: u.extra,
            hp: u.hp,
            maxHp: u.maxHp,
            shield: u.shield,
            atk: u.atk,
            status: u.status,
            isDead: u.isDead,
            thornStack: u.thornStack,
            linkedAllyId: u.linkedAllyId,
            s2Count: u.s2Count,
            elecStacks: u.elecStacks,
            growthStack: u.growthStack,
            stats: u.stats,
            passiveTriggered: u.passiveTriggered,
            revengeAtk: u.revengeAtk,
            isSuper: u.isSuper
        };
    },
    deserializeUnit: function(d) {
        const u = new Unit(d.id, d.team, d.base, d.extra);
        u.hp = d.hp;
        u.maxHp = d.maxHp;
        u.shield = d.shield;
        u.atk = d.atk;
        u.status = d.status;
        u.isDead = d.isDead;
        if (d.thornStack) u.thornStack = d.thornStack;
        if (d.linkedAllyId) u.linkedAllyId = d.linkedAllyId;
        if (d.s2Count) u.s2Count = d.s2Count;
        if (d.elecStacks) u.elecStacks = d.elecStacks;
        if (d.growthStack) u.growthStack = d.growthStack;
        if (d.stats) u.stats = d.stats;
        if (d.passiveTriggered) u.passiveTriggered = d.passiveTriggered;
        if (d.revengeAtk) u.revengeAtk = d.revengeAtk;
        if (d.isSuper) u.isSuper = d.isSuper;
        return u;
    },
    calc: (a, d) => {
        let v = 1.0;
        let t = '';
        if (a.isNormal) {
            if (d.isNormal || d.isEnhanced) {
                v = 1.2;
                t = '(ê°•íƒ€)';
            }
        } else {
            const w = {
                'Fire': ['Metal', 'Tree'],
                'Water': ['Fire', 'Metal'],
                'Tree': ['Water', 'Earth'],
                'Metal': ['Tree', 'Earth'],
                'Earth': ['Fire', 'Water']
            };
            const ew = {
                'Light': ['Dark'],
                'Dark': ['Light']
            };
            if (!d.isNormal) {
                if (w[a.base]?.includes(d.base) || ew[a.base]?.includes(d.base)) {
                    v = 1.2;
                    t = '(ì•½ì )';
                } else if (w[d.base]?.includes(a.base)) {
                    v = 0.8;
                    t = '(ì €í•­)';
                }
            }
        }
        if (v === 1.2 && a.extra && d.extra && ((a.extra === 'Light' && d.extra === 'Dark') || (a.extra === 'Dark' && d.extra === 'Light'))) {
            v = 1.3;
            t = '(ì¹˜ëª…íƒ€!)';
        }
        return {
            v,
            t
        };
    }
};

window.onload = function() {
    Game.init();
};
</script>
</body>
</html>
