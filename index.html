<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elemental Tactics: v4.1 AI & Meta Update</title>
    <style>
        :root {
            --bg-main: #f4f7f6; --panel-bg: #ffffff;
            --text-main: #2d3436; --accent: #00cec9;
            --hp-high: #00b894; --hp-low: #d63031; --shield: #0984e3;
            --shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        body { 
            margin: 0; background: var(--bg-main); color: var(--text-main); 
            font-family: 'Pretendard', 'Malgun Gothic', sans-serif; 
            overflow: hidden; user-select: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; height: 100dvh; 
        }

        .screen-shake { animation: screenShake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes screenShake { 
            10%, 90% { transform: translate3d(-1px, 0, 0); } 
            20%, 80% { transform: translate3d(2px, 0, 0); } 
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 
            40%, 60% { transform: translate3d(4px, 0, 0); } 
        }

        #flash-overlay { position: fixed; inset: 0; background: white; opacity: 0; pointer-events: none; z-index: 999; transition: opacity 0.1s; }

        #app { width: 100%; max-width: 600px; height: 100%; position: relative; display: flex; flex-direction: column; }
        
        button { font-family: inherit; }
        .btn-restart { 
            background: #fff; border: 1px solid #dfe6e9; padding: 6px 14px; 
            border-radius: 20px; cursor: pointer; font-size: 13px; color: #636e72; transition: 0.2s; 
        }
        .btn-restart:hover { background: #e0f7fa; color: var(--accent); border-color: var(--accent); }

        .screen { position: absolute; inset: 0; background: var(--bg-main); display: flex; flex-direction: column; padding: 15px; z-index: 10; }
        #battle-screen { display: none; padding: 5px; }

        .hero-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; overflow-y: auto; padding: 5px; flex: 1; }
        .hero-card { 
            background: var(--panel-bg); border: 2px solid #e0e0e0; border-radius: 12px; 
            padding: 8px; cursor: pointer; transition: 0.2s; 
            display: flex; flex-direction: column; align-items: center;
            box-shadow: var(--shadow); position: relative;
        }
        .hero-card.selected { border-color: var(--accent); background: #e0f7fa; transform: translateY(-3px); }

        .field-row { flex: 1; display: flex; justify-content: space-evenly; align-items: center; width: 100%; }
        
        .unit { 
            width: 29vw; max-width: 130px; 
            background: var(--panel-bg); border: 3px solid #dfe6e9; 
            border-radius: 12px; padding: 8px 4px; position: relative; transition: 0.3s; 
            cursor: default; box-shadow: var(--shadow); text-align: center;
            display: flex; flex-direction: column; align-items: center;
        }
        
        .unit.active-turn { border-color: var(--accent); transform: scale(1.05); z-index: 5; box-shadow: 0 0 20px rgba(0, 206, 201, 0.5); }
        .unit.target-enemy:hover { border-color: #d63031; background: #fff5f5; cursor: crosshair; }
        .unit.target-ally:hover { border-color: #00b894; background: #e6fffa; cursor: pointer; }
        .unit.target-aoe { border-color: #d63031; background: #ffebee; animation: pulse 1s infinite; cursor: pointer; }
        .unit.dead { opacity: 0.5; filter: grayscale(1); pointer-events: none; border-color: #b2bec3; transform: scale(0.95); }

        /* Role Shapes */
        .unit.role-tank { border-radius: 6px; border-width: 4px; }
        .unit.role-nuker { border-radius: 16px 4px; }
        .unit.role-supp { border-radius: 20px; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); box-shadow: 0 0 15px rgba(214, 48, 49, 0.5); } 100% { transform: scale(1); } }

        .attr-icon { 
            width: 42px; height: 42px; border-radius: 50%; margin-bottom: 4px; 
            display: flex; justify-content: center; align-items: center; font-size: 26px; 
            color: #fff; position: relative; box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .sub-attr-icon {
            position: absolute; bottom: -2px; right: -2px; width: 18px; height: 18px;
            background: #2d3436; color: #fff; border: 2px solid #fff; border-radius: 50%;
            font-size: 10px; display: flex; justify-content: center; align-items: center;
        }
        
        .mini-attr-box {
            position: absolute; bottom: -6px; right: -6px; 
            display: flex; gap: 1px; background: rgba(0,0,0,0.7); 
            padding: 2px; border-radius: 8px; border: 1px solid #fff;
        }
        .mini-icon { font-size: 10px; line-height: 1; }
        
        .status-bar { width: 90%; height: 6px; background: #dfe6e9; border-radius: 3px; overflow: hidden; position: relative; margin-top: 4px; }
        .hp-fill { height: 100%; background: var(--hp-high); transition: width 0.3s; }
        .shield-fill { position: absolute; top:0; left:0; height: 100%; background: var(--shield); opacity: 0.8; transition: width 0.3s; }

        .control-panel { 
            flex: 0 0 auto; max-height: 40vh; 
            background: var(--panel-bg); border-radius: 16px 16px 0 0; 
            box-shadow: 0 -5px 20px rgba(0,0,0,0.05); 
            display: flex; flex-direction: column; overflow: hidden; width: 100%;
        }
        .cp-header { padding: 8px 12px; background: #f8f9fa; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        
        .timeline-container { height: 36px; background: #fff; border-bottom: 1px solid #eee; display: flex; align-items: center; padding: 0 10px; overflow: hidden; gap: 5px; }
        .timeline-label { font-size: 10px; font-weight: bold; color: #b2bec3; margin-right: 5px; }
        .tl-node { width: 26px; height: 26px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 14px; border: 2px solid #ddd; position: relative; flex-shrink: 0; }
        .tl-node.curr { border-color: var(--accent); transform: scale(1.1); z-index: 2; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .tl-node.ally { border-color: #74b9ff; background: #eaf4ff; }
        .tl-node.enemy { border-color: #ff7675; background: #fff0f0; }

        .log-container { flex: 1; padding: 8px; overflow-y: auto; font-size: 12px; border-bottom: 1px solid #eee; background: #fff; line-height: 1.5; display: flex; flex-direction: column; min-height: 50px; }
        .log-entry { margin-bottom: 3px; padding-bottom: 3px; border-bottom: 1px dashed #f1f2f6; word-break: keep-all; }
        .log-ally { color: #2980b9; } .log-enemy { color: #c0392b; } .log-sys { color: #7f8c8d; font-style: italic; }
        .log-crit { color: #e67e22; font-weight: bold; }
        
        .btn-group { display: flex; height: 75px; flex-shrink: 0; }
        .skill-btn { 
            flex: 1; border: none; background: #fff; border-right: 1px solid #eee; 
            cursor: pointer; transition: 0.2s; color: var(--text-main); display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; padding: 5px;
        }
        .skill-btn:hover:not(:disabled) { background: #f3e5f5; }
        .skill-btn.selected { background: #e0f7fa; border-top: 3px solid var(--accent); }
        .skill-btn:disabled { background: #fdfdfd; color: #ccc; cursor: not-allowed; }
        .skill-name { font-size: 13px; font-weight: bold; margin-bottom: 2px; }
        .skill-desc { font-size: 10px; color: #666; line-height: 1.1; }

        .passive-panel {
            background: #f1f2f6; padding: 6px 12px; font-size: 11px; color: #555;
            display: flex; align-items: center; border-top: 1px solid #dfe6e9;
        }
        .passive-icon { margin-right: 6px; font-size: 14px; }
        
        .btn-start { background: var(--accent); color: white; border: none; padding: 16px; border-radius: 12px; font-weight: bold; width: 100%; margin-top: 15px; cursor: pointer; font-size: 16px; box-shadow: 0 4px 10px rgba(0, 206, 201, 0.3); }
        .btn-start:disabled { background: #b2bec3; cursor: not-allowed; box-shadow: none; }

        .btn-rnd { background:#6c5ce7; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:bold; margin-left:5px; }
        .btn-rnd:hover { background:#a29bfe; }

        .bg-Fire { background: linear-gradient(135deg, #ff7675, #d63031); }
        .bg-Water { background: linear-gradient(135deg, #74b9ff, #0984e3); }
        .bg-Tree { background: linear-gradient(135deg, #55efc4, #00b894); }
        .bg-Metal { background: linear-gradient(135deg, #b2bec3, #636e72); }
        .bg-Earth { background: linear-gradient(135deg, #ffeaa7, #e17055); }
        .bg-Light { background: linear-gradient(135deg, #fff7d6, #fdcb6e); color: #2d3436; }
        .bg-Dark { background: linear-gradient(135deg, #a29bfe, #6c5ce7); }
        .bg-Normal { background: linear-gradient(135deg, #dfe6e9, #b2bec3); color:#2d3436; }
        .bg-Light-Enhanced { background: radial-gradient(circle, #fff, #f1c40f); border: 2px solid #f1c40f; color:#333; box-shadow: 0 0 10px #ffeaa7; }
        .bg-Dark-Enhanced { background: radial-gradient(circle, #636e72, #000); border: 2px solid #636e72; box-shadow: 0 0 10px #2d3436; }

        .tag-container { position: absolute; top: -22px; left: 0; width: 100%; display: flex; justify-content: center; gap: 2px; flex-wrap: wrap; z-index: 10; }
        .tag { padding: 3px 6px; border-radius: 4px; font-size: 11px; color: #fff; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.3); text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        .tag.poison { background: #8e44ad; } .tag.stun { background: #f1c40f; color:#333; text-shadow:none; }
        .tag.freeze { background: #00cec9; } .tag.silence { background: #2d3436; }
        .tag.evade { background: #74b9ff; } .tag.burn { background: #d63031; }
        .tag.banish { background: #000; } .tag.burn { background: #d63031; }
        .tag.bind { background: #27ae60; } .tag.trap { background: #e67e22; }
        .tag.atkdown { background: #34495e; } .tag.growth { background: #2ecc71; }
        .tag.blind { background: #95a5a6; color:#333; text-shadow:none; }
        .tag.immunity { background: #fff; color:#333; border:1px solid #333; text-shadow:none; }
        .tag.healdown { background: #8B4513; color:#fff; }
        .tag.atkup { background: #c0392b; color:#fff; }

        .float-text {
            position: absolute; font-weight: 900; font-size: 24px; pointer-events: none; z-index: 100;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); animation: floatUp 0.8s forwards;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 
            20% { transform: translate(-50%, -20px) scale(1.2); opacity: 1; } 
            100% { transform: translate(-50%, -50px) scale(1); opacity: 0; } 
        }
        .ft-dmg { color: #ff7675; } .ft-crit { color: #ffeaa7; font-size: 32px; } 
        .ft-heal { color: #55efc4; } .ft-miss { color: #b2bec3; font-size: 18px; }

        #modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 100; display: none; justify-content: center; align-items: center; }
        .modal-content { background: #fff; padding: 25px; border-radius: 16px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.2); overflow-y:auto; max-height:80vh;}
        
        .chart-table { width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 13px; }
        .chart-table th, .chart-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .chart-table th { background: #f8f9fa; color: #2d3436; }

        .diff-select { margin: 15px 0; padding: 10px; width: 100%; border-radius: 8px; border: 1px solid #dfe6e9; font-size: 14px; }
        .atk-text { font-size: 12px; font-weight: bold; color: #636e72; background: rgba(255,255,255,0.8); padding: 1px 4px; border-radius: 4px; }
    </style>
</head>
<body>

<div id="flash-overlay"></div>
<div id="app">
    <div id="modal-overlay">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-body"></div>
            <button onclick="UI.closeModal()" style="width:100%; padding:10px; background:var(--accent); color:#fff; border:none; cursor:pointer; border-radius:8px; font-weight:bold; margin-top:15px;">í™•ì¸</button>
        </div>
    </div>

    <div id="selection-screen" class="screen">
        <div style="text-align:center; margin-bottom:15px;">
            <h2 style="margin:0 0 10px 0; color:var(--accent);">íŒ€ êµ¬ì„± (3ëª…)</h2>
            <button class="btn-restart" onclick="UI.showChart()">ğŸ“Š ìƒì„±í‘œ ë³´ê¸°</button>
        </div>
        <div class="hero-grid" id="hero-grid"></div>
        <div style="background:#fff; padding:15px; border-radius:12px; margin-top:15px; box-shadow:var(--shadow);">
            <div id="preview-info" style="font-size:13px; color:#636e72;">ì˜ì›…ì„ í´ë¦­í•˜ì—¬ ì •ë³´ë¥¼ í™•ì¸í•˜ì„¸ìš”.</div>
            <div style="display:flex; align-items:center; gap:5px;">
                <select id="diff-select" class="diff-select" style="flex:1;">
                    <option value="easy">ë‚œì´ë„: ì‰¬ì›€ (ëœë¤)</option>
                    <option value="normal" selected>ë‚œì´ë„: ë³´í†µ</option>
                    <option value="hard">ë‚œì´ë„: ì–´ë ¤ì›€</option>
                    <option value="hell">ë‚œì´ë„: ì§€ì˜¥ ğŸ”¥ (TOP 7 ë±)</option>
                </select>
                <button class="btn-rnd" onclick="Game.randomPick()">ğŸ² ëœë¤</button>
            </div>
        </div>
        <button id="btn-start" class="btn-start" onclick="Game.start()" disabled>ì „íˆ¬ ì‹œì‘ (0/3)</button>
    </div>

    <div id="battle-screen" class="screen">
        <div class="field-row" id="enemy-row"></div>
        <div class="control-panel">
            <div class="cp-header">
                <span id="turn-indicator" style="font-weight:bold; font-size:14px; color:var(--accent);">Ready</span>
                <div style="display:flex; gap:8px;">
                    <button class="btn-restart" onclick="UI.showChart()">ğŸ“Š</button>
                    <button class="btn-restart" onclick="Game.reset()">ğŸ”„ ì²˜ìŒìœ¼ë¡œ</button>
                </div>
            </div>
            
            <div class="timeline-container" id="timeline">
                <span class="timeline-label">NEXT:</span>
                <div id="tl-track" style="display:flex; gap:5px;"></div>
            </div>

            <div class="log-container" id="logs"></div>
            
            <div id="passive-panel" class="passive-panel">
                <span id="p-icon" class="passive-icon">â“</span>
                <span id="p-desc">íŒ¨ì‹œë¸Œ ì •ë³´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</span>
            </div>

            <div class="btn-group">
                <button id="sk-0" class="skill-btn" onclick="Game.prepareSkill(0)">ê¸°ë³¸ê³µê²©</button>
                <button id="sk-1" class="skill-btn" onclick="Game.prepareSkill(1)">ìŠ¤í‚¬ 1</button>
                <button id="sk-2" class="skill-btn" onclick="Game.prepareSkill(2)">ìŠ¤í‚¬ 2</button>
            </div>
        </div>
        <div class="field-row" id="player-row"></div>
    </div>
</div>
  <script>
const ATTR = { 'Fire':{i:'ğŸ”¥', n:'ë¶ˆ', c:'#e74c3c'}, 'Water':{i:'ğŸ’§', n:'ë¬¼', c:'#3498db'}, 'Tree':{i:'ğŸŒ¿', n:'ë‚˜ë¬´', c:'#2ecc71'}, 'Metal':{i:'âš”ï¸', n:'ì‡ ', c:'#95a5a6'}, 'Earth':{i:'â›°ï¸', n:'í™', c:'#e67e22'}, 'Light':{i:'â˜€ï¸', n:'ë¹›', c:'#f1c40f'}, 'Dark':{i:'ğŸŒ™', n:'ì–´ë‘ ', c:'#9b59b6'}, 'Normal':{i:'â˜€ï¸ğŸŒ™', n:'ë…¸ë§', c:'#ecf0f1'} };
const NAME_MAP = { 'Water-Light':'ì¦ê¸°', 'Fire-Light':'í‘¸ë¥¸ë¶ˆ', 'Tree-Light':'ìˆ²', 'Metal-Light':'ë…ê°€ìŠ¤', 'Earth-Light':'ëª¨ë˜', 'Water-Dark':'ì–¼ìŒ', 'Fire-Dark':'ê²€ì€ë¶ˆ', 'Tree-Dark':'ê°€ì‹œ', 'Metal-Dark':'ì „ê¸°', 'Earth-Dark':'ë°”ìœ„', 'Light-Light':'ë¹›(ê°•í™”)', 'Dark-Dark':'ì–´ë‘ (ê°•í™”)', 'Normal':'ë…¸ë§' };

const SKILL_DB = {
    'Fire': { s1:'í™”ì—¼ë°©ì‚¬', s1d:'1.3ë°°+í™”ìƒ', s2:'ë©”í…Œì˜¤', s2d:'ê´‘ì—­ 0.8ë°°+í™”ìƒ(25%)', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'ğŸ”¥', passive:'ğŸ©¸ í¡í˜ˆ: ëª¨ë“  ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 20%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤.' },
    'Water': { s1:'ë¬¼ëŒ€í¬', s1d:'1.5ë°°', s2:'ì¹˜ìœ ì˜ ë¹„', s2d:'ì•„êµ°ì „ì²´ HP+110 (20%í™•ë¥  +50)', type:'HEAL', target:'ALL_ALLY', role:'supp', icon:'ğŸ³', passive:null },
    'Tree': { s1:'ê´‘í•©ì„±', s1d:'ì‰´ë“œ+30/ê³µ+18 ì„±ì¥', s2:'ì¹˜ìœ ì˜ ì', s2d:'ì•„êµ°1ëª… HP+150/ì •í™”', type:'SELF_BUFF', target:'SELF', role:'tank', icon:'ğŸŒ³', passive:'ğŸŒ¿ ì„±ì¥: ê´‘í•©ì„± ì‚¬ìš© ì‹œ ì˜êµ¬ì ìœ¼ë¡œ ê³µê²©ë ¥ê³¼ ì‰´ë“œê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Metal': { s1:'ê°•ì² ë² ê¸°', s1d:'1.3ë°°+í”¼í•´í¡ìˆ˜(30%)', s2:'ê²°íˆ¬ ì‹ ì²­', s2d:'ì  ë„ë°œ/ì‰´ë“œ+15', type:'DEBUFF', target:'ENEMY', role:'tank', icon:'ğŸ›¡ï¸', passive:null },
    'Earth': { s1:'ì•”ì„íˆ¬ì²™', s1d:'1.3ë°°+ê¸°ì ˆ25%/ì¹¨ë¬µ20%', s2:'ì§€ì§„', s2d:'ê´‘ì—­ 0.8ë°°', type:'AOE', target:'ALL_ENEMY', role:'supp', icon:'ğŸœï¸', passive:null },
    'Light': { s1:'í™€ë¦¬ë³¼', s1d:'1.5ë°°', s2:'ìˆ˜í˜¸ì˜ ë¹›', s2d:'ì „ì²´ ì‰´ë“œ+60/ê³µ+10(1í„´)', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'âœ¨', passive:null },
    'Dark': { s1:'ë‹¤í¬ë³¼', s1d:'1.5ë°°', s2:'ê³µí¬', s2d:'ê³µâ†“/ì‰´ë“œ30%ì†Œë©¸', type:'DEBUFF', target:'ALL_ENEMY', role:'supp', icon:'ğŸ‘»', passive:null },
    'Normal': { s1:'ê· í˜•íƒ€', s1d:'1.5ë°°/ì•„êµ°ë³´í˜¸(HPì†Œëª¨)', s2:'ì£¼ì‚¬ìœ„', s2d:'ëœë¤ í”¼í•´', type:'RANDOM', target:'ENEMY', role:'nuker', icon:'ğŸ²', passive:null },
    'Light-Light': { s1:'ì‹ ì˜ì‹¬íŒ', s1d:'1.5ë°°', s2:'ì„±ì—­', s2d:'ì „ì²´ ì‰´ë“œ+50/ì •í™”', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ‘¼', passive:null },
    'Dark-Dark': { s1:'ì‹¬ì—°ì¼ê²©', s1d:'0.9ë°°+ì¹¨ë¬µ', s2:'ë¸”ë™í™€', s2d:'í„´ ìŠ¤í‚µ(80%)', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ•³ï¸', passive:'ğŸŒ‘ ì‹¬ì—°ì˜ í˜: ë¸”ë™í™€ ì„±ê³µ ì‹œ ê³µê²©ë ¥ì´ 10 ì˜êµ¬ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Water-Light': { s1:'ìŠ¤íŒ€ì ¯', s1d:'1.4ë°°+ì‹¤ëª…(20%)', s2:'ì•ˆê°œ', s2d:'íƒ€ê²Ÿí+íšŒí”¼(15%)', type:'TARGET_BUFF', target:'ALLY', role:'supp', icon:'â˜ï¸', passive:'â˜ï¸ ì¦ê¸°: íšŒí”¼ ì‹œ ê¸°ì ˆ/ë¹™ê²° CCê¸°ë¥¼ 15% í™•ë¥ ë¡œ ë¬´íš¨í™”í•©ë‹ˆë‹¤ (íšŒí”¼ì†Œë©¸).' },
    'Fire-Light': { s1:'ì²­ì—¼', s1d:'1.5ë°°', s2:'í­ì£¼', s2d:'ìì‹  ê³µ+40 (ìµœëŒ€5íšŒ)', type:'BUFF', target:'SELF', role:'nuker', icon:'ğŸ”·', passive:'ğŸ”¥ í­ì£¼: ìŠ¤í‚¬ ì‚¬ìš© ì‹œ ê³µê²©ë ¥ì´ ëˆ„ì ë©ë‹ˆë‹¤ (ìµœëŒ€ 5íšŒ).' },
    'Tree-Light': { s1:'ìˆ²ì˜ë¶„ë…¸', s1d:'1.2ë°°+ì‰´ë“œê´€í†µ+í', s2:'ì¶•ë³µ', s2d:'ì•„êµ° ì •í™”/HP+70', type:'BUFF', target:'ALL_ALLY', role:'supp', icon:'ğŸ§š', passive:null },
    'Metal-Light': { s1:'ê°€ìŠ¤íƒ„', s1d:'0.5ë°°+ì‰´ë“œíŒŒê´´(ì„±ê³µì‹œ ì‰´ë“œ)', s2:'ë§¹ë…ì‚´í¬', s2d:'ì „ì²´ ì¤‘ë…', type:'DEBUFF', target:'ALL_ENEMY', role:'tank', icon:'â˜£ï¸', passive:null },
    'Earth-Light': { s1:'ëª¨ë˜í­í’', s1d:'1.3ë°°+ì‰´ë“œë¬´ì‹œ', s2:'ëª¨ë˜ì§€ì˜¥', s2d:'ì¹˜ìœ ê°ì†Œ+ë„íŠ¸', type:'DEBUFF', target:'ENEMY', role:'supp', icon:'ğŸ¦‚', passive:null },
    'Water-Dark': { s1:'ê³ ë“œë¦„', s1d:'1.5ë°°', s2:'ì ˆëŒ€ì˜ë„', s2d:'ë¹™ê²°(35%)', type:'DEBUFF', target:'ENEMY', role:'nuker', icon:'â„ï¸', passive:null },
    'Fire-Dark': { s1:'í‘ì—¼', s1d:'1.0ë°°+ê´‘ì—­í™”ìƒ', s2:'ì†Œê°', s2d:'ì²´ë ¥ë¹„ë¡€í”¼í•´', type:'NUKE_PER', target:'ENEMY', role:'nuker', icon:'ğŸ²', passive:'ğŸ©¸ í¡í˜ˆ: ëª¨ë“  ê³µê²© ì‹œ í”¼í•´ëŸ‰ì˜ 20%ë¥¼ íšŒë³µí•©ë‹ˆë‹¤.' },
    'Tree-Dark': { s1:'ê°€ì‹œì°Œë¥´ê¸°', s1d:'1.5ë°°+ìŠ¤íƒê°•í™”', s2:'ì˜í˜¼ê²°ì†', s2d:'ì‚¬ë§ì‹œ í­ì£¼/ê´‘ì—­ë…', type:'TARGET_BUFF', target:'ALLY', role:'tank', icon:'ğŸ¥€', passive:'ğŸ¥€ ë³µìˆ˜: ì‚¬ë§ ì‹œ ì  ì „ì²´ì—ê²Œ ë§¹ë…ì„ ê±¸ê³  ì•„êµ° í•˜ë‚˜ë¥¼ ê°•í™”í•©ë‹ˆë‹¤.' },
    'Metal-Dark': { s1:'ì „ê¸°ì¶©ê²©', s1d:'1.5ë°°+ê³¼ë¶€í•˜(ìµœëŒ€5íšŒ)', s2:'ë°©ì „', s2d:'ê´‘ì—­+ê¸°ì ˆ15%/ê³¼ë¶€í•˜', type:'AOE', target:'ALL_ENEMY', role:'nuker', icon:'âš¡', passive:'âš¡ ê³¼ë¶€í•˜: ê³µê²© ì‹œ ìŠ¤íƒì´ ìŒ“ì´ë©° ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.' },
    'Earth-Dark': { s1:'ë‚™ì„', s1d:'1.5ë°°', s2:'ì‚°ì‚¬íƒœ', s2d:'2.5ë°°+1í„´ê¸°ì ˆ(íœ´ì‹)', type:'ATK', target:'ENEMY', role:'nuker', icon:'ğŸ—¿', passive:null }
};

class Unit {
    constructor(id, team, base, extra) {
        this.id = id; this.team = team;
        this.base = base; this.extra = extra;
        this.maxHp = 600; 
        if(base==='Tree' && extra==='Dark') this.maxHp = 700;
        this.hp = this.maxHp; this.shield = (base==='Metal' && !extra) ? 100 : 0;
        this.atk = 55 + Math.floor(Math.random()*15);
        this.status = []; this.isDead = false;
        this.thornStack = 0; this.linkedAllyId = -1;
        this.resist = 0; 
        this.s2Count = 0;
        this.elecStacks = 0;
        this.stats = { dmg: 0, heal: 0, shieldGiven: 0, taken: 0 }; 

        this.isNormal = (this.base==='Light'&&this.extra==='Dark') || (this.base==='Dark'&&this.extra==='Light');
        this.isEnhanced = (this.base===this.extra && (this.base==='Light'||this.base==='Dark'));
        
        if (this.isNormal) this.name = NAME_MAP['Normal'];
        else if (this.isEnhanced) this.name = NAME_MAP[`${this.base}-${this.extra}`];
        else if (this.extra) this.name = `${NAME_MAP[`${this.base}-${this.extra}`]} (${ATTR[this.base].n}+${ATTR[this.extra].n})`;
        else this.name = `${ATTR[this.base].n} (ê¸°ì´ˆ)`;
    }
    getKey() { if(this.isNormal) return 'Normal'; if(this.isEnhanced) return `${this.base}-${this.extra}`; return SKILL_DB[`${this.base}-${this.extra}`] ? `${this.base}-${this.extra}` : this.base; }
    
    getAtk() { 
        let v = this.atk; 
        const ads = this.status.filter(s=>s.type==='ATK_DOWN'); 
        if(ads.length>0) v -= (ads.length*15); 
        if(this.hasStatus('LIGHT_MIGHT')) v += 10;
        return Math.max(10, v); 
    }
    
    takeDamage(dmg, isFire=false, ignoreShield=false) {
        if (isFire && this.hasStatus('BURN')) dmg = Math.floor(dmg * 1.25);
        if (this.hasStatus('DMG_RED')) dmg = Math.floor(dmg * 0.8);
        if (this.hasStatus('EVADE')) { if(Math.random() < 0.15) return -1; }

        const link = this.status.find(s => s.type.startsWith('REFLECT_LINK_'));
        if (link) Game.recordReflectDamage(this.team, parseInt(link.type.split('_')[2]), dmg);
        
        this.stats.taken += dmg;

        if (!ignoreShield && this.shield > 0) { if(this.shield >= dmg) {this.shield -= dmg; return 0;} else {dmg -= this.shield; this.shield = 0;} }
        this.hp = Math.max(0, this.hp - dmg);
        return dmg;
    }
    
    revive(hpPercent) {
        this.isDead = false;
        this.hp = Math.floor(this.maxHp * hpPercent);
        this.status = [];
        this.shield = 0;
    }

    addStatus(type, turn, val=0, source=null) {
        if (this.isNormal && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        
        if (this.hasStatus('EVADE') && ['STUN', 'FREEZE'].includes(type)) {
            // Self-inflicted check
            if (source && source.id !== this.id) {
                if (Math.random() < 0.15) {
                    UI.floatText(this, "CCíšŒí”¼!", "ft-miss");
                    this.status = this.status.filter(s => s.type !== 'EVADE');
                    return; 
                }
            }
        }

        const HARD_CC = ['STUN', 'FREEZE', 'BANISH'];
        if (HARD_CC.includes(type)) {
            if (this.hasStatus('IMMUNITY')) {
                UI.floatText(this, "ë©´ì—­", "ft-miss");
                return;
            }
            this.status.push({type: 'IMMUNITY', turn: turn + 1});
        }

        if (this.resist > 0 && Math.random() < this.resist && ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN'].includes(type)) return;
        if (type === 'ATK_DOWN') { const s = this.status.filter(s=>s.type==='ATK_DOWN'); if(s.length<2) this.status.push({type,turn,val}); else s[0].turn=turn; return; }
        
        if(type==='BURN') { const ex = this.status.find(s=>s.type==='BURN'); if(ex) { ex.turn = turn; return; } }
        if(type==='HEAL_DOWN') { const ex = this.status.find(s=>s.type==='HEAL_DOWN'); if(ex) { ex.turn = turn; return; } }
        if(type==='LIGHT_MIGHT') { const ex = this.status.find(s=>s.type==='LIGHT_MIGHT'); if(ex) { ex.turn = turn; return; } }

        if (type.startsWith('PROVOKED_BY_') && source) type = `PROVOKED_BY_${source.id}`;

        const idx = this.status.findIndex(s=>s.type===type); if(idx >= 0) this.status[idx].turn = turn; else this.status.push({type, turn, val});
    }
    hasStatus(type) { return this.status.some(s=>s.type===type); }
    
    cleanse() { 
        const bad = ['POISON','BURN','FREEZE','STUN','SILENCE','BLIND','TRAP','BANISH','ATK_DOWN']; 
        this.status = this.status.filter(s => !bad.includes(s.type) && !s.type.startsWith('PROVOKED')); 
    }
    dispel() { const buffs = ['EVADE','DMG_RED','ATK_BUFF','GROWTH','LIGHT_MIGHT']; const has=this.status.some(s=>buffs.includes(s.type)); this.status=this.status.filter(s=>!buffs.includes(s.type)); return has; }
    
    tickStatus() {
        let log = [];
        if(this.hasStatus('POISON')) { const d=this.takeDamage(30); UI.floatText(this, d, 'ft-dmg'); log.push(`â˜ ï¸ [${this.name}] ë… í”¼í•´ ${d}`); }
        if(this.hasStatus('BURN')) { const d=this.takeDamage(20); UI.floatText(this, d, 'ft-dmg'); log.push(`ğŸ”¥ [${this.name}] í™”ìƒ í”¼í•´ ${d}`); }
        if(this.hasStatus('TRAP')) { const d=this.takeDamage(40); UI.floatText(this, d, 'ft-dmg'); log.push(`â³ [${this.name}] ëª¨ë˜ì§€ì˜¥ í”¼í•´ ${d}`); }
        return log;
    }

    decayStatus() {
        this.status.forEach(s => s.turn--);
        this.status = this.status.filter(s => s.turn > 0);
    }
    
    heal(amount) { 
        if(this.hasStatus('HEAL_DOWN')) amount = Math.floor(amount * 0.5); 
        const prev=this.hp; 
        this.hp=Math.min(this.maxHp, this.hp+amount); 
        const diff=this.hp-prev; 
        if(diff>0) {
            UI.floatText(this, diff, 'ft-heal'); 
            this.stats.heal += diff; 
        }
        return diff; 
    }
}

const AudioSys = {
    ctx: null,
    init: function() { try { this.ctx = new (window.AudioContext||window.webkitAudioContext)(); } catch(e){} },
    resume: function() { if(this.ctx&&this.ctx.state==='suspended') this.ctx.resume(); },
    playSoft: function(freq, type, dur, vol=0.1) {
        if(!this.ctx) return;
        const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); const t=this.ctx.currentTime;
        o.type=type; o.frequency.setValueAtTime(freq,t);
        g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+0.05); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.1);
    },
    play: function(type) {
        if(!this.ctx) return;
        if(type==='HIT') this.playSoft(100,'triangle',0.15,0.2);
        else if(type==='SKILL') { this.playSoft(300,'sine',0.2,0.1); setTimeout(()=>this.playSoft(500,'sine',0.3,0.1),100); }
        else if(type==='HEAL') { this.playSoft(400,'sine',0.3,0.1); setTimeout(()=>this.playSoft(600,'sine',0.4,0.1),150); }
        else if(type==='DEBUFF') { this.playSoft(200,'sine',0.3,0.15); setTimeout(()=>this.playSoft(150,'sine',0.4,0.15), 150); }
        else if(type==='MISS') this.playSoft(800,'triangle',0.05,0.05);
        else if(type==='WIN') { setTimeout(()=>this.playSoft(400,'sine',0.3,0.2),0); setTimeout(()=>this.playSoft(600,'sine',0.6,0.2),400); }
        else if(type==='POWER_UP') { 
            this.playSoft(261,'sine',0.4,0.1); setTimeout(()=>this.playSoft(329,'sine',0.4,0.1), 100); setTimeout(()=>this.playSoft(392,'sine',0.6,0.1), 200); 
        }
        else if(type==='CRITICAL') { this.playSoft(80,'triangle',0.1,0.4); setTimeout(()=>this.playSoft(60,'triangle',0.3,0.4), 50); }
    }
};

const UI = {
    showModal: function(title, content) {
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = `<h3 style="color:#00cec9; margin-top:0;">${title}</h3><div>${content}</div>`;
    },
    closeModal: function() { document.getElementById('modal-overlay').style.display = 'none'; },
    showChart: function() {
        const tableHtml = `
            <table class="chart-table">
                <tr><th>ê³µê²©ì</th><th>ìœ ë¦¬í•œ ëŒ€ìƒ (1.2ë°°)</th></tr>
                <tr><td>ğŸ”¥ ë¶ˆ</td><td>âš”ï¸ ì‡ , ğŸŒ¿ ë‚˜ë¬´</td></tr>
                <tr><td>ğŸ’§ ë¬¼</td><td>ğŸ”¥ ë¶ˆ, âš”ï¸ ì‡ </td></tr>
                <tr><td>ğŸŒ¿ ë‚˜ë¬´</td><td>ğŸ’§ ë¬¼, â›°ï¸ í™</td></tr>
                <tr><td>âš”ï¸ ì‡ </td><td>ğŸŒ¿ ë‚˜ë¬´, â›°ï¸ í™</td></tr>
                <tr><td>â›°ï¸ í™</td><td>ğŸ”¥ ë¶ˆ, ğŸ’§ ë¬¼</td></tr>
                <tr><td>â˜€ï¸/ğŸŒ™</td><td>ì„œë¡œì—ê²Œ 1.2ë°°</td></tr>
            </table>
            <div class="dual-chart">
                <div style="font-weight:bold; color:#00cec9; margin-bottom:5px;">âš¡ ì´ì¤‘ ìƒì„± (1.3ë°° ì¹˜ëª…íƒ€)</div>
                <div class="dual-row" style='font-size:12px;'>ê¸°ì´ˆ ì†ì„± ìš°ìœ„ + ë¹›/ì–´ë‘ ì´ ìƒëŒ€ì™€ ë°˜ëŒ€ì¼ ë•Œ ë°œë™</div>
                <div style="font-weight:bold; color:#0984e3; margin-top:5px;">ğŸ›¡ï¸ ìƒì„± ë°©ì–´</div>
                <div class="dual-row" style='font-size:12px;'>ìœ ë¦¬í•œ ì†ì„±ì—ê²Œ í”¼ê²© ì‹œ ë°ë¯¸ì§€ ê°ê²½ (0.83ë°° / 0.76ë°°)</div>
            </div>
        `;
        this.showModal("ğŸ“Š ìƒì„± ê°€ì´ë“œ", tableHtml);
    },
    floatText: function(unit, text, type) {
        const id = unit.team === 0 ? `p-card-${unit.id}` : `e-card-${unit.id}`;
        const unitEl = document.getElementById(id); if(!unitEl) return;
        const el = document.createElement('div'); el.className = `float-text ${type}`;
        el.innerText = type === 'ft-heal' ? `+${text}` : text;
        const rect = unitEl.getBoundingClientRect();
        el.style.left = (rect.left + rect.width / 2 + window.scrollX) + 'px'; el.style.top = (rect.top + window.scrollY) + 'px';
        document.body.appendChild(el); setTimeout(() => el.remove(), 800);
    },
    flash: function() {
        const f = document.getElementById('flash-overlay');
        f.style.opacity = 0.6;
        setTimeout(() => f.style.opacity = 0, 100);
    },
    screenShake: function() {
        document.body.classList.remove('screen-shake');
        void document.body.offsetWidth;
        document.body.classList.add('screen-shake');
    },
    showResult: function(winnerTeamStr) {
        const allUnits = [...Game.pTeam, ...Game.eTeam];
        const maxDmg = Math.max(...allUnits.map(u => u.stats.dmg), 1);
        const maxHeal = Math.max(...allUnits.map(u => u.stats.heal + u.stats.shieldGiven), 1);

        let html = `<h2 style="color:${winnerTeamStr==='ì•„êµ°'?'#00b894':'#d63031'}">${winnerTeamStr} ìŠ¹ë¦¬!</h2>`;
        html += `<div style="max-height:60vh; overflow-y:auto; text-align:left;">`;
        
        const mvp = allUnits.sort((a,b)=>(b.stats.dmg+b.stats.heal+b.stats.shieldGiven)-(a.stats.dmg+a.stats.heal+a.stats.shieldGiven))[0];

        const renderBar = (u) => {
            const dmgPct = (u.stats.dmg / maxDmg) * 100;
            const healPct = ((u.stats.heal + u.stats.shieldGiven) / maxHeal) * 100;
            const isMVP = u.id === mvp.id;
            
            return `
            <div style="margin-bottom:12px; padding:8px; background:${u.team===0?'#f0f8ff':'#fff0f0'}; border-radius:8px; border:1px solid #eee; position:relative;">
                ${isMVP ? '<span style="position:absolute; top:5px; right:5px; font-size:20px;">ğŸ‘‘</span>' : ''}
                <div style="display:flex; align-items:center; gap:5px; margin-bottom:4px;">
                    <div class="attr-icon" style="width:24px; height:24px; font-size:14px; background:${ATTR[u.base].c}">${SKILL_DB[u.getKey()].icon || ATTR[u.base].i}</div>
                    <div style="font-weight:bold; font-size:13px;">${u.name.split(' ')[0]}</div>
                </div>
                <div style="display:flex; align-items:center; font-size:11px; margin-bottom:2px;">
                    <span style="width:30px; color:#555;">ë”œ</span>
                    <div style="flex:1; background:#eee; height:8px; border-radius:4px; overflow:hidden;">
                        <div style="width:${dmgPct}%; background:#ff7675; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right;">${u.stats.dmg}</span>
                </div>
                <div style="display:flex; align-items:center; font-size:11px;">
                    <span style="width:30px; color:#555;">í/ì‰´</span>
                    <div style="flex:1; background:#eee; height:8px; border-radius:4px; overflow:hidden;">
                        <div style="width:${healPct}%; background:#55efc4; height:100%;"></div>
                    </div>
                    <span style="width:35px; text-align:right;">${u.stats.heal + u.stats.shieldGiven}</span>
                </div>
            </div>`;
        };

        html += `<h4 style="margin:5px 0;">ì•„êµ° (Player)</h4>`;
        Game.pTeam.forEach(u => html += renderBar(u));
        html += `<h4 style="margin:10px 0 5px;">ì êµ° (Enemy)</h4>`;
        Game.eTeam.forEach(u => html += renderBar(u));
        html += `</div>`;
        
        document.getElementById('modal-overlay').style.display = 'flex';
        document.getElementById('modal-body').innerHTML = html;
    }
};

const Game = {
    pool: [], selected: [], pTeam: [], eTeam: [], queue: [], curr: 0, selectedSkillIdx: -1, timer: null, turnCount: 1, difficulty: 'normal', watchdog: null,
    isOver: false, 

    init: function() {
        if(this.timer) clearTimeout(this.timer);
        this.isOver = false;
        let combos = [];
        const bases = ['Fire','Water','Tree','Metal','Earth','Light','Dark'];
        const extras = [null, 'Light', 'Dark'];
        bases.forEach(b => extras.forEach(e => combos.push({b, e})));
        combos = combos.filter(c => !(c.b === 'Dark' && c.e === 'Light')); 
        combos.sort(() => Math.random() - 0.5);

        const grid = document.getElementById('hero-grid');
        grid.innerHTML = '';
        this.pool = []; this.selected = [];

        for(let i=0; i<12; i++) {
            const c = combos[i];
            const u = new Unit(i, 0, c.b, c.e);
            this.pool.push(u);
            const el = document.createElement('div');
            el.className = 'hero-card';
            el.innerHTML = this.renderCard(u);
            el.onclick = () => this.toggle(i, el);
            grid.appendChild(el);
        }
        document.getElementById('btn-start').innerText = "ì „íˆ¬ ì‹œì‘ (0/3)";
        document.getElementById('btn-start').disabled = true;
    },

    renderCard: function(u) {
        let bgClass = `bg-${u.base}`;
        if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
        if(u.isNormal) bgClass = 'bg-Normal';
        const role = SKILL_DB[u.getKey()].role || 'Unit';
        const icon = SKILL_DB[u.getKey()].icon || ''; 
        return `<div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div><div style="font-weight:bold; margin-bottom:2px;">${u.name.split(' ')[0]}</div><div style="font-size:11px; color:#aaa;">${u.name}</div><div style="margin-top:5px; font-size:10px; background:#f0f0f0; padding:2px 6px; border-radius:4px;">${role}</div>`;
    },

    toggle: function(i, el) {
        if(this.selected.includes(i)) { this.selected = this.selected.filter(x=>x!==i); el.classList.remove('selected'); }
        else { if(this.selected.length>=3) return; this.selected.push(i); el.classList.add('selected'); }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (${this.selected.length}/3)`;
        btn.disabled = this.selected.length !== 3;
    },

    randomPick: function() {
        Game.selected.forEach(i => {
            const el = document.querySelectorAll('.hero-card')[i];
            if(el) el.classList.remove('selected');
        });
        Game.selected = [];
        while(Game.selected.length < 3) {
            const r = Math.floor(Math.random() * 12);
            if(!Game.selected.includes(r)) {
                Game.selected.push(r);
                const el = document.querySelectorAll('.hero-card')[r];
                if(el) el.classList.add('selected');
            }
        }
        const btn = document.getElementById('btn-start');
        btn.innerText = `ì „íˆ¬ ì‹œì‘ (3/3)`;
        btn.disabled = false;
    },

    start: function() {
        AudioSys.init(); AudioSys.resume();
        this.difficulty = document.getElementById('diff-select').value;
        this.pTeam = this.selected.map((idx, i) => { const u = this.pool[idx]; u.id=i; u.team=0; return u; });
        this.eTeam = [];
        this.isOver = false;
        
        const makeEnemy = (idx, b, e) => { const u = new Unit(idx + 3, 1, b, e); return u; };

        // Hell Mode Decks (Top 7)
        if (this.difficulty === 'hell') {
            const decks = [
                [{b:'Earth',e:'Light'}, {b:'Earth',e:'Dark'}, {b:'Light',e:'Light'}], // ì‚¬ë§‰ì˜ í­í’
                [{b:'Fire',e:null}, {b:'Tree',e:null}, {b:'Water',e:null}], // ë¶ˆì‚¬ì¡°
                [{b:'Metal',e:'Light'}, {b:'Tree',e:'Dark'}, {b:'Metal',e:null}], // ë…ì„± ë²™ì»¤
                [{b:'Water',e:'Dark'}, {b:'Normal',e:null}, {b:'Earth',e:null}], // ë¹™ê²° ë¡œë˜
                [{b:'Metal',e:'Dark'}, {b:'Fire',e:'Light'}, {b:'Normal',e:null}], // ì™•ê·€ ë“€ì˜¤
                [{b:'Fire',e:'Dark'}, {b:'Tree',e:'Light'}, {b:'Earth',e:'Light'}], // íƒ±ì»¤ ë¶„ì‡„ê¸°
                [{b:'Fire',e:null}, {b:'Water',e:null}, {b:'Tree',e:null}] // í´ë˜ì‹
            ];
            const d = decks[Math.floor(Math.random()*decks.length)];
            this.eTeam = d.map((c, i) => makeEnemy(i, c.b, c.e));
        } else {
            const used = new Set();
            while(this.eTeam.length<3) {
                const b = ['Fire','Water','Tree','Metal','Earth','Light','Dark'][Math.floor(Math.random()*7)];
                const e = [null,'Light','Dark'][Math.floor(Math.random()*3)];
                if(b==='Dark'&&e==='Light') continue; 
                
                let key = `${b}-${e}`;
                if(b==='Light'&&e==='Dark') key = 'Normal';
                
                if(!used.has(key)) { 
                    used.add(key); 
                    this.eTeam.push(makeEnemy(this.eTeam.length, b, e)); 
                }
            }
        }
        this.queue = [0,1,2,3,4,5]; this.curr = Math.floor(Math.random()*6);
        this.turnCount = 1;
        document.getElementById('selection-screen').style.display='none';
        document.getElementById('battle-screen').style.display='flex';
        document.getElementById('logs').innerHTML = ''; 
        this.log("<span class='log-sys'>âš”ï¸ ì „íˆ¬ ì‹œì‘! (v4.1 AI & Meta Update)</span>");
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1000);
    },

    reset: function() {
        if(this.timer) clearTimeout(this.timer);
        if(this.watchdog) clearTimeout(this.watchdog);
        UI.closeModal();
        document.getElementById('battle-screen').style.display='none';
        document.getElementById('selection-screen').style.display='flex';
        this.init();
    },

    recordReflectDamage: function(teamId, ownerId, amount) {},
    
    recordStat: function(unit, type, amount) {
        if(!unit || amount <= 0) return;
        if(type === 'dmg') unit.stats.dmg += amount;
        if(type === 'shield') unit.stats.shieldGiven += amount;
    },

    turn: function() {
        if (this.isOver) return;

        if(this.watchdog) clearTimeout(this.watchdog);
        this.watchdog = setTimeout(() => {
            console.log("AI Stuck Detected. Forcing next turn.");
            this.endTurn();
        }, 3000);

        if(this.endCheck()) return;
        const tVal = this.queue[this.curr];
        const u = tVal%2===0 ? this.pTeam[tVal/2] : this.eTeam[(tVal-1)/2];

        if(u.isDead) { this.endTurn(); return; }

        if(u.hasStatus('FREEZE') || u.hasStatus('STUN') || u.hasStatus('BANISH')) {
            UI.floatText(u, "SKIP", "ft-miss");
            this.log(`<span class='log-sys'>ğŸš« ${u.name} í–‰ë™ë¶ˆê°€</span>`);
            setTimeout(() => this.endTurn(), 800);
            return;
        }
        
        const tickLogs = u.tickStatus();
        tickLogs.forEach(l => this.log(`<span class='log-sys'>${l}</span>`));
        this.render();
        if(u.hp<=0) { this.die(u); this.endTurn(); return; }

        document.getElementById('turn-indicator').innerText = `Turn ${Math.ceil(this.turnCount/6)} : ${u.name}`;
        this.turnCount++;
        
        if(u.team===0) { 
            if(this.watchdog) clearTimeout(this.watchdog);
            this.input(u); 
        } else { 
            this.noInput(); 
            this.timer=setTimeout(()=>this.ai(u), 800); 
        }
    },

    input: function(u) {
        const k=u.getKey(); const s=SKILL_DB[k];
        const silenced = u.hasStatus('SILENCE');
        
        document.getElementById('p-icon').innerText = s.icon;
        document.getElementById('p-desc').innerText = s.passive || 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';

        document.getElementById('sk-1').innerHTML = `<span class="skill-name">${s.s1}</span><br><span class="skill-desc">${s.s1d}</span>`;
        document.getElementById('sk-2').innerHTML = `<span class="skill-name">${s.s2}</span><br><span class="skill-desc">${s.s2d}</span>`;
        document.getElementById('sk-0').disabled = false;
        document.getElementById('sk-1').disabled = silenced;
        
        let s2Limit = false;
        if (k === 'Fire-Light' && u.s2Count >= 5) s2Limit = true;
        let sk2Disable = silenced || s2Limit;
        
        // [Logic] Disable Self-Target S2 for Thorn if alone
        if (k === 'Tree-Dark') {
            const aliveAllies = Game.pTeam.filter(a => !a.isDead && a.id !== u.id);
            if (aliveAllies.length === 0 || u.linkedAllyId !== -1) sk2Disable = true;
        }
        
        document.getElementById('sk-2').disabled = sk2Disable;
        
        if(silenced) this.log(`<span class='log-sys'>ğŸ˜¶ [${u.name}] ì¹¨ë¬µ ìƒíƒœ!</span>`);
        const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
        if(provoked) {
            const targetId = parseInt(provoked.type.split('_')[2]);
            const target = this.eTeam.find(e => e.id === targetId) || this.pTeam.find(p => p.id === targetId);
            this.log(`<span class='log-sys'>ğŸ’¢ [${u.name}] ë„ë°œ ë‹¹í•¨!</span>`);
            this.noInput(); 
            if(target && !target.isDead) setTimeout(() => this.execute(u, target, 0), 1000);
            else setTimeout(() => { this.selectedSkillIdx=0; this.highlightTargets('ENEMY'); }, 500); 
            return;
        }
        this.selectedSkillIdx = -1;
    },
    
    noInput: function() { [0,1,2].forEach(i=>{ const b = document.getElementById(`sk-${i}`); b.disabled=true; b.classList.remove('selected'); }); },

    prepareSkill: function(idx) {
        [0,1,2].forEach(i => { const b = document.getElementById(`sk-${i}`); if(i===idx) b.classList.add('selected'); else b.classList.remove('selected'); });
        this.selectedSkillIdx = idx;
        const u = this.pTeam[this.queue[this.curr]/2]; const k = u.getKey(); const skillInfo = SKILL_DB[k];
        let targetType = (idx === 0 || idx === 1) ? 'ENEMY' : skillInfo.target;
        if(k==='Tree') { if(idx===1) targetType = 'SELF'; else if(idx===2) targetType = 'ALLY'; }
        if(k==='Water-Light' && idx===2) targetType = 'ALLY';
        this.highlightTargets(targetType);
    },

    highlightTargets: function(targetType) {
        document.querySelectorAll('.unit').forEach(el => { 
            el.classList.remove('target-enemy', 'target-ally', 'target-aoe'); 
            el.onclick = null; 
        });

        const isAOE = ['ALL_ENEMY', 'ALL_ALLY', 'AOE'].includes(targetType);
        const isAllyTarget = ['ALLY','ALL_ALLY','SELF'].includes(targetType);
        
        const targets = isAllyTarget ? this.pTeam : this.eTeam;
        let targetClass = isAllyTarget ? 'target-ally' : 'target-enemy';
        if (isAOE && !isAllyTarget) targetClass = 'target-aoe'; 

        targets.forEach((t) => {
            if(!t.isDead) {
                const el = document.getElementById(isAllyTarget ? `p-card-${t.id}` : `e-card-${t.id}`);
                el.classList.add(targetClass);
                el.onclick = () => {
                    if(targetType === 'SELF' && t.id !== this.pTeam[this.queue[this.curr]/2].id) return;
                    this.noInput();
                    document.querySelectorAll('.unit').forEach(el => el.classList.remove('target-enemy', 'target-ally', 'target-aoe'));
                    this.execute(this.pTeam[this.queue[this.curr]/2], t, this.selectedSkillIdx);
                };
            }
        });
    },

    ai: function(u) {
        try {
            const silenced = u.hasStatus('SILENCE');
            const provoked = u.status.find(st => st.type.startsWith('PROVOKED_BY_'));
            if(provoked) {
                const targetId = parseInt(provoked.type.split('_')[2]);
                const target = this.pTeam.find(p => p.id === targetId) || this.eTeam.find(e => e.id === targetId);
                if(target && !target.isDead) { this.execute(u, target, 0); return; }
            }

            const enemies = u.team === 0 ? this.eTeam : this.pTeam; 
            const allies = u.team === 0 ? this.pTeam : this.eTeam; 
            const aliveEnemies = enemies.filter(e => !e.isDead);
            const aliveAllies = allies.filter(a => !a.isDead);

            const k = u.getKey(); 
            const info = SKILL_DB[k];
            
            let blockS2 = false;
            if (k === 'Fire-Light') {
                const hasBuff = u.status.some(s => s.type === 'ATK_BUFF'); 
                if (hasBuff || u.s2Count >= 5) blockS2 = true; 
            }
            if (k === 'Tree-Dark') {
                if (u.linkedAllyId !== -1 || aliveAllies.length <= 1) blockS2 = true; // [Logic] Thorn AI fix
            }

            let attackTarget = aliveEnemies[0];
            let bestScore = -9999;
            aliveEnemies.forEach(e => {
                let score = 0;
                // [AI] Execution Logic
                const potentialDmg = u.getAtk() * (info.type==='NUKE_PER'?1.5:1.0) * Game.calc(u, e).v;
                if (e.hp <= potentialDmg) score += 500; 

                if (e.hp < u.getAtk() * 1.5) score += 50; 
                const aff = Game.calc(u, e).v;
                if (aff > 1.2) score += 20; 
                if (e.hp < e.maxHp * 0.4) score += 10;
                
                // [AI] Don't waste CC
                if (['STUN','FREEZE','BANISH'].some(s => e.hasStatus(s))) score -= 30;

                if (score > bestScore) { bestScore = score; attackTarget = e; }
            });
            if (this.difficulty === 'easy') attackTarget = aliveEnemies[Math.floor(Math.random()*aliveEnemies.length)];

            let supportTarget = aliveAllies.sort((a,b) => a.hp - b.hp)[0]; 

            let action = 0;
            let finalTarget = attackTarget; 

            if (!silenced) {
                const isS2Support = ['BUFF','SELF_BUFF','HEAL','TARGET_BUFF','ALL_ALLY'].includes(info.type);
                let useS2 = false;
                if (this.difficulty === 'hell' || this.difficulty === 'hard') {
                     useS2 = true; 
                     // [AI] Don't Overheal
                     if (isS2Support && info.type === 'HEAL' && supportTarget.hp > supportTarget.maxHp * 0.8) useS2 = false;
                } else {
                     useS2 = Math.random() > 0.4;
                }

                if (useS2 && !blockS2) {
                    if (isS2Support) {
                        action = 2;
                        finalTarget = supportTarget; 
                        if (info.type === 'SELF_BUFF') finalTarget = u;
                    } else {
                        action = 2; 
                    }
                } else {
                    action = 1; 
                }
            }
            
            if (['HEAL'].includes(info.type) && !silenced) {
                action = 2;
                finalTarget = supportTarget;
            }

            this.execute(u, finalTarget, action);
        } catch (e) {
            console.error(e);
            this.endTurn(); 
        }
    },

    execute: function(atk, def, sIdx) {
        document.querySelectorAll('.unit').forEach(el=>el.onclick=null);
        const k = atk.getKey(); const s = SKILL_DB[k];
        
        const aff = (def && def.team !== atk.team) ? this.calc(atk, def) : {v:1, t:''};
        let defMod = 1.0;
        if (def && def.team !== atk.team) {
            const defAff = this.calc(def, atk); 
            if (defAff.v === 1.3) defMod = 0.76; 
            else if (defAff.v === 1.2) defMod = 0.83;
        }

        let m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ${sIdx===0?'ê³µê²©':(sIdx===1?s.s1:s.s2)}`;
        
        const isGlobal = ['AOE','HEAL','BUFF','ALL_ALLY'].includes(s.type) && sIdx === 2;
        if (!isGlobal && def) {
             m += ` â” <b class="${def.team===0?'log-ally':'log-enemy'}">[${def.name}]</b>`;
        }

        if (atk.hasStatus('BLIND') && Math.random() < 0.20) { 
            m += " (ì‹¤ëª…ìœ¼ë¡œ ë¹—ë‚˜ê°!)"; UI.floatText(atk, "MISS", "ft-miss"); AudioSys.play('MISS');
            this.log(m); this.endTurn(); return;
        }

        const baseAtk = atk.getAtk();
        let playedSound = false;

        // [Logic] Skill Execution
        if(sIdx === 0) {
            AudioSys.play('HIT'); playedSound=true;
            const dmg = Math.floor(baseAtk * 1.0 * aff.v * defMod);
            const act = def.takeDamage(dmg);
            Game.recordStat(atk, 'dmg', act); 
            if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); AudioSys.play('MISS'); }
            else { 
                m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); 
                UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg");
                if (aff.v > 1.2 || act > 150) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; } 
                
                // [Fire Passive: Lifesteal]
                if (k.startsWith('Fire')) {
                    const healAmt = Math.floor(act * 0.2);
                    atk.heal(healAmt);
                }
            }
        } 
        else if (sIdx === 1) {
            if(k === 'Tree') {
                atk.shield += 30; Game.recordStat(atk, 'shield', 30);
                atk.atk += 18; atk.addStatus('GROWTH', 99); 
                m = `<b class="${atk.team===0?'log-ally':'log-enemy'}">[${atk.name}]</b> ê´‘í•©ì„±! (ì„±ì¥)`;
                UI.floatText(atk, "GROWTH", "ft-heal");
                AudioSys.play('POWER_UP'); playedSound=true;
            } else {
                let mult = 1.5; if(k==='Tree-Dark') mult += atk.thornStack; if(k==='Water-Light') mult = 1.4;
                if (k==='Metal-Light') mult = 0.5;
                if (k==='Metal') mult = 1.3;
                if (k==='Dark-Dark') mult = 0.9; 

                let rawDmg = Math.floor(baseAtk * mult * aff.v * defMod);
                
                if(k==='Metal-Light' || k==='Earth') { AudioSys.play('DEBUFF'); playedSound=true; }

                if(k==='Earth') { if(Math.random() < 0.25) { def.addStatus('STUN', 1, 0, atk); m+='(ê¸°ì ˆ) '; } else if(Math.random() < 0.20) { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; } }
                
                if(k==='Metal-Light') { 
                    const broken = def.shield > 0;
                    def.shield=0; def.addStatus('POISON', 3, 0, atk); m+='(ì‰´ë“œíŒŒê´´+ì¤‘ë…) '; 
                    if (broken) {
                        const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                        const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                        if(lowest) { lowest.shield += 30; Game.recordStat(atk, 'shield', 30); UI.floatText(lowest, "+30ğŸ›¡ï¸", "ft-heal"); m+=`(ì•„êµ°ë³´í˜¸) `; }
                    }
                }

                if(k==='Dark-Dark') { def.addStatus('SILENCE', 2, 0, atk); m+='(ì¹¨ë¬µ) '; }
                if(k==='Water-Light' && Math.random()<0.2) { def.addStatus('BLIND', 1, 0, atk); m+='(ì‹¤ëª… ì„±ê³µ) '; }
                if(k==='Fire') { def.addStatus('BURN', 2, 0, atk); m+='(í™”ìƒ) '; }
                if(k==='Fire-Dark') { (atk.team===0 ? this.eTeam : this.pTeam).forEach(e => { if(!e.isDead) e.addStatus('BURN', 2, 0, atk); }); m += '(ì „ì²´ í™”ìƒ) '; }
                if(k==='Tree-Light') {
                    const allies = atk.team===0 ? this.pTeam : this.eTeam;
                    const alive = allies.filter(a=>!a.isDead);
                    if(alive.length > 0) { const lucky = alive[Math.floor(Math.random()*alive.length)]; lucky.heal(20); m+=`(ì•„êµ° íšŒë³µ) `; }
                }
                if(k==='Metal-Dark' && Math.random()<0.1) { 
                    const extra = Math.floor(baseAtk * 1.0 * aff.v * defMod); rawDmg += extra; 
                    if(atk.elecStacks < 5) { atk.atk += 25; atk.elecStacks++; AudioSys.play('POWER_UP'); } 
                    m += `<span class='log-crit'>(âš¡ê³¼ë¶€í•˜!+${extra})</span>`; 
                }

                if (k === 'Normal') {
                    atk.hp = Math.max(0, atk.hp - 30);
                    const teamArr = atk.team === 0 ? Game.pTeam : Game.eTeam;
                    const lowest = teamArr.filter(a=>!a.isDead).sort((a,b)=>a.hp - b.hp)[0];
                    if (lowest) {
                        const shieldAmt = (lowest.id === atk.id) ? 60 : 50;
                        lowest.shield += shieldAmt; Game.recordStat(atk, 'shield', shieldAmt); UI.floatText(lowest, `+${shieldAmt}ğŸ›¡ï¸`, "ft-heal");
                    }
                    m += ` (HPì†Œëª¨/ë³´í˜¸)`;
                }

                if (k === 'Earth-Light' || k === 'Tree-Light') { 
                    let actual = def.takeDamage(rawDmg, false, true);
                    Game.recordStat(atk, 'dmg', actual);
                    m += ` ${actual} í”¼í•´ (ì‰´ë“œë¬´ì‹œ) ${aff.t}`; this.shake(def); UI.floatText(def, actual, "ft-crit");
                } else {
                    const act = def.takeDamage(rawDmg, k.startsWith('Fire'));
                    Game.recordStat(atk, 'dmg', act);
                    if(act===-1) { m+="ë¹—ë‚˜ê°!"; UI.floatText(def, "MISS", "ft-miss"); }
                    else { 
                        m += ` ${act} í”¼í•´ ${aff.t}`; this.shake(def); UI.floatText(def, act, aff.v>1.2?"ft-crit":"ft-dmg"); 
                        if (k === 'Metal') {
                            const absorb = Math.floor(act * 0.3); atk.shield += absorb; Game.recordStat(atk, 'shield', absorb); UI.floatText(atk, `+${absorb}`, "ft-heal");
                        }
                        if (k.startsWith('Fire')) {
                            const healAmt = Math.floor(act * 0.2);
                            atk.heal(healAmt);
                        }
                    }
                }
            }
        } 
        else {
            if (k === 'Fire-Light') { atk.s2Count++; if(atk.s2Count<=5) AudioSys.play('POWER_UP'); playedSound=true; }

            if (k === 'Dark-Dark') {
                atk.takeDamage(20); AudioSys.play('DEBUFF'); playedSound=true;
                if(Math.random() < 0.8) { 
                    def.addStatus('BANISH', 1); m += " (ğŸŒŒì¶”ë°© ì„±ê³µ)"; UI.floatText(def,"ì¶”ë°©!","ft-miss"); 
                    atk.atk += 10;
                } 
                else { m += " (ì¶”ë°© ì‹¤íŒ¨)"; UI.floatText(def,"ì €í•­","ft-miss"); }
            }
            else if (k === 'Water-Dark') {
                const act = def.takeDamage(Math.floor(baseAtk)); Game.recordStat(atk, 'dmg', act); m += ` ${act} í”¼í•´`; UI.floatText(def, act, "ft-dmg");
                if(Math.random() < 0.35) { def.addStatus('FREEZE', 1); m += " (â„ï¸ë¹™ê²°)"; UI.floatText(def,"ë¹™ê²°","ft-miss"); }
            }
            else if (k === 'Normal') {
                const rnd = Math.random() * 1.7 + 0.8;
                const dmg = Math.floor(baseAtk * rnd * aff.v * defMod);
                const act = def.takeDamage(dmg); Game.recordStat(atk, 'dmg', act); m += ` ì£¼ì‚¬ìœ„(x${rnd.toFixed(2)}) ${act}`; this.shake(def); UI.floatText(def, act, "ft-dmg");
                if(rnd > 2.0) { AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true; }
            }
            else if(s.type === 'AOE') {
                m += " (ì „ì²´ ê³µê²©!)";
                (atk.team===0?this.eTeam:this.pTeam).forEach(e => { if(!e.isDead) {
                    let indDefMod = 1.0;
                    const da = Game.calc(e, atk);
                    if(da.v===1.3) indDefMod=0.76; else if(da.v===1.2) indDefMod=0.83;
                    const dmg = Math.floor(baseAtk * 0.8 * Game.calc(atk, e).v * indDefMod);
                    const act = e.takeDamage(dmg, k.startsWith('Fire'));
                    Game.recordStat(atk, 'dmg', act);
                    if(act !== -1) { 
                        this.shake(e); UI.floatText(e, act, "ft-dmg"); 
                        if(k==='Earth-Light') e.addStatus('BLIND', 2); 
                        if(k==='Metal-Dark'&&Math.random()<0.15) e.addStatus('STUN', 1);
                        if(k==='Fire' && Math.random()<0.25) e.addStatus('BURN', 2, 0, atk); 
                        if (k.startsWith('Fire')) {
                            const healAmt = Math.floor(act * 0.2);
                            atk.heal(healAmt);
                        }
                    }
                }});
            } 
            else if(s.type === 'HEAL') { 
                AudioSys.play('HEAL'); playedSound=true;
                (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{if(!a.isDead) a.heal(110)});
                m+=" (ì•„êµ° ì „ì²´ íšŒë³µ +110)"; 
                if(k==='Water' && Math.random() < 0.2) {
                    const lowest = (atk.team===0?this.pTeam:this.eTeam).filter(a=>!a.isDead).sort((a,b)=>a.hp-b.hp)[0];
                    if(lowest) { lowest.heal(50); m+=` (ğŸ’§ëŒ€ë°•í +50)`; UI.floatText(lowest, "+50", "ft-heal"); }
                }
            }
            else if(s.type === 'BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                m += " (ì•„êµ° ì „ì²´ ê°•í™”)";
                const allies = atk.team===0?this.pTeam:this.eTeam;
                if(k==='Light') allies.forEach(a=>{if(!a.isDead) { 
                    a.shield=Math.min(300, a.shield+60); 
                    a.addStatus('LIGHT_MIGHT', 1); 
                    Game.recordStat(atk,'shield',60); 
                }}); 
                else if(k==='Light-Light') allies.forEach(a=>{if(!a.isDead) {a.shield=Math.min(300, a.shield+50); Game.recordStat(atk,'shield',50); a.cleanse();}}); 
                else if(k==='Fire-Light') { atk.atk+=40; atk.addStatus('ATK_BUFF', 99); m="ìì‹  ê³µê²©ë ¥ +40"; }
                else if(k==='Tree-Light') allies.forEach(a=>{if(!a.isDead) {a.heal(70); a.cleanse();}});
            } 
            else if(s.type === 'TARGET_BUFF' || s.type === 'SELF_BUFF') {
                AudioSys.play('HEAL'); playedSound=true;
                if(def) { 
                    if(k==='Tree') { def.heal(150); def.cleanse(); m+=` ì¹˜ìœ /ì •í™”`; }
                    else if(k==='Tree-Dark') { 
                        // [Future] Self-cast logic prepared
                        if (atk.id === def.id) {
                            // m += " (ìì‹ ì—ê²Œ ì‚¬ìš© ë¶ˆê°€)"; 
                        } else {
                            atk.linkedAllyId = def.id; def.addStatus('BIND', 99); atk.resist += 0.3; m+=` ê²°ì†! (í­ì£¼ëŒ€ê¸°/ì €í•­â†‘)`; 
                        }
                    }
                    else if(k==='Water-Light') {
                        (atk.team===0?this.pTeam:this.eTeam).forEach(a=>{if(!a.isDead) a.addStatus('EVADE', 2)});
                        const healAmt = Math.floor((def.maxHp - def.hp) * 0.15); def.heal(healAmt); m += ` (íšŒí”¼ì¦ê°€+ì¹˜ìœ )`;
                    }
                }
            } 
            else if(s.type === 'DEBUFF') {
                AudioSys.play('DEBUFF'); playedSound=true;
                if(k==='Metal') { def.addStatus(`PROVOKED_BY_${atk.id}`, 2, 0, atk); atk.addStatus('DMG_RED', 2); atk.shield+=15; Game.recordStat(atk,'shield',15); m += ` ë„ë°œ! (ì‰´ë“œ+15)`; }
                else if(k==='Dark') { (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{if(!e.isDead){ e.addStatus('ATK_DOWN', 2); e.shield=Math.floor(e.shield*0.7); if(Math.random()<0.2) e.dispel(); }}); m+=" (ì  ì „ì²´ ê³µí¬)"; }
                else if(k==='Metal-Light') { 
                    (atk.team===0?this.eTeam:this.pTeam).forEach(e=>{
                        if(!e.isDead) { e.addStatus('POISON', 3); }
                    }); 
                    m+=" (ê´‘ì—­ ì¤‘ë… ì‚´í¬)"; 
                }
                else if(k==='Earth-Light') { 
                    def.addStatus('TRAP', 2); 
                    def.addStatus('HEAL_DOWN', 2); 
                    m+=` ëª¨ë˜ì§€ì˜¥(ì†ë°•+ì¹˜ìœ ê°ì†Œ)`; 
                }
            } 
            else if(s.type === 'NUKE' || s.type === 'NUKE_PER' || s.type === 'ATK') {
                let dmg = 0;
                if (s.type === 'NUKE_PER') dmg = Math.floor(baseAtk * 1.2 * aff.v * defMod + def.maxHp * 0.1);
                else if (k === 'Earth-Dark') dmg = Math.floor(baseAtk * 2.5 * aff.v * defMod);
                else dmg = Math.floor(baseAtk * 2.0 * aff.v * defMod);

                if(k==='Earth-Dark') atk.addStatus('STUN', 2);
                
                const act = def.takeDamage(dmg, k.startsWith('Fire'));
                Game.recordStat(atk, 'dmg', act);
                if(act!==-1) { 
                    m+=` ${act} í­ë°œì  í”¼í•´!`; this.shake(def); UI.floatText(def, act, "ft-crit"); 
                    AudioSys.play('CRITICAL'); UI.screenShake(); UI.flash(); playedSound=true;
                    if (k.startsWith('Fire')) {
                        const healAmt = Math.floor(act * 0.2);
                        atk.heal(healAmt);
                    }
                } else AudioSys.play('MISS');
            }
        }
        
        if (!playedSound) AudioSys.play('SKILL');

        if(k === 'Metal-Dark' && sIdx===2 && Math.random() < 0.1) {
            const aliveE = (atk.team===0?this.eTeam:this.pTeam).filter(e=>!e.isDead);
            if(aliveE.length>0) { const target = aliveE[Math.floor(Math.random()*aliveE.length)]; const extra = Math.floor(baseAtk); target.takeDamage(extra, false); Game.recordStat(atk,'dmg',extra); m += `<br>âš¡ ê³¼ë¶€í•˜! +${extra}`; UI.floatText(target, extra, "ft-crit"); }
        }
        this.log(m); this.endTurn();
    },

    endTurn: function() {
        if(this.isOver) return; 
        if(this.watchdog) clearTimeout(this.watchdog);
        
        const u = this.queue[this.curr]%2===0 ? this.pTeam[this.queue[this.curr]/2] : this.eTeam[(this.queue[this.curr]-1)/2];
        if(u && !u.isDead) u.decayStatus();

        [...this.pTeam, ...this.eTeam].forEach(u=>{if(u.hp<=0) this.die(u)});
        this.curr = (this.curr+1)%6;
        if(this.curr===0) this.turnCount++;
        this.render();
        this.timer = setTimeout(()=>this.turn(), 1500);
    },

    calc: (a,d) => {
        let v = 1.0;
        let t = '';
        if(a.isNormal) {
            if(d.isNormal||d.isEnhanced) { v=1.2; t='(ê°•íƒ€)'; }
        } else {
            const w={'Fire':['Metal','Tree'],'Water':['Fire','Metal'],'Tree':['Water','Earth'],'Metal':['Tree','Earth'],'Earth':['Fire','Water']};
            const ew={'Light':['Dark'],'Dark':['Light']};
            if(!d.isNormal){ 
                if(w[a.base]?.includes(d.base)||ew[a.base]?.includes(d.base)) { v=1.2; t='(ì•½ì )'; }
            }
        }
        if(v===1.2 && a.extra && d.extra && ((a.extra==='Light'&&d.extra==='Dark')||(a.extra==='Dark'&&d.extra==='Light'))) { v=1.3; t='(ì¹˜ëª…íƒ€!)'; }
        return {v, t};
    },
    
    die: function(u) { 
        if(u.isDead) return; 
        u.isDead=true; u.hp=0; u.status=[]; 
        Game.log(`${u.name} íƒˆë½`); 
        
        const allies = u.team===0 ? Game.pTeam : Game.eTeam;
        const thorns = allies.filter(a => a.base==='Tree' && a.extra==='Dark' && !a.isDead && a.linkedAllyId === u.id);
        thorns.forEach(thorn => {
            thorn.thornStack += 0.3; thorn.atk += 20; thorn.linkedAllyId = -1; 
            Game.log(`ğŸŒµ [${thorn.name}] ë³µìˆ˜! (ê´‘ì—­ë…)`);
            const enemies = u.team===0 ? Game.eTeam : Game.pTeam;
            enemies.forEach(e => { if(!e.isDead) e.addStatus('POISON', 1, 0); });
            UI.floatText(thorn, "RAGE!", "ft-crit"); 
        });
    },
    endCheck: function() {
        const pd=this.pTeam.every(u=>u.isDead), ed=this.eTeam.every(u=>u.isDead);
        if(pd||ed) { 
            this.isOver = true; 
            if(this.timer) clearTimeout(this.timer);
            AudioSys.play('WIN'); 
            UI.showResult(pd ? "ì êµ°" : "ì•„êµ°"); 
            return true; 
        } 
        return false;
    },
    log: function(m) { const b=document.getElementById('logs'); const d=document.createElement('div'); d.className='log-entry'; d.innerHTML=m; b.appendChild(d); b.scrollTop = b.scrollHeight; },
    render: function() {
        const tl = document.getElementById('tl-track');
        tl.innerHTML = '';
        for(let i=0; i<6; i++) {
            const idx = (this.curr + i) % 6;
            const qId = this.queue[idx]; 
            const isP = qId % 2 === 0;
            const uIdx = isP ? qId/2 : (qId-1)/2;
            const team = isP ? this.pTeam : this.eTeam;
            const u = team[uIdx];
            
            const n = document.createElement('div');
            n.className = `tl-node ${isP?'ally':'enemy'} ${i===0?'curr':''}`;
            if(u.isDead) n.style.opacity = 0.3;
            // [Patch] Use Character Icon for Timeline
            n.innerText = SKILL_DB[u.getKey()].icon || ATTR[u.base].i;
            tl.appendChild(n);
        }

        const draw = (id, team, tid) => {
            const el=document.getElementById(id); el.innerHTML='';
            team.forEach((u) => {
                const myTurnIndex = team.findIndex(m => m.id === u.id);
                let isActive = false;
                if (tid === 0) isActive = this.queue[this.curr] === u.id * 2;
                else isActive = this.queue[this.curr] === (u.id - 3) * 2 + 1;

                const d=document.createElement('div');
                const role = SKILL_DB[u.getKey()].role || 'nuker';
                d.className = `unit role-${role} ${u.isDead?'dead':''} ${isActive?'active-turn':''} ${tid===1?'target-enemy':''} ${tid===0?'target-ally':''}`;
                d.id = tid===0 ? `p-card-${u.id}` : `e-card-${u.id}`;
                
                const tags = u.status.map(s => {
                    let c='tag'; 
                    if(s.type=='POISON') c+=' poison'; else if(s.type=='FREEZE') c+=' freeze'; 
                    else if(s.type.includes('PROVOKED')) c+=' taunt'; else if(s.type=='SILENCE') c+=' silence';
                    else if(s.type=='EVADE') c+=' evade'; else if(s.type=='BURN') c+=' burn';
                    else if(s.type=='BANISH') c+=' banish'; else if(s.type=='TRAP') c+=' trap';
                    else if(s.type=='BIND') c+=' bind'; else if(s.type=='GROWTH') c+=' growth';
                    else if(s.type=='ATK_DOWN') c+=' atkdown'; else if(s.type=='BLIND') c+=' blind';
                    else if(s.type=='ATK_BUFF') c+=' growth'; else if(s.type=='IMMUNITY') c+=' immunity';
                    else if(s.type=='HEAL_DOWN') c+=' healdown'; else if(s.type=='LIGHT_MIGHT') c+=' atkup';
                    
                    let txt = s.type;
                    if(s.type=='POISON') txt='ë…'; if(s.type=='FREEZE') txt='ë¹™ê²°'; 
                    if(s.type.includes('PROVOKED')) txt='ë„ë°œ'; if(s.type=='SILENCE') txt='ì¹¨ë¬µ';
                    if(s.type=='DMG_RED') txt='ë°©ì–´â†‘'; if(s.type=='EVADE') txt='íšŒí”¼';
                    if(s.type=='BURN') txt='í™”ìƒ'; if(s.type=='TRAP') txt='ì†ë°•';
                    if(s.type=='BANISH') txt='ì¶”ë°©'; if(s.type=='BIND') txt='ê²°ì†';
                    if(s.type=='GROWTH') txt='ì„±ì¥'; if(s.type=='ATK_DOWN') txt='ê³µê²©â†“';
                    if(s.type=='BLIND') txt='ì‹¤ëª…'; if(s.type=='ATK_BUFF') txt='í­ì£¼';
                    if(s.type=='IMMUNITY') txt='ë©´ì—­'; if(s.type=='HEAL_DOWN') txt='ì¹˜ìœ â†“';
                    if(s.type=='LIGHT_MIGHT') txt='ê³µê²©â†‘';

                    return `<span class="${c}">${txt}(${s.turn})</span>`;
                }).join('');

                let bgClass = `bg-${u.base}`;
                if(u.isEnhanced) bgClass = `bg-${u.base}-Enhanced`;
                if(u.isNormal) bgClass = 'bg-Normal';

                const icon = SKILL_DB[u.getKey()].icon || ''; 
                d.innerHTML = `
                    <div class="tag-container">${tags}</div>
                    <div class="attr-icon ${bgClass}">${icon || ATTR[u.base].i}<div class="mini-attr-box"><div class="mini-icon">${ATTR[u.base].i}</div>${u.extra ? `<div class="mini-icon">${ATTR[u.extra].i}</div>` : ''}</div></div>
                    <div class="unit-name">${u.name.split(' ')[0]} <span class="atk-text">âš”ï¸${u.getAtk()}</span></div>
                    <div class="status-bar"><div class="hp-fill" style="width:${(u.hp/u.maxHp)*100}%; background:${u.hp<150?'var(--hp-low)':'var(--hp-high)'}"></div><div class="shield-fill" style="width:${(u.shield/u.maxHp)*100}%"></div></div>
                    <div style="font-size:10px; margin-top:3px; color:#b2bec3;">${u.hp}${u.shield>0?` (+${u.shield})`:''}</div>
                `;
                el.appendChild(d);
            });
        };
        draw('player-row', this.pTeam, 0); draw('enemy-row', this.eTeam, 1);
    },
    shake: function(u) { const id = u.team === 0 ? `p-card-${u.id}` : `e-card-${u.id}`; const el = document.getElementById(id); if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); } }
};

window.onload = function() { Game.init(); };
</script>
</body>
</html>
